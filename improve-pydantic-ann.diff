commit e77ab329afafdf6525eedc62dac4b7dd2f40f58d
Author: Wei Ouyang <oeway007@gmail.com>
Date:   Tue Jul 8 16:56:21 2025 -0700

    improve pydantic annotation

diff --git a/python/hypha_rpc/utils/pydantic.py b/python/hypha_rpc/utils/pydantic.py
index 481db20..b90eed8 100644
--- a/python/hypha_rpc/utils/pydantic.py
+++ b/python/hypha_rpc/utils/pydantic.py
@@ -1,8 +1,8 @@
-from typing import Any, Optional, Union
+from typing import Any, Optional, Union, Dict, List, Type
 
 from pydantic import BaseModel, Field, create_model
 
-TYPE_MAPPING: dict[str, type] = {
+TYPE_MAPPING: Dict[str, type] = {
     "string": str,
     "integer": int,
     "number": float,
@@ -12,7 +12,7 @@ TYPE_MAPPING: dict[str, type] = {
     "null": type(None),
 }
 
-CONSTRAINT_MAPPING: dict[str, str] = {
+CONSTRAINT_MAPPING: Dict[str, str] = {
     "minimum": "ge",
     "maximum": "le",
     "exclusiveMinimum": "gt",
@@ -24,7 +24,7 @@ CONSTRAINT_MAPPING: dict[str, str] = {
 }
 
 
-def get_field_params_from_field_schema(field_schema: dict) -> dict:
+def get_field_params_from_field_schema(field_schema: Dict) -> Dict:
     """Gets Pydantic field parameters from a JSON schema field."""
     field_params = {}
     for constraint, constraint_value in CONSTRAINT_MAPPING.items():
@@ -37,11 +37,11 @@ def get_field_params_from_field_schema(field_schema: dict) -> dict:
     return field_params
 
 
-def create_model_from_schema(schema: dict) -> type[BaseModel]:  # noqa: C901
+def create_model_from_schema(schema: Dict) -> Type[BaseModel]:  # noqa: C901
     """Create Pydantic model from a JSON schema generated by `Model.model_json_schema()`."""
-    models: dict[str, type[BaseModel]] = {}
+    models: Dict[str, Type[BaseModel]] = {}
 
-    def resolve_field_type(field_schema: dict) -> type[Any]:
+    def resolve_field_type(field_schema: Dict) -> Type[Any]:
         """Resolves field type, including optional types and nullability."""
         if "$ref" in field_schema:
             model_reference = field_schema["$ref"].split("/")[-1]
@@ -66,7 +66,7 @@ def create_model_from_schema(schema: dict) -> type[BaseModel]:  # noqa: C901
         if field_schema.get("type") == "array":
             items = field_schema.get("items", {})
             item_type = resolve_field_type(items)
-            return list[item_type]  # type: ignore[valid-type]
+            return List[item_type]  # type: ignore[valid-type]
 
         # Handle objects (dicts with specified value types)
         if field_schema.get("type") == "object":
@@ -74,7 +74,7 @@ def create_model_from_schema(schema: dict) -> type[BaseModel]:  # noqa: C901
             value_type = (
                 resolve_field_type(additional_props) if additional_props else Any
             )
-            return dict[str, value_type]  # type: ignore[valid-type]
+            return Dict[str, value_type]  # type: ignore[valid-type]
 
         return field_type  # type: ignore[return-value]
 
@@ -104,7 +104,7 @@ def create_model_from_schema(schema: dict) -> type[BaseModel]:  # noqa: C901
     return create_model(schema.get("title", "MainModel"), **main_fields, __doc__=schema.get("description", ""))  # type: ignore[call-overload]
 
 
-def pydantic_encoder(obj: BaseModel) -> dict:
+def pydantic_encoder(obj: BaseModel) -> Dict:
     """Encode Pydantic model to a serializable dict."""
     return {
         "_rtype": "pydantic_model",
@@ -113,7 +113,7 @@ def pydantic_encoder(obj: BaseModel) -> dict:
     }
 
 
-def pydantic_decoder(encoded_obj: dict) -> BaseModel:
+def pydantic_decoder(encoded_obj: Dict) -> BaseModel:
     """Decode dict back to a Pydantic model instance."""
     model_type = create_model_from_schema(encoded_obj["_rschema"])
     return model_type(**encoded_obj["_rvalue"])
diff --git a/test_revert.py b/test_revert.py
deleted file mode 100644
index fc12abd..0000000
--- a/test_revert.py
+++ /dev/null
@@ -1,53 +0,0 @@
-#!/usr/bin/env python3
-"""Test that context injection works after reverting changes."""
-
-import asyncio
-from hypha_rpc import connect_to_server
-
-async def test_revert():
-    """Test that context injection works with old server after revert."""
-    
-    print("Testing compatibility after reverting changes...")
-    
-    try:
-        # Connect to the old server
-        server = await connect_to_server({
-            "server_url": "https://hypha.aicell.io",
-            "timeout": 30
-        })
-        print("✓ Successfully connected to old server")
-        
-        # Register a simple service that requires context
-        await server.register_service({
-            "id": "test-revert",
-            "config": {"require_context": True, "visibility": "public"},
-            "test": lambda x, context=None: {
-                "input": x,
-                "has_context": context is not None,
-                "workspace": context.get("ws") if context else None
-            }
-        })
-        print("✓ Registered service with require_context")
-        
-        # Get the service and test it
-        svc = await server.get_service("test-revert")
-        result = await svc.test("hello")
-        
-        print(f"Result: {result}")
-        
-        if result["has_context"]:
-            print("✅ SUCCESS: Context injection works after revert!")
-            print(f"Workspace: {result['workspace']}")
-        else:
-            print("❌ FAILED: Context injection not working")
-            
-        await server.disconnect()
-        print("✓ Disconnected")
-        
-    except Exception as e:
-        print(f"❌ Error: {e}")
-        import traceback
-        traceback.print_exc()
-
-if __name__ == "__main__":
-    asyncio.run(test_revert())
\ No newline at end of file
