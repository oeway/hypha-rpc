/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["WebPythonKernel"] = factory();
	else
		root["WebPythonKernel"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/comlink/dist/esm/comlink.mjs":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),\n/* harmony export */   expose: () => (/* binding */ expose),\n/* harmony export */   finalizer: () => (/* binding */ finalizer),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   proxyMarker: () => (/* binding */ proxyMarker),\n/* harmony export */   releaseProxy: () => (/* binding */ releaseProxy),\n/* harmony export */   transfer: () => (/* binding */ transfer),\n/* harmony export */   transferHandlers: () => (/* binding */ transferHandlers),\n/* harmony export */   windowEndpoint: () => (/* binding */ windowEndpoint),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\n\n//# sourceMappingURL=comlink.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCLGtCQUFrQixVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQXlELGdCQUFnQixJQUFJO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5REFBeUQsZ0JBQWdCLElBQUk7QUFDN0UsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUk7QUFDakkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9XZWJQeXRob25LZXJuZWwvLi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcz9lMjg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IHByb3h5TWFya2VyID0gU3ltYm9sKFwiQ29tbGluay5wcm94eVwiKTtcbmNvbnN0IGNyZWF0ZUVuZHBvaW50ID0gU3ltYm9sKFwiQ29tbGluay5lbmRwb2ludFwiKTtcbmNvbnN0IHJlbGVhc2VQcm94eSA9IFN5bWJvbChcIkNvbWxpbmsucmVsZWFzZVByb3h5XCIpO1xuY29uc3QgZmluYWxpemVyID0gU3ltYm9sKFwiQ29tbGluay5maW5hbGl6ZXJcIik7XG5jb25zdCB0aHJvd01hcmtlciA9IFN5bWJvbChcIkNvbWxpbmsudGhyb3duXCIpO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT09IG51bGwpIHx8IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcbi8qKlxuICogSW50ZXJuYWwgdHJhbnNmZXIgaGFuZGxlIHRvIGhhbmRsZSBvYmplY3RzIG1hcmtlZCB0byBwcm94eS5cbiAqL1xuY29uc3QgcHJveHlUcmFuc2ZlckhhbmRsZXIgPSB7XG4gICAgY2FuSGFuZGxlOiAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIHZhbFtwcm94eU1hcmtlcl0sXG4gICAgc2VyaWFsaXplKG9iaikge1xuICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGV4cG9zZShvYmosIHBvcnQxKTtcbiAgICAgICAgcmV0dXJuIFtwb3J0MiwgW3BvcnQyXV07XG4gICAgfSxcbiAgICBkZXNlcmlhbGl6ZShwb3J0KSB7XG4gICAgICAgIHBvcnQuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHdyYXAocG9ydCk7XG4gICAgfSxcbn07XG4vKipcbiAqIEludGVybmFsIHRyYW5zZmVyIGhhbmRsZXIgdG8gaGFuZGxlIHRocm93biBleGNlcHRpb25zLlxuICovXG5jb25zdCB0aHJvd1RyYW5zZmVySGFuZGxlciA9IHtcbiAgICBjYW5IYW5kbGU6ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHRocm93TWFya2VyIGluIHZhbHVlLFxuICAgIHNlcmlhbGl6ZSh7IHZhbHVlIH0pIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWQ7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkID0ge1xuICAgICAgICAgICAgICAgIGlzRXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmFsdWUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFsdWUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VyaWFsaXplZCA9IHsgaXNFcnJvcjogZmFsc2UsIHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzZXJpYWxpemVkLCBbXV07XG4gICAgfSxcbiAgICBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgICAgIGlmIChzZXJpYWxpemVkLmlzRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKHNlcmlhbGl6ZWQudmFsdWUubWVzc2FnZSksIHNlcmlhbGl6ZWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHNlcmlhbGl6ZWQudmFsdWU7XG4gICAgfSxcbn07XG4vKipcbiAqIEFsbG93cyBjdXN0b21pemluZyB0aGUgc2VyaWFsaXphdGlvbiBvZiBjZXJ0YWluIHZhbHVlcy5cbiAqL1xuY29uc3QgdHJhbnNmZXJIYW5kbGVycyA9IG5ldyBNYXAoW1xuICAgIFtcInByb3h5XCIsIHByb3h5VHJhbnNmZXJIYW5kbGVyXSxcbiAgICBbXCJ0aHJvd1wiLCB0aHJvd1RyYW5zZmVySGFuZGxlcl0sXG5dKTtcbmZ1bmN0aW9uIGlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgb3JpZ2luKSB7XG4gICAgZm9yIChjb25zdCBhbGxvd2VkT3JpZ2luIG9mIGFsbG93ZWRPcmlnaW5zKSB7XG4gICAgICAgIGlmIChvcmlnaW4gPT09IGFsbG93ZWRPcmlnaW4gfHwgYWxsb3dlZE9yaWdpbiA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd2VkT3JpZ2luIGluc3RhbmNlb2YgUmVnRXhwICYmIGFsbG93ZWRPcmlnaW4udGVzdChvcmlnaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBleHBvc2Uob2JqLCBlcCA9IGdsb2JhbFRoaXMsIGFsbG93ZWRPcmlnaW5zID0gW1wiKlwiXSkge1xuICAgIGVwLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIGNhbGxiYWNrKGV2KSB7XG4gICAgICAgIGlmICghZXYgfHwgIWV2LmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgZXYub3JpZ2luKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIG9yaWdpbiAnJHtldi5vcmlnaW59JyBmb3IgY29tbGluayBwcm94eWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWQsIHR5cGUsIHBhdGggfSA9IE9iamVjdC5hc3NpZ24oeyBwYXRoOiBbXSB9LCBldi5kYXRhKTtcbiAgICAgICAgY29uc3QgYXJndW1lbnRMaXN0ID0gKGV2LmRhdGEuYXJndW1lbnRMaXN0IHx8IFtdKS5tYXAoZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhdGguc2xpY2UoMCwgLTEpLnJlZHVjZSgob2JqLCBwcm9wKSA9PiBvYmpbcHJvcF0sIG9iaik7XG4gICAgICAgICAgICBjb25zdCByYXdWYWx1ZSA9IHBhdGgucmVkdWNlKChvYmosIHByb3ApID0+IG9ialtwcm9wXSwgb2JqKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJHRVRcIiAvKiBNZXNzYWdlVHlwZS5HRVQgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlNFVFwiIC8qIE1lc3NhZ2VUeXBlLlNFVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50W3BhdGguc2xpY2UoLTEpWzBdXSA9IGZyb21XaXJlVmFsdWUoZXYuZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFQUExZXCIgLyogTWVzc2FnZVR5cGUuQVBQTFkgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWUuYXBwbHkocGFyZW50LCBhcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJDT05TVFJVQ1RcIiAvKiBNZXNzYWdlVHlwZS5DT05TVFJVQ1QgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHJhd1ZhbHVlKC4uLmFyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHByb3h5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiRU5EUE9JTlRcIiAvKiBNZXNzYWdlVHlwZS5FTkRQT0lOVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlKG9iaiwgcG9ydDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cmFuc2Zlcihwb3J0MSwgW3BvcnQxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlJFTEVBU0VcIiAvKiBNZXNzYWdlVHlwZS5SRUxFQVNFICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpXG4gICAgICAgICAgICAuY2F0Y2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgW3Rocm93TWFya2VyXTogMCB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJldHVyblZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbd2lyZVZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJSRUxFQVNFXCIgLyogTWVzc2FnZVR5cGUuUkVMRUFTRSAqLykge1xuICAgICAgICAgICAgICAgIC8vIGRldGFjaCBhbmQgZGVhY3RpdmUgYWZ0ZXIgc2VuZGluZyByZWxlYXNlIHJlc3BvbnNlIGFib3ZlLlxuICAgICAgICAgICAgICAgIGVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxpemVyIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpbmFsaXplcl0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvYmpbZmluYWxpemVyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIFNlbmQgU2VyaWFsaXphdGlvbiBFcnJvciBUbyBDYWxsZXJcbiAgICAgICAgICAgIGNvbnN0IFt3aXJlVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgVHlwZUVycm9yKFwiVW5zZXJpYWxpemFibGUgcmV0dXJuIHZhbHVlXCIpLFxuICAgICAgICAgICAgICAgIFt0aHJvd01hcmtlcl06IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChlcC5zdGFydCkge1xuICAgICAgICBlcC5zdGFydCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpIHtcbiAgICByZXR1cm4gZW5kcG9pbnQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJNZXNzYWdlUG9ydFwiO1xufVxuZnVuY3Rpb24gY2xvc2VFbmRQb2ludChlbmRwb2ludCkge1xuICAgIGlmIChpc01lc3NhZ2VQb3J0KGVuZHBvaW50KSlcbiAgICAgICAgZW5kcG9pbnQuY2xvc2UoKTtcbn1cbmZ1bmN0aW9uIHdyYXAoZXAsIHRhcmdldCkge1xuICAgIGNvbnN0IHBlbmRpbmdMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgZXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldikge1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGV2O1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlciA9IHBlbmRpbmdMaXN0ZW5lcnMuZ2V0KGRhdGEuaWQpO1xuICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmVyKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcGVuZGluZ0xpc3RlbmVycy5kZWxldGUoZGF0YS5pZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIFtdLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNSZWxlYXNlZCkge1xuICAgIGlmIChpc1JlbGVhc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZVwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWxlYXNlRW5kcG9pbnQoZXApIHtcbiAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgbmV3IE1hcCgpLCB7XG4gICAgICAgIHR5cGU6IFwiUkVMRUFTRVwiIC8qIE1lc3NhZ2VUeXBlLlJFTEVBU0UgKi8sXG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIGNsb3NlRW5kUG9pbnQoZXApO1xuICAgIH0pO1xufVxuY29uc3QgcHJveHlDb3VudGVyID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHByb3h5RmluYWxpemVycyA9IFwiRmluYWxpemF0aW9uUmVnaXN0cnlcIiBpbiBnbG9iYWxUaGlzICYmXG4gICAgbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChlcCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSAtIDE7XG4gICAgICAgIHByb3h5Q291bnRlci5zZXQoZXAsIG5ld0NvdW50KTtcbiAgICAgICAgaWYgKG5ld0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZWxlYXNlRW5kcG9pbnQoZXApO1xuICAgICAgICB9XG4gICAgfSk7XG5mdW5jdGlvbiByZWdpc3RlclByb3h5KHByb3h5LCBlcCkge1xuICAgIGNvbnN0IG5ld0NvdW50ID0gKHByb3h5Q291bnRlci5nZXQoZXApIHx8IDApICsgMTtcbiAgICBwcm94eUNvdW50ZXIuc2V0KGVwLCBuZXdDb3VudCk7XG4gICAgaWYgKHByb3h5RmluYWxpemVycykge1xuICAgICAgICBwcm94eUZpbmFsaXplcnMucmVnaXN0ZXIocHJveHksIGVwLCBwcm94eSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW5yZWdpc3RlclByb3h5KHByb3h5KSB7XG4gICAgaWYgKHByb3h5RmluYWxpemVycykge1xuICAgICAgICBwcm94eUZpbmFsaXplcnMudW5yZWdpc3Rlcihwcm94eSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHBhdGggPSBbXSwgdGFyZ2V0ID0gZnVuY3Rpb24gKCkgeyB9KSB7XG4gICAgbGV0IGlzUHJveHlSZWxlYXNlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRhcmdldCwge1xuICAgICAgICBnZXQoX3RhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSByZWxlYXNlUHJveHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyUHJveHkocHJveHkpO1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlRW5kcG9pbnQoZXApO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlzUHJveHlSZWxlYXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wID09PSBcInRoZW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0aGVuOiAoKSA9PiBwcm94eSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByID0gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiIC8qIE1lc3NhZ2VUeXBlLkdFVCAqLyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50aGVuLmJpbmQocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIFsuLi5wYXRoLCBwcm9wXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChfdGFyZ2V0LCBwcm9wLCByYXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBFUzYgUHJveHkgSGFuZGxlciBgc2V0YCBtZXRob2RzIGFyZSBzdXBwb3NlZCB0byByZXR1cm4gYVxuICAgICAgICAgICAgLy8gYm9vbGVhbi4gVG8gc2hvdyBnb29kIHdpbGwsIHdlIHJldHVybiB0cnVlIGFzeW5jaHJvbm91c2x5IMKvXFxfKOODhClfL8KvXG4gICAgICAgICAgICBjb25zdCBbdmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmF3VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlNFVFwiIC8qIE1lc3NhZ2VUeXBlLlNFVCAqLyxcbiAgICAgICAgICAgICAgICBwYXRoOiBbLi4ucGF0aCwgcHJvcF0ubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwbHkoX3RhcmdldCwgX3RoaXNBcmcsIHJhd0FyZ3VtZW50TGlzdCkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCA9PT0gY3JlYXRlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkVORFBPSU5UXCIgLyogTWVzc2FnZVR5cGUuRU5EUE9JTlQgKi8sXG4gICAgICAgICAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGp1c3QgcHJldGVuZCB0aGF0IGBiaW5kKClgIGRpZG7igJl0IGhhcHBlbi5cbiAgICAgICAgICAgIGlmIChsYXN0ID09PSBcImJpbmRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQVBQTFlcIiAvKiBNZXNzYWdlVHlwZS5BUFBMWSAqLyxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudExpc3QsXG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBjb25zdHJ1Y3QoX3RhcmdldCwgcmF3QXJndW1lbnRMaXN0KSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQ09OU1RSVUNUXCIgLyogTWVzc2FnZVR5cGUuQ09OU1RSVUNUICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50TGlzdCxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJQcm94eShwcm94eSwgZXApO1xuICAgIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIG15RmxhdChhcnIpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NBcmd1bWVudHMoYXJndW1lbnRMaXN0KSB7XG4gICAgY29uc3QgcHJvY2Vzc2VkID0gYXJndW1lbnRMaXN0Lm1hcCh0b1dpcmVWYWx1ZSk7XG4gICAgcmV0dXJuIFtwcm9jZXNzZWQubWFwKCh2KSA9PiB2WzBdKSwgbXlGbGF0KHByb2Nlc3NlZC5tYXAoKHYpID0+IHZbMV0pKV07XG59XG5jb25zdCB0cmFuc2ZlckNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHRyYW5zZmVyKG9iaiwgdHJhbnNmZXJzKSB7XG4gICAgdHJhbnNmZXJDYWNoZS5zZXQob2JqLCB0cmFuc2ZlcnMpO1xuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBwcm94eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIHsgW3Byb3h5TWFya2VyXTogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIHdpbmRvd0VuZHBvaW50KHcsIGNvbnRleHQgPSBnbG9iYWxUaGlzLCB0YXJnZXRPcmlnaW4gPSBcIipcIikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvc3RNZXNzYWdlOiAobXNnLCB0cmFuc2ZlcmFibGVzKSA9PiB3LnBvc3RNZXNzYWdlKG1zZywgdGFyZ2V0T3JpZ2luLCB0cmFuc2ZlcmFibGVzKSxcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogY29udGV4dC5hZGRFdmVudExpc3RlbmVyLmJpbmQoY29udGV4dCksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGNvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKGNvbnRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1dpcmVWYWx1ZSh2YWx1ZSkge1xuICAgIGZvciAoY29uc3QgW25hbWUsIGhhbmRsZXJdIG9mIHRyYW5zZmVySGFuZGxlcnMpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIuY2FuSGFuZGxlKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgW3NlcmlhbGl6ZWRWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSBoYW5kbGVyLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJIQU5ETEVSXCIgLyogV2lyZVZhbHVlVHlwZS5IQU5ETEVSICovLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJSQVdcIiAvKiBXaXJlVmFsdWVUeXBlLlJBVyAqLyxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlckNhY2hlLmdldCh2YWx1ZSkgfHwgW10sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGZyb21XaXJlVmFsdWUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkhBTkRMRVJcIiAvKiBXaXJlVmFsdWVUeXBlLkhBTkRMRVIgKi86XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmZXJIYW5kbGVycy5nZXQodmFsdWUubmFtZSkuZGVzZXJpYWxpemUodmFsdWUudmFsdWUpO1xuICAgICAgICBjYXNlIFwiUkFXXCIgLyogV2lyZVZhbHVlVHlwZS5SQVcgKi86XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywgbXNnLCB0cmFuc2ZlcnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICAgICAgcGVuZGluZ0xpc3RlbmVycy5zZXQoaWQsIHJlc29sdmUpO1xuICAgICAgICBpZiAoZXAuc3RhcnQpIHtcbiAgICAgICAgICAgIGVwLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7IGlkIH0sIG1zZyksIHRyYW5zZmVycyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheSg0KVxuICAgICAgICAuZmlsbCgwKVxuICAgICAgICAubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKS50b1N0cmluZygxNikpXG4gICAgICAgIC5qb2luKFwiLVwiKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRW5kcG9pbnQsIGV4cG9zZSwgZmluYWxpemVyLCBwcm94eSwgcHJveHlNYXJrZXIsIHJlbGVhc2VQcm94eSwgdHJhbnNmZXIsIHRyYW5zZmVySGFuZGxlcnMsIHdpbmRvd0VuZHBvaW50LCB3cmFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21saW5rLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/comlink/dist/esm/comlink.mjs\n\n}");

/***/ }),

/***/ "./src/_pypi.ts":
/*!**********************!*\
  !*** ./src/_pypi.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allJSONUrl: () => (/* binding */ allJSONUrl),\n/* harmony export */   ipykernelWheelUrl: () => (/* binding */ ipykernelWheelUrl),\n/* harmony export */   pipliteWheelUrl: () => (/* binding */ pipliteWheelUrl),\n/* harmony export */   pyodide_kernelWheelUrl: () => (/* binding */ pyodide_kernelWheelUrl),\n/* harmony export */   widgetsnbextensionWheelUrl: () => (/* binding */ widgetsnbextensionWheelUrl),\n/* harmony export */   widgetsnbextensionWheelUrl1: () => (/* binding */ widgetsnbextensionWheelUrl1)\n/* harmony export */ });\n// this file is autogenerated from the wheels in the pypi directory\nconst allJSONUrl = \"pypi/all.json\";\nconst ipykernelWheelUrl = \"pypi/ipykernel-6.9.2-py3-none-any.whl\";\nconst pipliteWheelUrl = \"pypi/piplite-0.6.0a5-py3-none-any.whl\";\nconst pyodide_kernelWheelUrl = \"pypi/pyodide_kernel-0.6.0a5-py3-none-any.whl\";\nconst widgetsnbextensionWheelUrl = \"pypi/widgetsnbextension-3.6.999-py3-none-any.whl\";\nconst widgetsnbextensionWheelUrl1 = \"pypi/widgetsnbextension-4.0.999-py3-none-any.whl\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvX3B5cGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsbUVBQW1FO0FBQzVELE1BQU0sVUFBVSxHQUFHLGVBQWUsQ0FBQztBQUNuQyxNQUFNLGlCQUFpQixHQUFHLHVDQUF1QyxDQUFDO0FBQ2xFLE1BQU0sZUFBZSxHQUFHLHVDQUF1QyxDQUFDO0FBQ2hFLE1BQU0sc0JBQXNCLEdBQUcsOENBQThDLENBQUM7QUFDOUUsTUFBTSwwQkFBMEIsR0FBRyxrREFBa0QsQ0FBQztBQUN0RixNQUFNLDJCQUEyQixHQUFHLGtEQUFrRCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vV2ViUHl0aG9uS2VybmVsLy4vc3JjL19weXBpLnRzP2U4NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGhpcyBmaWxlIGlzIGF1dG9nZW5lcmF0ZWQgZnJvbSB0aGUgd2hlZWxzIGluIHRoZSBweXBpIGRpcmVjdG9yeVxuZXhwb3J0IGNvbnN0IGFsbEpTT05VcmwgPSBcInB5cGkvYWxsLmpzb25cIjtcbmV4cG9ydCBjb25zdCBpcHlrZXJuZWxXaGVlbFVybCA9IFwicHlwaS9pcHlrZXJuZWwtNi45LjItcHkzLW5vbmUtYW55LndobFwiO1xuZXhwb3J0IGNvbnN0IHBpcGxpdGVXaGVlbFVybCA9IFwicHlwaS9waXBsaXRlLTAuNi4wYTUtcHkzLW5vbmUtYW55LndobFwiO1xuZXhwb3J0IGNvbnN0IHB5b2RpZGVfa2VybmVsV2hlZWxVcmwgPSBcInB5cGkvcHlvZGlkZV9rZXJuZWwtMC42LjBhNS1weTMtbm9uZS1hbnkud2hsXCI7XG5leHBvcnQgY29uc3Qgd2lkZ2V0c25iZXh0ZW5zaW9uV2hlZWxVcmwgPSBcInB5cGkvd2lkZ2V0c25iZXh0ZW5zaW9uLTMuNi45OTktcHkzLW5vbmUtYW55LndobFwiO1xuZXhwb3J0IGNvbnN0IHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsMSA9IFwicHlwaS93aWRnZXRzbmJleHRlbnNpb24tNC4wLjk5OS1weTMtbm9uZS1hbnkud2hsXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/_pypi.ts\n\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Kernel: () => (/* binding */ Kernel),\n/* harmony export */   KernelEvents: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents),\n/* harmony export */   KernelManager: () => (/* reexport safe */ _manager__WEBPACK_IMPORTED_MODULE_3__.KernelManager)\n/* harmony export */ });\n/* harmony import */ var _pyodide_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pyodide-loader */ \"./src/pyodide-loader.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _pypi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_pypi */ \"./src/_pypi.ts\");\n/* harmony import */ var _manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manager */ \"./src/manager.ts\");\n// Kernel implementation for Deno using Pyodide directly\n// Based on the PyodideRemoteKernel but adapted for direct execution in main thread\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n    setMaxListeners(n) {\n        // No-op for browser compatibility\n    }\n}\n// @ts-ignore Importing from npm\n\n// Import types and enums\n\n// Import PyPI URLs\n\n// Event types from JupyterLab\n// Re-export types to maintain backward compatibility\n\nclass Kernel extends EventEmitter {\n    constructor() {\n        super();\n        this.initialized = false;\n        this.initPromise = null;\n        // Filesystem options\n        this.filesystemOptions = {\n            enabled: false,\n            root: \".\",\n            mountPoint: \"/home/pyodide\"\n        };\n        // Input handling\n        this._resolveInputReply = null;\n        // Execution state\n        this._parent_header = {};\n        this.executionCount = 0;\n        this._status = \"unknown\";\n        // Interrupt handling\n        this._interruptBuffer = null;\n        this._interruptSupported = false;\n        // Environment variables\n        this.environmentVariables = {};\n        super.setMaxListeners(20);\n        // Generate a unique ID for this kernel instance\n        this.kernelId = `kernel_${Math.random().toString(36).substring(2)}_${Date.now()}`;\n    }\n    // Async method for kernel status\n    async getStatus() {\n        return this._status;\n    }\n    /**\n     * Initialize the kernel with maximum performance optimizations\n     * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n     */\n    async initialize(options) {\n        if (this.initialized) {\n            return;\n        }\n        if (this.initPromise) {\n            return this.initPromise;\n        }\n        // Set filesystem options if provided\n        if (options?.filesystem) {\n            this.filesystemOptions = {\n                ...this.filesystemOptions,\n                ...options.filesystem\n            };\n        }\n        // Set environment variables if provided\n        if (options?.env) {\n            this.environmentVariables = { ...options.env };\n        }\n        this.initPromise = this._initializeInternal();\n        return this.initPromise;\n    }\n    /**\n     * Initialize the kernel with maximum performance optimizations\n     * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n     */\n    async _initializeInternal() {\n        const startTime = Date.now();\n        console.log(\"🚀 Starting optimized kernel initialization...\");\n        try {\n            // Load Pyodide from CDN\n            const pyodideStartTime = Date.now();\n            // Use our CDN loader - it will automatically handle main thread vs worker\n            this.pyodide = await (0,_pyodide_loader__WEBPACK_IMPORTED_MODULE_0__.loadPyodide)();\n            const pyodideTime = Date.now() - pyodideStartTime;\n            console.log(`✅ Pyodide loaded in ${pyodideTime}ms`);\n            // Initialize core components in parallel\n            const [, ,] = await Promise.all([\n                // 1. Filesystem mounting (if enabled)\n                this.filesystemOptions.enabled ? this.mountFilesystem() : Promise.resolve(),\n                // 2. Package manager initialization\n                this.initPackageManager(),\n                // 3. Environment variables setup\n                this.setEnvironmentVariables()\n            ]);\n            // Install packages and initialize globals\n            await this.initKernel();\n            await this.initGlobals();\n            const totalTime = Date.now() - startTime;\n            console.log(`🎯 KERNEL INITIALIZATION COMPLETE in ${totalTime}ms`);\n            console.log(`⚡ Performance: Pyodide(${pyodideTime}ms) + Setup(${totalTime - pyodideTime}ms)`);\n            // Mark as initialized\n            this.initialized = true;\n            this._status = \"active\";\n            console.log(\"🟢 Kernel is now ACTIVE and ready for execution!\");\n        }\n        catch (error) {\n            console.error(\"❌ Kernel initialization failed:\", error);\n            this._status = \"unknown\";\n            throw error;\n        }\n    }\n    /**\n     * Mount the local filesystem to the Pyodide environment\n     */\n    async mountFilesystem() {\n        try {\n            console.log(`Mounting filesystem from ${this.filesystemOptions.root} to ${this.filesystemOptions.mountPoint}`);\n            // Use the same approach as in deno-demo-fs-asgi.js for maximum compatibility\n            // Simple and direct mounting of the filesystem\n            await this.pyodide.FS.mount(this.pyodide.FS.filesystems.NODEFS, { root: this.filesystemOptions.root || \".\" }, this.filesystemOptions.mountPoint || \"/home/pyodide\");\n            console.log(\"Filesystem mounted successfully\");\n            // Verify the mount by listing the directory\n            try {\n                const mountedFiles = this.pyodide.FS.readdir(this.filesystemOptions.mountPoint || \"/home/pyodide\");\n                console.log(`Files in ${this.filesystemOptions.mountPoint} directory: ${mountedFiles.join(\", \")}`);\n            }\n            catch (error) {\n                console.error(`Error listing mounted directory: ${error}`);\n            }\n        }\n        catch (error) {\n            console.error(\"Error mounting filesystem:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Initialize the Pyodide package manager with optimized wheel loading\n     * OPTIMIZED: Smart caching and parallel wheel installation\n     */\n    async initPackageManager() {\n        const startTime = Date.now();\n        console.log(\"⚡ Initializing optimized package manager...\");\n        try {\n            // Load micropip and packaging in parallel\n            console.log(\"📦 Loading micropip, packaging...\");\n            await this.pyodide.loadPackage(['micropip', 'packaging']);\n            console.log(\"✅ Loaded micropip, packaging\");\n            // Get the base URL - use window.location for browser or fallback for worker\n            let baseUrl;\n            if (typeof window !== 'undefined' && window.location) {\n                // In main thread - use window.location\n                baseUrl = new URL(\".\", window.location.href).href;\n            }\n            else if (typeof self !== 'undefined' && self.location) {\n                // In web worker - use self.location\n                baseUrl = new URL(\".\", self.location.href).href;\n            }\n            else {\n                // Fallback - assume current origin\n                baseUrl = \"/\";\n            }\n            const allJsonPath = new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.allJSONUrl, baseUrl).href;\n            // Prepare all wheel URLs for parallel loading\n            const wheelFiles = [\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.pipliteWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.pyodide_kernelWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.ipykernelWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.widgetsnbextensionWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.widgetsnbextensionWheelUrl1, baseUrl).href,\n            ];\n            console.log(`🚀 Installing ${wheelFiles.length} wheel packages in parallel...`);\n            // Install all wheel packages in parallel for maximum speed\n            const wheelPromises = wheelFiles.map(async (wheelUrl, index) => {\n                const wheelStartTime = Date.now();\n                try {\n                    await this.pyodide.runPythonAsync(`\nimport micropip\nawait micropip.install('${wheelUrl}', keep_going=True)\nprint(f\"✅ Wheel ${index + 1}/${wheelFiles.length} installed\")\n`);\n                    const wheelTime = Date.now() - wheelStartTime;\n                    console.log(`⚡ Wheel ${index + 1} installed in ${wheelTime}ms`);\n                    return { index, success: true, time: wheelTime };\n                }\n                catch (error) {\n                    const wheelTime = Date.now() - wheelStartTime;\n                    console.warn(`⚠️ Wheel ${index + 1} failed after ${wheelTime}ms:`, error);\n                    return { index, success: false, time: wheelTime, error };\n                }\n            });\n            // Wait for all wheel installations\n            const wheelResults = await Promise.all(wheelPromises);\n            const successful = wheelResults.filter(r => r.success);\n            const failed = wheelResults.filter(r => !r.success);\n            console.log(`📊 Wheels: ${successful.length}/${wheelFiles.length} successful`);\n            if (failed.length > 0) {\n                console.warn(`⚠️ Failed wheels: ${failed.map(f => f.index + 1).join(', ')}`);\n            }\n            // Set up piplite configuration with performance optimizations (if available)\n            try {\n                await this.pyodide.runPythonAsync(`\ntry:\n    import piplite.piplite\n    import json\n\n    # Load package index for faster lookups\n    try:\n        piplite.piplite.PIPLITE_URL = \"${allJsonPath}\"\n        # Pre-load package index for faster installation\n        print(\"📋 Package index configured\")\n    except Exception as e:\n        print(f\"⚠️ Package index setup warning: {e}\")\n\n    # Configure piplite for optimal performance\n    piplite.piplite.REPODATA_INFO = {}\n    print(\"⚡ Piplite optimized for performance\")\nexcept ImportError:\n    print(\"⚠️ Piplite not available, continuing without it\")\nexcept Exception as e:\n    print(f\"⚠️ Piplite setup failed: {e}\")\n`);\n            }\n            catch (error) {\n                console.warn(\"⚠️ Piplite configuration failed, continuing without it:\", error);\n            }\n            const totalTime = Date.now() - startTime;\n            console.log(`🎯 Package manager initialized in ${totalTime}ms`);\n        }\n        catch (error) {\n            console.error(\"❌ Package manager initialization failed:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Initialize the kernel with required Python packages\n     * OPTIMIZED: Maximum parallelization with intelligent dependency resolution\n     */\n    async initKernel() {\n        const startTime = Date.now();\n        console.log(\"🚀 Initializing kernel packages with maximum optimization...\");\n        // All packages to install with priority and dependency information\n        const packageConfig = [\n            // High priority: CDN packages (fastest)\n            { name: 'pure-eval', priority: 1, source: 'pyodide' },\n            { name: 'stack-data', priority: 1, source: 'pyodide' },\n            { name: 'pygments', priority: 1, source: 'pyodide' },\n            { name: 'ssl', priority: 1, source: 'pyodide' },\n            { name: 'sqlite3', priority: 1, source: 'pyodide' },\n            { name: 'prompt_toolkit', priority: 1, source: 'pyodide' },\n            { name: 'jedi', priority: 1, source: 'pyodide' },\n            { name: 'ipython', priority: 1, source: 'pyodide' },\n            // Medium priority: pip packages\n            { name: 'comm', priority: 2, source: 'pip' },\n            { name: 'hypha-rpc', priority: 2, source: 'pip' },\n            { name: 'nbformat', priority: 2, source: 'pip' },\n            // Lower priority: complex packages\n            { name: 'ipykernel', priority: 3, source: 'pip' },\n            { name: 'pyodide_kernel', priority: 3, source: 'pip' }\n        ];\n        try {\n            console.log(`📦 Installing ${packageConfig.length} packages with intelligent optimization...`);\n            // Install ALL packages in parallel with advanced error handling and caching\n            await this.installPackagesWithIntelligentOptimization(packageConfig);\n            // Import the kernel (must be done after packages are installed)\n            console.log(\"📥 Importing pyodide_kernel...\");\n            const importStartTime = Date.now();\n            await this.pyodide.runPythonAsync('import pyodide_kernel');\n            const importTime = Date.now() - importStartTime;\n            console.log(`✅ pyodide_kernel imported in ${importTime}ms`);\n            const totalTime = Date.now() - startTime;\n            console.log(`🎯 Kernel packages initialized in ${totalTime}ms`);\n        }\n        catch (error) {\n            console.error(\"❌ Kernel package initialization failed:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Install packages with intelligent optimization and advanced caching\n     * OPTIMIZED: Smart source selection, parallel installation, and performance monitoring\n     */\n    async installPackagesWithIntelligentOptimization(packageConfig) {\n        console.log(`⚡ Starting intelligent parallel installation of ${packageConfig.length} packages...`);\n        const installPromises = packageConfig.map(async (pkg) => {\n            const startTime = Date.now();\n            try {\n                console.log(`🔄 Installing ${pkg.name} (priority: ${pkg.priority}, preferred: ${pkg.source})...`);\n                // Try preferred source first, with intelligent fallback\n                if (pkg.source === 'pyodide') {\n                    try {\n                        await this.pyodide.loadPackage([pkg.name]);\n                        const duration = Date.now() - startTime;\n                        console.log(`✅ ${pkg.name} loaded from Pyodide CDN (${duration}ms)`);\n                        return { package: pkg.name, method: 'pyodide', duration, success: true, priority: pkg.priority };\n                    }\n                    catch (pyodideError) {\n                        // Fallback to pip with enhanced error handling\n                        console.log(`📦 ${pkg.name} not available on CDN, trying pip...`);\n                        await this.installViaPipWithOptimizations(pkg.name);\n                        const duration = Date.now() - startTime;\n                        console.log(`✅ ${pkg.name} installed via pip fallback (${duration}ms)`);\n                        return { package: pkg.name, method: 'pip-fallback', duration, success: true, priority: pkg.priority };\n                    }\n                }\n                else {\n                    // Direct pip installation with optimizations\n                    await this.installViaPipWithOptimizations(pkg.name);\n                    const duration = Date.now() - startTime;\n                    console.log(`✅ ${pkg.name} installed via pip (${duration}ms)`);\n                    return { package: pkg.name, method: 'pip', duration, success: true, priority: pkg.priority };\n                }\n            }\n            catch (error) {\n                const duration = Date.now() - startTime;\n                console.warn(`❌ Failed to install ${pkg.name} after ${duration}ms:`, error);\n                return { package: pkg.name, method: 'failed', duration, success: false, priority: pkg.priority, error };\n            }\n        });\n        // Wait for all installations with detailed analysis\n        const results = await Promise.all(installPromises);\n        // Comprehensive performance analysis\n        this.analyzeInstallationResults(results);\n    }\n    /**\n     * Install package via pip with performance optimizations\n     */\n    async installViaPipWithOptimizations(packageName) {\n        await this.pyodide.runPythonAsync(`\ntry:\n    # Use optimized pip installation with caching\n    await piplite.install('${packageName}', keep_going=True, deps=True)\n    print(\"✅ Successfully installed ${packageName} via optimized pip\")\nexcept Exception as e:\n    print(\"⚠️ Warning: Failed to install ${packageName}:\", str(e))\n    # Try alternative installation method\n    try:\n        import micropip\n        await micropip.install('${packageName}', keep_going=True)\n        print(\"✅ Successfully installed ${packageName} via micropip fallback\")\n    except Exception as e2:\n        print(\"❌ Both pip methods failed for ${packageName}:\", str(e2))\n        raise e2\n`);\n    }\n    /**\n     * Analyze installation results and provide performance insights\n     */\n    analyzeInstallationResults(results) {\n        const successful = results.filter(r => r.success);\n        const failed = results.filter(r => !r.success);\n        const pyodideInstalls = successful.filter(r => r.method === 'pyodide');\n        const pipInstalls = successful.filter(r => r.method === 'pip');\n        const fallbackInstalls = successful.filter(r => r.method === 'pip-fallback');\n        const totalDuration = Math.max(...results.map(r => r.duration));\n        const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;\n        const estimatedSequential = results.reduce((sum, r) => sum + r.duration, 0);\n        console.log(`🎯 INTELLIGENT INSTALLATION COMPLETE!`);\n        console.log(`📊 Results: ${successful.length}/${results.length} successful`);\n        console.log(`⚡ Pyodide CDN: ${pyodideInstalls.length} packages`);\n        console.log(`📦 Direct pip: ${pipInstalls.length} packages`);\n        console.log(`🔄 Pip fallback: ${fallbackInstalls.length} packages`);\n        console.log(`❌ Failed: ${failed.length} packages`);\n        console.log(`⏱️  Total time: ${totalDuration}ms (vs ~${estimatedSequential}ms sequential)`);\n        console.log(`🚀 Speed improvement: ~${Math.round(estimatedSequential / totalDuration)}x faster`);\n        console.log(`📈 Average per package: ${Math.round(avgDuration)}ms`);\n        if (failed.length > 0) {\n            console.warn(`⚠️  Failed packages: ${failed.map(f => f.package).join(', ')}`);\n            // Log specific failure reasons for debugging\n            failed.forEach(f => {\n                console.warn(`   - ${f.package}: ${f.error?.message || 'Unknown error'}`);\n            });\n        }\n        // Performance insights\n        const fastestInstall = Math.min(...successful.map(r => r.duration));\n        const slowestInstall = Math.max(...successful.map(r => r.duration));\n        console.log(`📊 Performance range: ${fastestInstall}ms (fastest) to ${slowestInstall}ms (slowest)`);\n    }\n    /**\n     * Initialize global objects from the pyodide_kernel package\n     * Based on the PyodideRemoteKernel implementation\n     */\n    async initGlobals() {\n        console.log(\"Initializing globals...\");\n        // Get the globals from the Python environment\n        const { globals } = this.pyodide;\n        // Get the kernel instance and related objects\n        this._kernel = globals.get('pyodide_kernel').kernel_instance.copy();\n        this._stdout_stream = globals.get('pyodide_kernel').stdout_stream.copy();\n        this._stderr_stream = globals.get('pyodide_kernel').stderr_stream.copy();\n        this._interpreter = this._kernel.interpreter.copy();\n        // Set up communication handlers\n        this._interpreter.send_comm = this.sendComm.bind(this);\n        // Set up callbacks\n        this.setupCallbacks();\n    }\n    /**\n     * Setup all necessary callbacks for the Python environment\n     */\n    setupCallbacks() {\n        // Execution result callback\n        const publishExecutionResult = (prompt_count, data, metadata) => {\n            const bundle = {\n                execution_count: prompt_count,\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'execute_result',\n            });\n        };\n        // Error callback\n        const publishExecutionError = (ename, evalue, traceback) => {\n            const bundle = {\n                ename: ename,\n                evalue: evalue,\n                traceback: traceback,\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'execute_error',\n            });\n        };\n        // Clear output callback\n        const clearOutputCallback = (wait) => {\n            const bundle = {\n                wait: this.formatResult(wait),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'clear_output',\n            });\n        };\n        // Display data callback\n        const displayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'display_data',\n            });\n        };\n        // Update display data callback\n        const updateDisplayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'update_display_data',\n            });\n        };\n        // Stream callback\n        const publishStreamCallback = (name, text) => {\n            const bundle = {\n                name: this.formatResult(name),\n                text: this.formatResult(text),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'stream',\n            });\n        };\n        // Assign callbacks to the Python objects\n        this._stdout_stream.publish_stream_callback = publishStreamCallback;\n        this._stderr_stream.publish_stream_callback = publishStreamCallback;\n        this._interpreter.display_pub.clear_output_callback = clearOutputCallback;\n        this._interpreter.display_pub.display_data_callback = displayDataCallback;\n        this._interpreter.display_pub.update_display_data_callback = updateDisplayDataCallback;\n        this._interpreter.displayhook.publish_execution_result = publishExecutionResult;\n        this._interpreter.input = this.input.bind(this);\n        this._interpreter.getpass = this.getpass.bind(this);\n    }\n    /**\n     * Process a message from Python environment\n     */\n    _sendMessage(msg) {\n        this._processMessage(msg);\n    }\n    /**\n     * Process a message by emitting the appropriate event\n     */\n    _processMessage(msg) {\n        if (!msg.type) {\n            return;\n        }\n        let eventData;\n        switch (msg.type) {\n            case 'stream': {\n                const bundle = msg.bundle ?? { name: 'stdout', text: '' };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.STREAM, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'input_request': {\n                const content = msg.content ?? { prompt: '', password: false };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.INPUT_REQUEST, content);\n                eventData = content;\n                break;\n            }\n            case 'display_data': {\n                const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.DISPLAY_DATA, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'update_display_data': {\n                const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.UPDATE_DISPLAY_DATA, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'clear_output': {\n                const bundle = msg.bundle ?? { wait: false };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.CLEAR_OUTPUT, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'execute_result': {\n                const bundle = msg.bundle ?? {\n                    execution_count: this.executionCount,\n                    data: {},\n                    metadata: {},\n                };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_RESULT, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'execute_error': {\n                const bundle = msg.bundle ?? { ename: '', evalue: '', traceback: [] };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'comm_open':\n            case 'comm_msg':\n            case 'comm_close': {\n                const content = msg.content ?? {};\n                super.emit(msg.type, content, msg.metadata, msg.buffers);\n                eventData = {\n                    content,\n                    metadata: msg.metadata,\n                    buffers: msg.buffers\n                };\n                break;\n            }\n        }\n        // Emit the ALL event with standardized format\n        if (eventData) {\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, {\n                type: msg.type,\n                data: eventData\n            });\n        }\n    }\n    /**\n     * Check if the kernel has been initialized\n     */\n    isInitialized() {\n        return this.initialized;\n    }\n    /**\n     * Makes sure pyodide is ready before continuing, and cache the parent message.\n     */\n    async setup(parent) {\n        await this.initialize();\n        this._parent_header = this.pyodide.toPy(parent || {});\n    }\n    /**\n     * Execute code in the kernel with proper message-based completion detection\n     *\n     * @param code The code to execute\n     * @param parent Parent message header\n     * @returns The result of the execution\n     */\n    async execute(code, parent = {}) {\n        if (!this.initialized) {\n            await this.initialize();\n        }\n        try {\n            this._status = \"busy\";\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_BUSY, {});\n            await this.setup(parent);\n            // Reset namespace for this kernel to ensure isolation between kernels\n            const namespaceReset = `\n# Kernel isolation - reset commonly conflicting variables to prevent cross-kernel state sharing\nfor _var in ['x', 'value', 'result', 'a', 'b', 'c', 'data', 'temp']:\n    if _var in globals():\n        del globals()[_var]\ndel _var\n`;\n            this.pyodide.runPython(namespaceReset);\n            // Create a promise that resolves only when execution is truly complete\n            return new Promise((resolve, reject) => {\n                const executionState = {\n                    allMessages: [],\n                    executionComplete: false,\n                    executionResult: null,\n                    executionError: null,\n                    timeout: null\n                };\n                // Set up message collector that captures ALL output before completion\n                const messageCollector = (eventData) => {\n                    executionState.allMessages.push(eventData);\n                    // Debug logging to trace message flow\n                    // console.log(`[KERNEL] Captured message: ${eventData.type}`, eventData.data);\n                };\n                // Set up completion detector\n                const completionDetector = async (executedCode) => {\n                    if (executionState.executionComplete) {\n                        return; // Already completed\n                    }\n                    console.log(`[KERNEL] Execution completed, processing ${executionState.allMessages.length} messages`);\n                    // Mark as complete to prevent multiple resolutions\n                    executionState.executionComplete = true;\n                    // Clean up listeners\n                    super.off(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, messageCollector);\n                    // Process collected messages to determine final result and extract computed value\n                    let hasError = false;\n                    let errorInfo = null;\n                    let computedResult = undefined;\n                    // First check if the direct result from _kernel.run() indicates an error\n                    const directResult = executionState.executionResult;\n                    if (directResult && directResult.status === 'error') {\n                        hasError = true;\n                        errorInfo = {\n                            ename: directResult.ename,\n                            evalue: directResult.evalue,\n                            traceback: directResult.traceback\n                        };\n                    }\n                    // Then check messages for execute_error or execute_result\n                    for (const message of executionState.allMessages) {\n                        if (message.type === 'execute_error') {\n                            hasError = true;\n                            errorInfo = message.data;\n                            break;\n                        }\n                        else if (message.type === 'execute_result') {\n                            // Store execute_result for compatibility but don't extract computed values\n                            computedResult = message.data;\n                        }\n                    }\n                    this._status = \"active\";\n                    super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_IDLE, {});\n                    if (hasError) {\n                        console.log(`[KERNEL] Execution failed with error:`, errorInfo);\n                        // Emit execute_error event for error streams\n                        // Clean up error name format (remove <class '...'> wrapper)\n                        const cleanErrorName = errorInfo.ename ? errorInfo.ename.replace(/^<class '(.+)'>$/, '$1') : errorInfo.ename;\n                        super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                            ename: cleanErrorName,\n                            evalue: errorInfo.evalue,\n                            traceback: errorInfo.traceback\n                        });\n                        const errorMsg = `${errorInfo.ename || 'Error'}: ${errorInfo.evalue || 'Unknown error'}`;\n                        resolve({\n                            success: false,\n                            error: new Error(errorMsg),\n                            result: executionState.executionResult\n                        });\n                    }\n                    else {\n                        console.log(`[KERNEL] Execution successful, captured ${executionState.allMessages.length} output messages`);\n                        let finalResult = computedResult !== undefined ? computedResult : executionState.executionResult;\n                        resolve({\n                            success: true,\n                            result: finalResult\n                        });\n                    }\n                };\n                // Install message collector BEFORE executing code\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, messageCollector);\n                // Execute the code and handle completion\n                this._kernel.run(code).then((result) => {\n                    console.log(\"[KERNEL] Python execution finished, waiting for messages to settle\");\n                    executionState.executionResult = this.formatResult(result);\n                    // Wait a small amount of time for any remaining messages to be processed\n                    // This ensures all stdout/stderr streams have been captured\n                    setTimeout(() => {\n                        completionDetector(code);\n                    }, 100); // 100ms should be enough for message processing\n                }).catch((error) => {\n                    console.error(\"[KERNEL] Python execution error:\", error);\n                    executionState.executionError = error instanceof Error ? error : new Error(String(error));\n                    // Still wait for messages to settle before completing\n                    setTimeout(() => {\n                        completionDetector(code);\n                    }, 100);\n                });\n            });\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Execute setup error:\", error);\n            this._status = \"active\";\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_IDLE, {});\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Format the result from the Pyodide evaluation\n     * Based on PyodideRemoteKernel implementation\n     */\n    formatResult(res) {\n        if (!(res instanceof this.pyodide.ffi.PyProxy)) {\n            return res;\n        }\n        try {\n            // Convert PyProxy to JS\n            const m = res.toJs();\n            const results = this.mapToObject(m);\n            return results;\n        }\n        catch (error) {\n            console.error(\"Error formatting result:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    }\n    /**\n     * Convert a Map to a JavaScript object recursively\n     * Based on PyodideRemoteKernel implementation\n     */\n    mapToObject(obj) {\n        const out = obj instanceof Array ? [] : {};\n        obj.forEach((value, key) => {\n            out[key] =\n                value instanceof Map || value instanceof Array\n                    ? this.mapToObject(value)\n                    : value;\n        });\n        return out;\n    }\n    /**\n     * Handle input reply from user\n     */\n    async inputReply(content) {\n        if (this._resolveInputReply) {\n            this._resolveInputReply(content);\n            this._resolveInputReply = null;\n        }\n    }\n    /**\n     * Send a input request to the front-end.\n     */\n    async sendInputRequest(prompt, password) {\n        const content = {\n            prompt,\n            password,\n        };\n        this._sendMessage({\n            type: 'input_request',\n            content,\n            parentHeader: this.formatResult(this._parent_header)['header']\n        });\n    }\n    /**\n     * Get password input (with hidden input)\n     */\n    async getpass(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, true);\n        const replyPromise = new Promise((resolve) => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result.value;\n    }\n    /**\n     * Get text input\n     */\n    async input(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, false);\n        const replyPromise = new Promise((resolve) => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result.value;\n    }\n    /**\n     * Send a comm message to the front-end.\n     */\n    async sendComm(type, content, metadata, ident, buffers) {\n        this._sendMessage({\n            type: type,\n            content: this.formatResult(content),\n            metadata: this.formatResult(metadata),\n            ident: this.formatResult(ident),\n            buffers: this.formatResult(buffers),\n            parentHeader: this.formatResult(this._parent_header)['header'],\n        });\n    }\n    /**\n     * Complete the code submitted by a user.\n     */\n    async complete(code, cursor_pos, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.complete(code, cursor_pos);\n        return this.formatResult(res);\n    }\n    /**\n     * Inspect the code submitted by a user.\n     */\n    async inspect(code, cursor_pos, detail_level, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.inspect(code, cursor_pos, detail_level);\n        return this.formatResult(res);\n    }\n    /**\n     * Check code for completeness.\n     */\n    async isComplete(code, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.is_complete(code);\n        return this.formatResult(res);\n    }\n    /**\n     * Get information about available comms.\n     */\n    async commInfo(target_name, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_info(target_name);\n        return {\n            comms: this.formatResult(res),\n            status: 'ok',\n        };\n    }\n    /**\n     * Open a COMM\n     */\n    async commOpen(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_open(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Send a message through a COMM\n     */\n    async commMsg(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_msg(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Close a COMM\n     */\n    async commClose(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_close(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Execute Python code with streaming output\n     * @param code The Python code to execute\n     * @param parent Parent message header\n     * @returns AsyncGenerator yielding intermediate outputs and finally the execution result\n     */\n    async *executeStream(code, parent = {}) {\n        try {\n            await this.initialize();\n            // Create event listeners for streaming\n            const eventQueue = [];\n            const handleAllEvents = (eventData) => {\n                eventQueue.push(eventData);\n            };\n            // Listen for all events BEFORE executing code\n            super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, handleAllEvents);\n            try {\n                // Use the fixed execute method which properly waits for all messages\n                const resultPromise = this.execute(code, parent);\n                // Stream events as they arrive\n                while (true) {\n                    // Check if we have queued events to yield\n                    if (eventQueue.length > 0) {\n                        yield eventQueue.shift();\n                    }\n                    // Check if execution is complete\n                    const isComplete = await Promise.race([\n                        resultPromise.then(() => true),\n                        new Promise(resolve => setTimeout(() => resolve(false), 10))\n                    ]);\n                    if (isComplete) {\n                        // Yield any remaining events\n                        while (eventQueue.length > 0) {\n                            yield eventQueue.shift();\n                        }\n                        // Return the final result\n                        return await resultPromise;\n                    }\n                }\n            }\n            catch (error) {\n                console.error(\"Error in executeStream:\", error);\n                throw error;\n            }\n            finally {\n                // Clean up listener in finally block to ensure it's always removed\n                super.off(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, handleAllEvents);\n            }\n        }\n        catch (error) {\n            console.error(\"Error in executeStream setup:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    // Interrupt functionality\n    async interrupt() {\n        if (!this.initialized || !this.pyodide) {\n            console.warn(\"[KERNEL] Cannot interrupt: kernel not initialized\");\n            return false;\n        }\n        // Main thread kernels have limited interrupt support\n        // According to Pyodide docs, interrupts work best in web workers\n        console.warn(\"[KERNEL] Main thread kernels have limited interrupt support\");\n        try {\n            // If we have an interrupt buffer set up, try to use it\n            if (this._interruptBuffer && this._interruptSupported) {\n                // Set interrupt signal (2 = SIGINT)\n                this._interruptBuffer[0] = 2;\n                // Give the interrupt a moment to be processed\n                await new Promise(resolve => setTimeout(resolve, 100));\n                // Check if the interrupt was processed (buffer should be reset to 0)\n                const wasProcessed = this._interruptBuffer[0] === 0;\n                return wasProcessed;\n            }\n            else {\n                // Fallback: try to force a Python interrupt using the interpreter\n                if (this._interpreter && typeof this._interpreter.interrupt === 'function') {\n                    this._interpreter.interrupt();\n                    return true;\n                }\n                // Send stderr stream first (for Jupyter notebook UI compatibility)\n                this._sendMessage({\n                    type: 'stream',\n                    bundle: {\n                        name: 'stderr',\n                        text: 'KeyboardInterrupt: Execution interrupted by user\\n'\n                    }\n                });\n                this._sendMessage({\n                    type: 'execute_error',\n                    bundle: {\n                        ename: 'KeyboardInterrupt',\n                        evalue: 'Execution interrupted by user',\n                        traceback: ['KeyboardInterrupt: Execution interrupted by user']\n                    }\n                });\n                return true;\n            }\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Error during interrupt:\", error);\n            return false;\n        }\n    }\n    setInterruptBuffer(buffer) {\n        this._interruptBuffer = buffer;\n        try {\n            if (this.pyodide && typeof this.pyodide.setInterruptBuffer === 'function') {\n                this.pyodide.setInterruptBuffer(buffer);\n                this._interruptSupported = true;\n            }\n            else {\n                console.warn(\"[KERNEL] pyodide.setInterruptBuffer not available, interrupt support limited\");\n                this._interruptSupported = false;\n            }\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Error setting interrupt buffer:\", error);\n            this._interruptSupported = false;\n        }\n    }\n    /**\n     * Set environment variables with performance optimization\n     * OPTIMIZED: Parallel variable setting and validation with proper escaping and edge case handling\n     */\n    async setEnvironmentVariables() {\n        if (Object.keys(this.environmentVariables).length === 0) {\n            return; // No variables to set\n        }\n        const startTime = Date.now();\n        console.log(`🌍 Setting ${Object.keys(this.environmentVariables).length} environment variables...`);\n        try {\n            // Set each environment variable individually to avoid escaping issues\n            for (const [key, value] of Object.entries(this.environmentVariables)) {\n                // Handle edge cases: null, undefined, etc.\n                let processedValue;\n                if (value === null) {\n                    processedValue = ''; // Convert null to empty string\n                }\n                else if (value === undefined) {\n                    processedValue = ''; // Convert undefined to empty string\n                }\n                else {\n                    processedValue = String(value); // Convert everything else to string\n                }\n                await this.pyodide.runPythonAsync(`\nimport os\nos.environ[${JSON.stringify(key)}] = ${JSON.stringify(processedValue)}\n`);\n            }\n            const duration = Date.now() - startTime;\n            console.log(`⚡ Environment variables set in ${duration}ms`);\n        }\n        catch (error) {\n            console.error(\"❌ Failed to set environment variables:\", error);\n            throw error;\n        }\n    }\n}\n// Only Python kernel is supported\n// Export the manager for advanced usage\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUM7UUFDOUQsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQy9ELE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7Q0FDRjtBQUVELGtDQUFrQztBQUVsQyx3Q0FBd0M7QUFDRSIsInNvdXJjZXMiOlsid2VicGFjazovL1dlYlB5dGhvbktlcm5lbC8uL3NyYy9pbmRleC50cz9mZmI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEtlcm5lbCBpbXBsZW1lbnRhdGlvbiBmb3IgRGVubyB1c2luZyBQeW9kaWRlIGRpcmVjdGx5XG4vLyBCYXNlZCBvbiB0aGUgUHlvZGlkZVJlbW90ZUtlcm5lbCBidXQgYWRhcHRlZCBmb3IgZGlyZWN0IGV4ZWN1dGlvbiBpbiBtYWluIHRocmVhZFxuXG4vLyBAdHMtaWdub3JlIEltcG9ydGluZyBmcm9tIG5wbVxuLy8gVXNlIGEgYnJvd3Nlci1jb21wYXRpYmxlIEV2ZW50RW1pdHRlclxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBldmVudHM6IHsgW2tleTogc3RyaW5nXTogRnVuY3Rpb25bXSB9ID0ge307XG5cbiAgb24oZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgb2ZmKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHJldHVybjtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICBlbWl0KGV2ZW50TmFtZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgcmV0dXJuO1xuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lciguLi5hcmdzKSk7XG4gIH1cblxuICBzZXRNYXhMaXN0ZW5lcnMobjogbnVtYmVyKSB7XG4gICAgLy8gTm8tb3AgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICB9XG59XG5cbi8vIEB0cy1pZ25vcmUgSW1wb3J0aW5nIGZyb20gbnBtXG5pbXBvcnQgeyBsb2FkUHlvZGlkZSB9IGZyb20gXCIuL3B5b2RpZGUtbG9hZGVyXCI7XG5cbi8vIEltcG9ydCB0eXBlcyBhbmQgZW51bXNcbmltcG9ydCB7IEtlcm5lbEV2ZW50cywgSUV2ZW50RGF0YSwgSU1lc3NhZ2UgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG4vLyBJbXBvcnQgUHlQSSBVUkxzXG5pbXBvcnQge1xuICBwaXBsaXRlV2hlZWxVcmwsXG4gIHB5b2RpZGVfa2VybmVsV2hlZWxVcmwsXG4gIGlweWtlcm5lbFdoZWVsVXJsLFxuICBhbGxKU09OVXJsLFxuICB3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybCxcbiAgd2lkZ2V0c25iZXh0ZW5zaW9uV2hlZWxVcmwxXG59IGZyb20gJy4vX3B5cGknO1xuXG4vLyBFdmVudCB0eXBlcyBmcm9tIEp1cHl0ZXJMYWJcbi8vIFJlLWV4cG9ydCB0eXBlcyB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnQgeyBLZXJuZWxFdmVudHMgfSBmcm9tIFwiLi90eXBlc1wiO1xuZXhwb3J0IHR5cGUgeyBcbiAgSUtlcm5lbCwgXG4gIElLZXJuZWxPcHRpb25zLCBcbiAgSUZpbGVzeXN0ZW1Nb3VudE9wdGlvbnMsIFxuICBJS2VybmVsRXhlY3V0ZU9wdGlvbnMsIFxuICBJTWVzc2FnZSwgXG4gIElFdmVudERhdGEsXG4gIElFdmVudEVtaXR0ZXJcbn0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLy8gSW50ZXJmYWNlIGZvciBrZXJuZWwgZXZlbnRzXG5leHBvcnQgaW50ZXJmYWNlIElGaWxlc3lzdGVtTW91bnRPcHRpb25zIHtcbiAgZW5hYmxlZD86IGJvb2xlYW47XG4gIHJvb3Q/OiBzdHJpbmc7XG4gIG1vdW50UG9pbnQ/OiBzdHJpbmc7XG59XG5cbi8vIEludGVyZmFjZSBmb3Iga2VybmVsIG9wdGlvbnNcbmV4cG9ydCBpbnRlcmZhY2UgSUtlcm5lbE9wdGlvbnMge1xuICBmaWxlc3lzdGVtPzogSUZpbGVzeXN0ZW1Nb3VudE9wdGlvbnM7XG4gIGVudj86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47IC8vIEVudmlyb25tZW50IHZhcmlhYmxlcyB0byBzZXQgaW4gdGhlIGtlcm5lbFxufVxuXG4vLyBJbnRlcmZhY2UgZm9yIGtlcm5lbFxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgaW5pdGlhbGl6ZShvcHRpb25zPzogSUtlcm5lbE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuICBleGVjdXRlKGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9PjtcbiAgZXhlY3V0ZVN0cmVhbT8oY29kZTogc3RyaW5nLCBwYXJlbnQ/OiBhbnkpOiBBc3luY0dlbmVyYXRvcjxhbnksIHsgc3VjY2VzczogYm9vbGVhbiwgcmVzdWx0PzogYW55LCBlcnJvcj86IEVycm9yIH0sIHZvaWQ+O1xuICBpc0luaXRpYWxpemVkKCk6IGJvb2xlYW47XG4gIGlucHV0UmVwbHkoY29udGVudDogeyB2YWx1ZTogc3RyaW5nIH0pOiBQcm9taXNlPHZvaWQ+O1xuICBnZXRTdGF0dXMoKTogUHJvbWlzZTxcImFjdGl2ZVwiIHwgXCJidXN5XCIgfCBcInVua25vd25cIj47XG4gIFxuICAvLyBJbnRlcnJ1cHQgZnVuY3Rpb25hbGl0eVxuICBpbnRlcnJ1cHQ/KCk6IFByb21pc2U8Ym9vbGVhbj47XG4gIHNldEludGVycnVwdEJ1ZmZlcj8oYnVmZmVyOiBVaW50OEFycmF5KTogdm9pZDtcbiAgXG4gIC8vIE9wdGlvbmFsIG1ldGhvZHNcbiAgY29tcGxldGU/KGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XG4gIGluc3BlY3Q/KGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBkZXRhaWxfbGV2ZWw6IDAgfCAxLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XG4gIGlzQ29tcGxldGU/KGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KTogUHJvbWlzZTxhbnk+O1xuICBjb21tSW5mbz8odGFyZ2V0X25hbWU6IHN0cmluZyB8IG51bGwsIHBhcmVudD86IGFueSk6IFByb21pc2U8YW55PjtcbiAgY29tbU9wZW4/KGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KTogUHJvbWlzZTx2b2lkPjtcbiAgY29tbU1zZz8oY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPHZvaWQ+O1xuICBjb21tQ2xvc2U/KGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KTogUHJvbWlzZTx2b2lkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsRXhlY3V0ZU9wdGlvbnMge1xuICBjb2RlOiBzdHJpbmc7XG4gIHNpbGVudD86IGJvb2xlYW47XG4gIHN0b3JlSGlzdG9yeT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1lc3NhZ2Uge1xuICB0eXBlOiBzdHJpbmc7XG4gIGJ1bmRsZT86IGFueTtcbiAgY29udGVudD86IGFueTtcbiAgbWV0YWRhdGE/OiBhbnk7XG4gIHBhcmVudEhlYWRlcj86IGFueTtcbiAgYnVmZmVycz86IGFueTtcbiAgaWRlbnQ/OiBhbnk7XG59XG5cbi8vIEV2ZW50IGRhdGEgc3RydWN0dXJlIHdpdGggc3RhbmRhcmRpemVkIGZvcm1hdFxuZXhwb3J0IGludGVyZmFjZSBJRXZlbnREYXRhIHtcbiAgdHlwZTogc3RyaW5nO1xuICBkYXRhOiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBLZXJuZWwgZXh0ZW5kcyBFdmVudEVtaXR0ZXIgaW1wbGVtZW50cyBJS2VybmVsIHtcbiAgcHJpdmF0ZSBweW9kaWRlOiBhbnk7XG4gIHByaXZhdGUgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBpbml0UHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gRmlsZXN5c3RlbSBvcHRpb25zXG4gIHByaXZhdGUgZmlsZXN5c3RlbU9wdGlvbnM6IElGaWxlc3lzdGVtTW91bnRPcHRpb25zID0ge1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIHJvb3Q6IFwiLlwiLFxuICAgIG1vdW50UG9pbnQ6IFwiL2hvbWUvcHlvZGlkZVwiXG4gIH07XG4gIFxuICAvLyBLZXJuZWwgY29tcG9uZW50c1xuICBwcml2YXRlIF9rZXJuZWw6IGFueTtcbiAgcHJpdmF0ZSBfaW50ZXJwcmV0ZXI6IGFueTtcbiAgcHJpdmF0ZSBfc3Rkb3V0X3N0cmVhbTogYW55O1xuICBwcml2YXRlIF9zdGRlcnJfc3RyZWFtOiBhbnk7XG4gIFxuICAvLyBJbnB1dCBoYW5kbGluZ1xuICBwcml2YXRlIF9yZXNvbHZlSW5wdXRSZXBseTogKCh2YWx1ZTogYW55KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gRXhlY3V0aW9uIHN0YXRlXG4gIHByaXZhdGUgX3BhcmVudF9oZWFkZXI6IGFueSA9IHt9O1xuICBwcml2YXRlIGV4ZWN1dGlvbkNvdW50ID0gMDtcbiAgcHJpdmF0ZSBfc3RhdHVzOiBcImFjdGl2ZVwiIHwgXCJidXN5XCIgfCBcInVua25vd25cIiA9IFwidW5rbm93blwiO1xuICBcbiAgLy8gSW50ZXJydXB0IGhhbmRsaW5nXG4gIHByaXZhdGUgX2ludGVycnVwdEJ1ZmZlcjogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9pbnRlcnJ1cHRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgXG4gIC8vIEVudmlyb25tZW50IHZhcmlhYmxlc1xuICBwcml2YXRlIGVudmlyb25tZW50VmFyaWFibGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIFxuICAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBrZXJuZWwgaW5zdGFuY2VcbiAgcHJpdmF0ZSByZWFkb25seSBrZXJuZWxJZDogc3RyaW5nO1xuICBcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBzdXBlci5zZXRNYXhMaXN0ZW5lcnMoMjApO1xuICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGlzIGtlcm5lbCBpbnN0YW5jZVxuICAgIHRoaXMua2VybmVsSWQgPSBga2VybmVsXyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpfV8ke0RhdGUubm93KCl9YDtcbiAgfVxuXG4gIC8vIEFzeW5jIG1ldGhvZCBmb3Iga2VybmVsIHN0YXR1c1xuICBhc3luYyBnZXRTdGF0dXMoKTogUHJvbWlzZTxcImFjdGl2ZVwiIHwgXCJidXN5XCIgfCBcInVua25vd25cIj4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUga2VybmVsIHdpdGggbWF4aW11bSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zXG4gICAqIE9QVElNSVpFRDogRnVsbCBwYXJhbGxlbGl6YXRpb24gd2l0aCBzbWFydCBjYWNoaW5nIGFuZCBwZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZShvcHRpb25zPzogSUtlcm5lbE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5pbml0UHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdFByb21pc2U7XG4gICAgfVxuXG4gICAgLy8gU2V0IGZpbGVzeXN0ZW0gb3B0aW9ucyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zPy5maWxlc3lzdGVtKSB7XG4gICAgICB0aGlzLmZpbGVzeXN0ZW1PcHRpb25zID0ge1xuICAgICAgICAuLi50aGlzLmZpbGVzeXN0ZW1PcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmZpbGVzeXN0ZW1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU2V0IGVudmlyb25tZW50IHZhcmlhYmxlcyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zPy5lbnYpIHtcbiAgICAgIHRoaXMuZW52aXJvbm1lbnRWYXJpYWJsZXMgPSB7IC4uLm9wdGlvbnMuZW52IH07XG4gICAgfVxuXG4gICAgdGhpcy5pbml0UHJvbWlzZSA9IHRoaXMuX2luaXRpYWxpemVJbnRlcm5hbCgpO1xuICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlO1xuICB9XG4gIFxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUga2VybmVsIHdpdGggbWF4aW11bSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zXG4gICAqIE9QVElNSVpFRDogRnVsbCBwYXJhbGxlbGl6YXRpb24gd2l0aCBzbWFydCBjYWNoaW5nIGFuZCBwZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9pbml0aWFsaXplSW50ZXJuYWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyhcIvCfmoAgU3RhcnRpbmcgb3B0aW1pemVkIGtlcm5lbCBpbml0aWFsaXphdGlvbi4uLlwiKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gTG9hZCBQeW9kaWRlIGZyb20gQ0ROXG4gICAgICBjb25zdCBweW9kaWRlU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIG91ciBDRE4gbG9hZGVyIC0gaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGhhbmRsZSBtYWluIHRocmVhZCB2cyB3b3JrZXJcbiAgICAgIHRoaXMucHlvZGlkZSA9IGF3YWl0IGxvYWRQeW9kaWRlKCk7XG4gICAgICBjb25zdCBweW9kaWRlVGltZSA9IERhdGUubm93KCkgLSBweW9kaWRlU3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYOKchSBQeW9kaWRlIGxvYWRlZCBpbiAke3B5b2RpZGVUaW1lfW1zYCk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgY29yZSBjb21wb25lbnRzIGluIHBhcmFsbGVsXG4gICAgICBjb25zdCBbLCAsXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgLy8gMS4gRmlsZXN5c3RlbSBtb3VudGluZyAoaWYgZW5hYmxlZClcbiAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5lbmFibGVkID8gdGhpcy5tb3VudEZpbGVzeXN0ZW0oKSA6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAvLyAyLiBQYWNrYWdlIG1hbmFnZXIgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgdGhpcy5pbml0UGFja2FnZU1hbmFnZXIoKSxcbiAgICAgICAgLy8gMy4gRW52aXJvbm1lbnQgdmFyaWFibGVzIHNldHVwXG4gICAgICAgIHRoaXMuc2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKVxuICAgICAgXSk7XG4gICAgICBcbiAgICAgIC8vIEluc3RhbGwgcGFja2FnZXMgYW5kIGluaXRpYWxpemUgZ2xvYmFsc1xuICAgICAgYXdhaXQgdGhpcy5pbml0S2VybmVsKCk7XG4gICAgICBhd2FpdCB0aGlzLmluaXRHbG9iYWxzKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OryBLRVJORUwgSU5JVElBTElaQVRJT04gQ09NUExFVEUgaW4gJHt0b3RhbFRpbWV9bXNgKTtcbiAgICAgIGNvbnNvbGUubG9nKGDimqEgUGVyZm9ybWFuY2U6IFB5b2RpZGUoJHtweW9kaWRlVGltZX1tcykgKyBTZXR1cCgke3RvdGFsVGltZSAtIHB5b2RpZGVUaW1lfW1zKWApO1xuICAgICAgXG4gICAgICAvLyBNYXJrIGFzIGluaXRpYWxpemVkXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfn6IgS2VybmVsIGlzIG5vdyBBQ1RJVkUgYW5kIHJlYWR5IGZvciBleGVjdXRpb24hXCIpO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgS2VybmVsIGluaXRpYWxpemF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gXCJ1bmtub3duXCI7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBNb3VudCB0aGUgbG9jYWwgZmlsZXN5c3RlbSB0byB0aGUgUHlvZGlkZSBlbnZpcm9ubWVudFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBtb3VudEZpbGVzeXN0ZW0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBNb3VudGluZyBmaWxlc3lzdGVtIGZyb20gJHt0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLnJvb3R9IHRvICR7dGhpcy5maWxlc3lzdGVtT3B0aW9ucy5tb3VudFBvaW50fWApO1xuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgYXBwcm9hY2ggYXMgaW4gZGVuby1kZW1vLWZzLWFzZ2kuanMgZm9yIG1heGltdW0gY29tcGF0aWJpbGl0eVxuICAgICAgLy8gU2ltcGxlIGFuZCBkaXJlY3QgbW91bnRpbmcgb2YgdGhlIGZpbGVzeXN0ZW1cbiAgICAgIGF3YWl0IHRoaXMucHlvZGlkZS5GUy5tb3VudChcbiAgICAgICAgdGhpcy5weW9kaWRlLkZTLmZpbGVzeXN0ZW1zLk5PREVGUyxcbiAgICAgICAgeyByb290OiB0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLnJvb3QgfHwgXCIuXCIgfSxcbiAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5tb3VudFBvaW50IHx8IFwiL2hvbWUvcHlvZGlkZVwiXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkZpbGVzeXN0ZW0gbW91bnRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgbW91bnQgYnkgbGlzdGluZyB0aGUgZGlyZWN0b3J5XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtb3VudGVkRmlsZXMgPSB0aGlzLnB5b2RpZGUuRlMucmVhZGRpcih0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLm1vdW50UG9pbnQgfHwgXCIvaG9tZS9weW9kaWRlXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRmlsZXMgaW4gJHt0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLm1vdW50UG9pbnR9IGRpcmVjdG9yeTogJHttb3VudGVkRmlsZXMuam9pbihcIiwgXCIpfWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgbGlzdGluZyBtb3VudGVkIGRpcmVjdG9yeTogJHtlcnJvcn1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG1vdW50aW5nIGZpbGVzeXN0ZW06XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBQeW9kaWRlIHBhY2thZ2UgbWFuYWdlciB3aXRoIG9wdGltaXplZCB3aGVlbCBsb2FkaW5nXG4gICAqIE9QVElNSVpFRDogU21hcnQgY2FjaGluZyBhbmQgcGFyYWxsZWwgd2hlZWwgaW5zdGFsbGF0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRQYWNrYWdlTWFuYWdlcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKFwi4pqhIEluaXRpYWxpemluZyBvcHRpbWl6ZWQgcGFja2FnZSBtYW5hZ2VyLi4uXCIpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBMb2FkIG1pY3JvcGlwIGFuZCBwYWNrYWdpbmcgaW4gcGFyYWxsZWxcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+TpiBMb2FkaW5nIG1pY3JvcGlwLCBwYWNrYWdpbmcuLi5cIik7XG4gICAgICBhd2FpdCB0aGlzLnB5b2RpZGUubG9hZFBhY2thZ2UoWydtaWNyb3BpcCcsICdwYWNrYWdpbmcnXSk7XG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBMb2FkZWQgbWljcm9waXAsIHBhY2thZ2luZ1wiKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBiYXNlIFVSTCAtIHVzZSB3aW5kb3cubG9jYXRpb24gZm9yIGJyb3dzZXIgb3IgZmFsbGJhY2sgZm9yIHdvcmtlclxuICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZztcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgICAgLy8gSW4gbWFpbiB0aHJlYWQgLSB1c2Ugd2luZG93LmxvY2F0aW9uXG4gICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKFwiLlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYubG9jYXRpb24pIHtcbiAgICAgICAgLy8gSW4gd2ViIHdvcmtlciAtIHVzZSBzZWxmLmxvY2F0aW9uXG4gICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKFwiLlwiLCBzZWxmLmxvY2F0aW9uLmhyZWYpLmhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayAtIGFzc3VtZSBjdXJyZW50IG9yaWdpblxuICAgICAgICBiYXNlVXJsID0gXCIvXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGFsbEpzb25QYXRoID0gbmV3IFVSTChhbGxKU09OVXJsLCBiYXNlVXJsKS5ocmVmO1xuICAgICAgXG4gICAgICAvLyBQcmVwYXJlIGFsbCB3aGVlbCBVUkxzIGZvciBwYXJhbGxlbCBsb2FkaW5nXG4gICAgICBjb25zdCB3aGVlbEZpbGVzID0gW1xuICAgICAgICBuZXcgVVJMKHBpcGxpdGVXaGVlbFVybCwgYmFzZVVybCkuaHJlZixcbiAgICAgICAgbmV3IFVSTChweW9kaWRlX2tlcm5lbFdoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKGlweWtlcm5lbFdoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsMSwgYmFzZVVybCkuaHJlZixcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5qAIEluc3RhbGxpbmcgJHt3aGVlbEZpbGVzLmxlbmd0aH0gd2hlZWwgcGFja2FnZXMgaW4gcGFyYWxsZWwuLi5gKTtcbiAgICAgIFxuICAgICAgLy8gSW5zdGFsbCBhbGwgd2hlZWwgcGFja2FnZXMgaW4gcGFyYWxsZWwgZm9yIG1heGltdW0gc3BlZWRcbiAgICAgIGNvbnN0IHdoZWVsUHJvbWlzZXMgPSB3aGVlbEZpbGVzLm1hcChhc3luYyAod2hlZWxVcmwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHdoZWVsU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxuaW1wb3J0IG1pY3JvcGlwXG5hd2FpdCBtaWNyb3BpcC5pbnN0YWxsKCcke3doZWVsVXJsfScsIGtlZXBfZ29pbmc9VHJ1ZSlcbnByaW50KGZcIuKchSBXaGVlbCAke2luZGV4ICsgMX0vJHt3aGVlbEZpbGVzLmxlbmd0aH0gaW5zdGFsbGVkXCIpXG5gKTtcbiAgICAgICAgICBjb25zdCB3aGVlbFRpbWUgPSBEYXRlLm5vdygpIC0gd2hlZWxTdGFydFRpbWU7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoSBXaGVlbCAke2luZGV4ICsgMX0gaW5zdGFsbGVkIGluICR7d2hlZWxUaW1lfW1zYCk7XG4gICAgICAgICAgcmV0dXJuIHsgaW5kZXgsIHN1Y2Nlc3M6IHRydWUsIHRpbWU6IHdoZWVsVGltZSB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnN0IHdoZWVsVGltZSA9IERhdGUubm93KCkgLSB3aGVlbFN0YXJ0VGltZTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBXaGVlbCAke2luZGV4ICsgMX0gZmFpbGVkIGFmdGVyICR7d2hlZWxUaW1lfW1zOmAsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm4geyBpbmRleCwgc3VjY2VzczogZmFsc2UsIHRpbWU6IHdoZWVsVGltZSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIGFsbCB3aGVlbCBpbnN0YWxsYXRpb25zXG4gICAgICBjb25zdCB3aGVlbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh3aGVlbFByb21pc2VzKTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSB3aGVlbFJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKTtcbiAgICAgIGNvbnN0IGZhaWxlZCA9IHdoZWVsUmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYPCfk4ogV2hlZWxzOiAke3N1Y2Nlc3NmdWwubGVuZ3RofS8ke3doZWVsRmlsZXMubGVuZ3RofSBzdWNjZXNzZnVsYCk7XG4gICAgICBpZiAoZmFpbGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gRmFpbGVkIHdoZWVsczogJHtmYWlsZWQubWFwKGYgPT4gZi5pbmRleCArIDEpLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldCB1cCBwaXBsaXRlIGNvbmZpZ3VyYXRpb24gd2l0aCBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zIChpZiBhdmFpbGFibGUpXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxudHJ5OlxuICAgIGltcG9ydCBwaXBsaXRlLnBpcGxpdGVcbiAgICBpbXBvcnQganNvblxuXG4gICAgIyBMb2FkIHBhY2thZ2UgaW5kZXggZm9yIGZhc3RlciBsb29rdXBzXG4gICAgdHJ5OlxuICAgICAgICBwaXBsaXRlLnBpcGxpdGUuUElQTElURV9VUkwgPSBcIiR7YWxsSnNvblBhdGh9XCJcbiAgICAgICAgIyBQcmUtbG9hZCBwYWNrYWdlIGluZGV4IGZvciBmYXN0ZXIgaW5zdGFsbGF0aW9uXG4gICAgICAgIHByaW50KFwi8J+TiyBQYWNrYWdlIGluZGV4IGNvbmZpZ3VyZWRcIilcbiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6XG4gICAgICAgIHByaW50KGZcIuKaoO+4jyBQYWNrYWdlIGluZGV4IHNldHVwIHdhcm5pbmc6IHtlfVwiKVxuXG4gICAgIyBDb25maWd1cmUgcGlwbGl0ZSBmb3Igb3B0aW1hbCBwZXJmb3JtYW5jZVxuICAgIHBpcGxpdGUucGlwbGl0ZS5SRVBPREFUQV9JTkZPID0ge31cbiAgICBwcmludChcIuKaoSBQaXBsaXRlIG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2VcIilcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcbiAgICBwcmludChcIuKaoO+4jyBQaXBsaXRlIG5vdCBhdmFpbGFibGUsIGNvbnRpbnVpbmcgd2l0aG91dCBpdFwiKVxuZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOlxuICAgIHByaW50KGZcIuKaoO+4jyBQaXBsaXRlIHNldHVwIGZhaWxlZDoge2V9XCIpXG5gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBQaXBsaXRlIGNvbmZpZ3VyYXRpb24gZmFpbGVkLCBjb250aW51aW5nIHdpdGhvdXQgaXQ6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdG90YWxUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIFBhY2thZ2UgbWFuYWdlciBpbml0aWFsaXplZCBpbiAke3RvdGFsVGltZX1tc2ApO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgUGFja2FnZSBtYW5hZ2VyIGluaXRpYWxpemF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIHJlcXVpcmVkIFB5dGhvbiBwYWNrYWdlc1xuICAgKiBPUFRJTUlaRUQ6IE1heGltdW0gcGFyYWxsZWxpemF0aW9uIHdpdGggaW50ZWxsaWdlbnQgZGVwZW5kZW5jeSByZXNvbHV0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRLZXJuZWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyhcIvCfmoAgSW5pdGlhbGl6aW5nIGtlcm5lbCBwYWNrYWdlcyB3aXRoIG1heGltdW0gb3B0aW1pemF0aW9uLi4uXCIpO1xuICAgIFxuICAgIC8vIEFsbCBwYWNrYWdlcyB0byBpbnN0YWxsIHdpdGggcHJpb3JpdHkgYW5kIGRlcGVuZGVuY3kgaW5mb3JtYXRpb25cbiAgICBjb25zdCBwYWNrYWdlQ29uZmlnID0gW1xuICAgICAgLy8gSGlnaCBwcmlvcml0eTogQ0ROIHBhY2thZ2VzIChmYXN0ZXN0KVxuICAgICAgeyBuYW1lOiAncHVyZS1ldmFsJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdzdGFjay1kYXRhJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdweWdtZW50cycsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnc3NsJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdzcWxpdGUzJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdwcm9tcHRfdG9vbGtpdCcsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnamVkaScsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnaXB5dGhvbicsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgXG4gICAgICAvLyBNZWRpdW0gcHJpb3JpdHk6IHBpcCBwYWNrYWdlc1xuICAgICAgeyBuYW1lOiAnY29tbScsIHByaW9yaXR5OiAyLCBzb3VyY2U6ICdwaXAnIH0sXG4gICAgICB7IG5hbWU6ICdoeXBoYS1ycGMnLCBwcmlvcml0eTogMiwgc291cmNlOiAncGlwJyB9LFxuICAgICAgeyBuYW1lOiAnbmJmb3JtYXQnLCBwcmlvcml0eTogMiwgc291cmNlOiAncGlwJyB9LFxuICAgICAgXG4gICAgICAvLyBMb3dlciBwcmlvcml0eTogY29tcGxleCBwYWNrYWdlc1xuICAgICAgeyBuYW1lOiAnaXB5a2VybmVsJywgcHJpb3JpdHk6IDMsIHNvdXJjZTogJ3BpcCcgfSxcbiAgICAgIHsgbmFtZTogJ3B5b2RpZGVfa2VybmVsJywgcHJpb3JpdHk6IDMsIHNvdXJjZTogJ3BpcCcgfVxuICAgIF07XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCfk6YgSW5zdGFsbGluZyAke3BhY2thZ2VDb25maWcubGVuZ3RofSBwYWNrYWdlcyB3aXRoIGludGVsbGlnZW50IG9wdGltaXphdGlvbi4uLmApO1xuICAgICAgXG4gICAgICAvLyBJbnN0YWxsIEFMTCBwYWNrYWdlcyBpbiBwYXJhbGxlbCB3aXRoIGFkdmFuY2VkIGVycm9yIGhhbmRsaW5nIGFuZCBjYWNoaW5nXG4gICAgICBhd2FpdCB0aGlzLmluc3RhbGxQYWNrYWdlc1dpdGhJbnRlbGxpZ2VudE9wdGltaXphdGlvbihwYWNrYWdlQ29uZmlnKTtcbiAgICAgIFxuICAgICAgLy8gSW1wb3J0IHRoZSBrZXJuZWwgKG11c3QgYmUgZG9uZSBhZnRlciBwYWNrYWdlcyBhcmUgaW5zdGFsbGVkKVxuICAgICAgY29uc29sZS5sb2coXCLwn5OlIEltcG9ydGluZyBweW9kaWRlX2tlcm5lbC4uLlwiKTtcbiAgICAgIGNvbnN0IGltcG9ydFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoJ2ltcG9ydCBweW9kaWRlX2tlcm5lbCcpO1xuICAgICAgY29uc3QgaW1wb3J0VGltZSA9IERhdGUubm93KCkgLSBpbXBvcnRTdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIHB5b2RpZGVfa2VybmVsIGltcG9ydGVkIGluICR7aW1wb3J0VGltZX1tc2ApO1xuICAgICAgXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYPCfjq8gS2VybmVsIHBhY2thZ2VzIGluaXRpYWxpemVkIGluICR7dG90YWxUaW1lfW1zYCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBLZXJuZWwgcGFja2FnZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEluc3RhbGwgcGFja2FnZXMgd2l0aCBpbnRlbGxpZ2VudCBvcHRpbWl6YXRpb24gYW5kIGFkdmFuY2VkIGNhY2hpbmdcbiAgICogT1BUSU1JWkVEOiBTbWFydCBzb3VyY2Ugc2VsZWN0aW9uLCBwYXJhbGxlbCBpbnN0YWxsYXRpb24sIGFuZCBwZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluc3RhbGxQYWNrYWdlc1dpdGhJbnRlbGxpZ2VudE9wdGltaXphdGlvbihwYWNrYWdlQ29uZmlnOiBBcnJheTx7bmFtZTogc3RyaW5nLCBwcmlvcml0eTogbnVtYmVyLCBzb3VyY2U6IHN0cmluZ30+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coYOKaoSBTdGFydGluZyBpbnRlbGxpZ2VudCBwYXJhbGxlbCBpbnN0YWxsYXRpb24gb2YgJHtwYWNrYWdlQ29uZmlnLmxlbmd0aH0gcGFja2FnZXMuLi5gKTtcbiAgICBcbiAgICBjb25zdCBpbnN0YWxsUHJvbWlzZXMgPSBwYWNrYWdlQ29uZmlnLm1hcChhc3luYyAocGtnKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgSW5zdGFsbGluZyAke3BrZy5uYW1lfSAocHJpb3JpdHk6ICR7cGtnLnByaW9yaXR5fSwgcHJlZmVycmVkOiAke3BrZy5zb3VyY2V9KS4uLmApO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHByZWZlcnJlZCBzb3VyY2UgZmlyc3QsIHdpdGggaW50ZWxsaWdlbnQgZmFsbGJhY2tcbiAgICAgICAgaWYgKHBrZy5zb3VyY2UgPT09ICdweW9kaWRlJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUubG9hZFBhY2thZ2UoW3BrZy5uYW1lXSk7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7cGtnLm5hbWV9IGxvYWRlZCBmcm9tIFB5b2RpZGUgQ0ROICgke2R1cmF0aW9ufW1zKWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ3B5b2RpZGUnLCBkdXJhdGlvbiwgc3VjY2VzczogdHJ1ZSwgcHJpb3JpdHk6IHBrZy5wcmlvcml0eSB9O1xuICAgICAgICAgIH0gY2F0Y2ggKHB5b2RpZGVFcnJvcikge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcGlwIHdpdGggZW5oYW5jZWQgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OmICR7cGtnLm5hbWV9IG5vdCBhdmFpbGFibGUgb24gQ0ROLCB0cnlpbmcgcGlwLi4uYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluc3RhbGxWaWFQaXBXaXRoT3B0aW1pemF0aW9ucyhwa2cubmFtZSk7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7cGtnLm5hbWV9IGluc3RhbGxlZCB2aWEgcGlwIGZhbGxiYWNrICgke2R1cmF0aW9ufW1zKWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ3BpcC1mYWxsYmFjaycsIGR1cmF0aW9uLCBzdWNjZXNzOiB0cnVlLCBwcmlvcml0eTogcGtnLnByaW9yaXR5IH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpcmVjdCBwaXAgaW5zdGFsbGF0aW9uIHdpdGggb3B0aW1pemF0aW9uc1xuICAgICAgICAgIGF3YWl0IHRoaXMuaW5zdGFsbFZpYVBpcFdpdGhPcHRpbWl6YXRpb25zKHBrZy5uYW1lKTtcbiAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSAke3BrZy5uYW1lfSBpbnN0YWxsZWQgdmlhIHBpcCAoJHtkdXJhdGlvbn1tcylgKTtcbiAgICAgICAgICByZXR1cm4geyBwYWNrYWdlOiBwa2cubmFtZSwgbWV0aG9kOiAncGlwJywgZHVyYXRpb24sIHN1Y2Nlc3M6IHRydWUsIHByaW9yaXR5OiBwa2cucHJpb3JpdHkgfTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICBjb25zb2xlLndhcm4oYOKdjCBGYWlsZWQgdG8gaW5zdGFsbCAke3BrZy5uYW1lfSBhZnRlciAke2R1cmF0aW9ufW1zOmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ2ZhaWxlZCcsIGR1cmF0aW9uLCBzdWNjZXNzOiBmYWxzZSwgcHJpb3JpdHk6IHBrZy5wcmlvcml0eSwgZXJyb3IgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBXYWl0IGZvciBhbGwgaW5zdGFsbGF0aW9ucyB3aXRoIGRldGFpbGVkIGFuYWx5c2lzXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGluc3RhbGxQcm9taXNlcyk7XG4gICAgXG4gICAgLy8gQ29tcHJlaGVuc2l2ZSBwZXJmb3JtYW5jZSBhbmFseXNpc1xuICAgIHRoaXMuYW5hbHl6ZUluc3RhbGxhdGlvblJlc3VsdHMocmVzdWx0cyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbnN0YWxsIHBhY2thZ2UgdmlhIHBpcCB3aXRoIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5zdGFsbFZpYVBpcFdpdGhPcHRpbWl6YXRpb25zKHBhY2thZ2VOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxudHJ5OlxuICAgICMgVXNlIG9wdGltaXplZCBwaXAgaW5zdGFsbGF0aW9uIHdpdGggY2FjaGluZ1xuICAgIGF3YWl0IHBpcGxpdGUuaW5zdGFsbCgnJHtwYWNrYWdlTmFtZX0nLCBrZWVwX2dvaW5nPVRydWUsIGRlcHM9VHJ1ZSlcbiAgICBwcmludChcIuKchSBTdWNjZXNzZnVsbHkgaW5zdGFsbGVkICR7cGFja2FnZU5hbWV9IHZpYSBvcHRpbWl6ZWQgcGlwXCIpXG5leGNlcHQgRXhjZXB0aW9uIGFzIGU6XG4gICAgcHJpbnQoXCLimqDvuI8gV2FybmluZzogRmFpbGVkIHRvIGluc3RhbGwgJHtwYWNrYWdlTmFtZX06XCIsIHN0cihlKSlcbiAgICAjIFRyeSBhbHRlcm5hdGl2ZSBpbnN0YWxsYXRpb24gbWV0aG9kXG4gICAgdHJ5OlxuICAgICAgICBpbXBvcnQgbWljcm9waXBcbiAgICAgICAgYXdhaXQgbWljcm9waXAuaW5zdGFsbCgnJHtwYWNrYWdlTmFtZX0nLCBrZWVwX2dvaW5nPVRydWUpXG4gICAgICAgIHByaW50KFwi4pyFIFN1Y2Nlc3NmdWxseSBpbnN0YWxsZWQgJHtwYWNrYWdlTmFtZX0gdmlhIG1pY3JvcGlwIGZhbGxiYWNrXCIpXG4gICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlMjpcbiAgICAgICAgcHJpbnQoXCLinYwgQm90aCBwaXAgbWV0aG9kcyBmYWlsZWQgZm9yICR7cGFja2FnZU5hbWV9OlwiLCBzdHIoZTIpKVxuICAgICAgICByYWlzZSBlMlxuYCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBBbmFseXplIGluc3RhbGxhdGlvbiByZXN1bHRzIGFuZCBwcm92aWRlIHBlcmZvcm1hbmNlIGluc2lnaHRzXG4gICAqL1xuICBwcml2YXRlIGFuYWx5emVJbnN0YWxsYXRpb25SZXN1bHRzKHJlc3VsdHM6IEFycmF5PGFueT4pOiB2b2lkIHtcbiAgICBjb25zdCBzdWNjZXNzZnVsID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN1Y2Nlc3MpO1xuICAgIGNvbnN0IGZhaWxlZCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gIXIuc3VjY2Vzcyk7XG4gICAgY29uc3QgcHlvZGlkZUluc3RhbGxzID0gc3VjY2Vzc2Z1bC5maWx0ZXIociA9PiByLm1ldGhvZCA9PT0gJ3B5b2RpZGUnKTtcbiAgICBjb25zdCBwaXBJbnN0YWxscyA9IHN1Y2Nlc3NmdWwuZmlsdGVyKHIgPT4gci5tZXRob2QgPT09ICdwaXAnKTtcbiAgICBjb25zdCBmYWxsYmFja0luc3RhbGxzID0gc3VjY2Vzc2Z1bC5maWx0ZXIociA9PiByLm1ldGhvZCA9PT0gJ3BpcC1mYWxsYmFjaycpO1xuICAgIFxuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBNYXRoLm1heCguLi5yZXN1bHRzLm1hcChyID0+IHIuZHVyYXRpb24pKTtcbiAgICBjb25zdCBhdmdEdXJhdGlvbiA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApIC8gcmVzdWx0cy5sZW5ndGg7XG4gICAgY29uc3QgZXN0aW1hdGVkU2VxdWVudGlhbCA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn46vIElOVEVMTElHRU5UIElOU1RBTExBVElPTiBDT01QTEVURSFgKTtcbiAgICBjb25zb2xlLmxvZyhg8J+TiiBSZXN1bHRzOiAke3N1Y2Nlc3NmdWwubGVuZ3RofS8ke3Jlc3VsdHMubGVuZ3RofSBzdWNjZXNzZnVsYCk7XG4gICAgY29uc29sZS5sb2coYOKaoSBQeW9kaWRlIENETjogJHtweW9kaWRlSW5zdGFsbHMubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDwn5OmIERpcmVjdCBwaXA6ICR7cGlwSW5zdGFsbHMubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDwn5SEIFBpcCBmYWxsYmFjazogJHtmYWxsYmFja0luc3RhbGxzLmxlbmd0aH0gcGFja2FnZXNgKTtcbiAgICBjb25zb2xlLmxvZyhg4p2MIEZhaWxlZDogJHtmYWlsZWQubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDij7HvuI8gIFRvdGFsIHRpbWU6ICR7dG90YWxEdXJhdGlvbn1tcyAodnMgfiR7ZXN0aW1hdGVkU2VxdWVudGlhbH1tcyBzZXF1ZW50aWFsKWApO1xuICAgIGNvbnNvbGUubG9nKGDwn5qAIFNwZWVkIGltcHJvdmVtZW50OiB+JHtNYXRoLnJvdW5kKGVzdGltYXRlZFNlcXVlbnRpYWwgLyB0b3RhbER1cmF0aW9uKX14IGZhc3RlcmApO1xuICAgIGNvbnNvbGUubG9nKGDwn5OIIEF2ZXJhZ2UgcGVyIHBhY2thZ2U6ICR7TWF0aC5yb3VuZChhdmdEdXJhdGlvbil9bXNgKTtcbiAgICBcbiAgICBpZiAoZmFpbGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPICBGYWlsZWQgcGFja2FnZXM6ICR7ZmFpbGVkLm1hcChmID0+IGYucGFja2FnZSkuam9pbignLCAnKX1gKTtcbiAgICAgIC8vIExvZyBzcGVjaWZpYyBmYWlsdXJlIHJlYXNvbnMgZm9yIGRlYnVnZ2luZ1xuICAgICAgZmFpbGVkLmZvckVhY2goZiA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgICAgLSAke2YucGFja2FnZX06ICR7Zi5lcnJvcj8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gUGVyZm9ybWFuY2UgaW5zaWdodHNcbiAgICBjb25zdCBmYXN0ZXN0SW5zdGFsbCA9IE1hdGgubWluKC4uLnN1Y2Nlc3NmdWwubWFwKHIgPT4gci5kdXJhdGlvbikpO1xuICAgIGNvbnN0IHNsb3dlc3RJbnN0YWxsID0gTWF0aC5tYXgoLi4uc3VjY2Vzc2Z1bC5tYXAociA9PiByLmR1cmF0aW9uKSk7XG4gICAgY29uc29sZS5sb2coYPCfk4ogUGVyZm9ybWFuY2UgcmFuZ2U6ICR7ZmFzdGVzdEluc3RhbGx9bXMgKGZhc3Rlc3QpIHRvICR7c2xvd2VzdEluc3RhbGx9bXMgKHNsb3dlc3QpYCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGdsb2JhbCBvYmplY3RzIGZyb20gdGhlIHB5b2RpZGVfa2VybmVsIHBhY2thZ2VcbiAgICogQmFzZWQgb24gdGhlIFB5b2RpZGVSZW1vdGVLZXJuZWwgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5pdEdsb2JhbHMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coXCJJbml0aWFsaXppbmcgZ2xvYmFscy4uLlwiKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGdsb2JhbHMgZnJvbSB0aGUgUHl0aG9uIGVudmlyb25tZW50XG4gICAgY29uc3QgeyBnbG9iYWxzIH0gPSB0aGlzLnB5b2RpZGU7XG4gICAgXG4gICAgLy8gR2V0IHRoZSBrZXJuZWwgaW5zdGFuY2UgYW5kIHJlbGF0ZWQgb2JqZWN0c1xuICAgIHRoaXMuX2tlcm5lbCA9IGdsb2JhbHMuZ2V0KCdweW9kaWRlX2tlcm5lbCcpLmtlcm5lbF9pbnN0YW5jZS5jb3B5KCk7XG4gICAgdGhpcy5fc3Rkb3V0X3N0cmVhbSA9IGdsb2JhbHMuZ2V0KCdweW9kaWRlX2tlcm5lbCcpLnN0ZG91dF9zdHJlYW0uY29weSgpO1xuICAgIHRoaXMuX3N0ZGVycl9zdHJlYW0gPSBnbG9iYWxzLmdldCgncHlvZGlkZV9rZXJuZWwnKS5zdGRlcnJfc3RyZWFtLmNvcHkoKTtcbiAgICB0aGlzLl9pbnRlcnByZXRlciA9IHRoaXMuX2tlcm5lbC5pbnRlcnByZXRlci5jb3B5KCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGNvbW11bmljYXRpb24gaGFuZGxlcnNcbiAgICB0aGlzLl9pbnRlcnByZXRlci5zZW5kX2NvbW0gPSB0aGlzLnNlbmRDb21tLmJpbmQodGhpcyk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGNhbGxiYWNrc1xuICAgIHRoaXMuc2V0dXBDYWxsYmFja3MoKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldHVwIGFsbCBuZWNlc3NhcnkgY2FsbGJhY2tzIGZvciB0aGUgUHl0aG9uIGVudmlyb25tZW50XG4gICAqL1xuICBwcml2YXRlIHNldHVwQ2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIC8vIEV4ZWN1dGlvbiByZXN1bHQgY2FsbGJhY2tcbiAgICBjb25zdCBwdWJsaXNoRXhlY3V0aW9uUmVzdWx0ID0gKFxuICAgICAgcHJvbXB0X2NvdW50OiBhbnksXG4gICAgICBkYXRhOiBhbnksXG4gICAgICBtZXRhZGF0YTogYW55LFxuICAgICk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBleGVjdXRpb25fY291bnQ6IHByb21wdF9jb3VudCxcbiAgICAgICAgZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQoZGF0YSksXG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChtZXRhZGF0YSksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgIHR5cGU6ICdleGVjdXRlX3Jlc3VsdCcsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRXJyb3IgY2FsbGJhY2tcbiAgICBjb25zdCBwdWJsaXNoRXhlY3V0aW9uRXJyb3IgPSAoZW5hbWU6IGFueSwgZXZhbHVlOiBhbnksIHRyYWNlYmFjazogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIGVuYW1lOiBlbmFtZSxcbiAgICAgICAgZXZhbHVlOiBldmFsdWUsXG4gICAgICAgIHRyYWNlYmFjazogdHJhY2ViYWNrLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICAgIHR5cGU6ICdleGVjdXRlX2Vycm9yJyxcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBDbGVhciBvdXRwdXQgY2FsbGJhY2tcbiAgICBjb25zdCBjbGVhck91dHB1dENhbGxiYWNrID0gKHdhaXQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICAgICAgd2FpdDogdGhpcy5mb3JtYXRSZXN1bHQod2FpdCksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgICAgdHlwZTogJ2NsZWFyX291dHB1dCcsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRGlzcGxheSBkYXRhIGNhbGxiYWNrXG4gICAgY29uc3QgZGlzcGxheURhdGFDYWxsYmFjayA9IChkYXRhOiBhbnksIG1ldGFkYXRhOiBhbnksIHRyYW5zaWVudDogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIGRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KGRhdGEpLFxuICAgICAgICBtZXRhZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQobWV0YWRhdGEpLFxuICAgICAgICB0cmFuc2llbnQ6IHRoaXMuZm9ybWF0UmVzdWx0KHRyYW5zaWVudCksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgIHR5cGU6ICdkaXNwbGF5X2RhdGEnLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBkaXNwbGF5IGRhdGEgY2FsbGJhY2tcbiAgICBjb25zdCB1cGRhdGVEaXNwbGF5RGF0YUNhbGxiYWNrID0gKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgbWV0YWRhdGE6IGFueSxcbiAgICAgIHRyYW5zaWVudDogYW55LFxuICAgICk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChkYXRhKSxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KG1ldGFkYXRhKSxcbiAgICAgICAgdHJhbnNpZW50OiB0aGlzLmZvcm1hdFJlc3VsdCh0cmFuc2llbnQpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICB0eXBlOiAndXBkYXRlX2Rpc3BsYXlfZGF0YScsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gU3RyZWFtIGNhbGxiYWNrXG4gICAgY29uc3QgcHVibGlzaFN0cmVhbUNhbGxiYWNrID0gKG5hbWU6IGFueSwgdGV4dDogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuZm9ybWF0UmVzdWx0KG5hbWUpLFxuICAgICAgICB0ZXh0OiB0aGlzLmZvcm1hdFJlc3VsdCh0ZXh0KSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgcGFyZW50SGVhZGVyOiB0aGlzLmZvcm1hdFJlc3VsdCh0aGlzLl9wYXJlbnRfaGVhZGVyKVsnaGVhZGVyJ10sXG4gICAgICAgIGJ1bmRsZSxcbiAgICAgICAgdHlwZTogJ3N0cmVhbScsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXNzaWduIGNhbGxiYWNrcyB0byB0aGUgUHl0aG9uIG9iamVjdHNcbiAgICB0aGlzLl9zdGRvdXRfc3RyZWFtLnB1Ymxpc2hfc3RyZWFtX2NhbGxiYWNrID0gcHVibGlzaFN0cmVhbUNhbGxiYWNrO1xuICAgIHRoaXMuX3N0ZGVycl9zdHJlYW0ucHVibGlzaF9zdHJlYW1fY2FsbGJhY2sgPSBwdWJsaXNoU3RyZWFtQ2FsbGJhY2s7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuZGlzcGxheV9wdWIuY2xlYXJfb3V0cHV0X2NhbGxiYWNrID0gY2xlYXJPdXRwdXRDYWxsYmFjaztcbiAgICB0aGlzLl9pbnRlcnByZXRlci5kaXNwbGF5X3B1Yi5kaXNwbGF5X2RhdGFfY2FsbGJhY2sgPSBkaXNwbGF5RGF0YUNhbGxiYWNrO1xuICAgIHRoaXMuX2ludGVycHJldGVyLmRpc3BsYXlfcHViLnVwZGF0ZV9kaXNwbGF5X2RhdGFfY2FsbGJhY2sgPSB1cGRhdGVEaXNwbGF5RGF0YUNhbGxiYWNrO1xuICAgIHRoaXMuX2ludGVycHJldGVyLmRpc3BsYXlob29rLnB1Ymxpc2hfZXhlY3V0aW9uX3Jlc3VsdCA9IHB1Ymxpc2hFeGVjdXRpb25SZXN1bHQ7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuaW5wdXQgPSB0aGlzLmlucHV0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuZ2V0cGFzcyA9IHRoaXMuZ2V0cGFzcy5iaW5kKHRoaXMpO1xuICB9XG4gIFxuICAvKipcbiAgICogUHJvY2VzcyBhIG1lc3NhZ2UgZnJvbSBQeXRob24gZW52aXJvbm1lbnRcbiAgICovXG4gIHByaXZhdGUgX3NlbmRNZXNzYWdlKG1zZzogSU1lc3NhZ2UpOiB2b2lkIHtcbiAgICB0aGlzLl9wcm9jZXNzTWVzc2FnZShtc2cpO1xuICB9XG4gIFxuICAvKipcbiAgICogUHJvY2VzcyBhIG1lc3NhZ2UgYnkgZW1pdHRpbmcgdGhlIGFwcHJvcHJpYXRlIGV2ZW50XG4gICAqL1xuICBwcml2YXRlIF9wcm9jZXNzTWVzc2FnZShtc2c6IElNZXNzYWdlKTogdm9pZCB7XG4gICAgaWYgKCFtc2cudHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBldmVudERhdGE6IGFueTtcblxuICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmVhbSc6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IG5hbWU6ICdzdGRvdXQnLCB0ZXh0OiAnJyB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5TVFJFQU0sIGJ1bmRsZSk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGJ1bmRsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdpbnB1dF9yZXF1ZXN0Jzoge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gbXNnLmNvbnRlbnQgPz8geyBwcm9tcHQ6ICcnLCBwYXNzd29yZDogZmFsc2UgfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuSU5QVVRfUkVRVUVTVCwgY29udGVudCk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGNvbnRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZGlzcGxheV9kYXRhJzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgZGF0YToge30sIG1ldGFkYXRhOiB7fSwgdHJhbnNpZW50OiB7fSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5ESVNQTEFZX0RBVEEsIGJ1bmRsZSk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGJ1bmRsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICd1cGRhdGVfZGlzcGxheV9kYXRhJzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgZGF0YToge30sIG1ldGFkYXRhOiB7fSwgdHJhbnNpZW50OiB7fSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5VUERBVEVfRElTUExBWV9EQVRBLCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnY2xlYXJfb3V0cHV0Jzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgd2FpdDogZmFsc2UgfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuQ0xFQVJfT1VUUFVULCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZXhlY3V0ZV9yZXN1bHQnOiB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IG1zZy5idW5kbGUgPz8ge1xuICAgICAgICAgIGV4ZWN1dGlvbl9jb3VudDogdGhpcy5leGVjdXRpb25Db3VudCxcbiAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfUkVTVUxULCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZXhlY3V0ZV9lcnJvcic6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IGVuYW1lOiAnJywgZXZhbHVlOiAnJywgdHJhY2ViYWNrOiBbXSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnY29tbV9vcGVuJzpcbiAgICAgIGNhc2UgJ2NvbW1fbXNnJzpcbiAgICAgIGNhc2UgJ2NvbW1fY2xvc2UnOiB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBtc2cuY29udGVudCA/PyB7fTtcbiAgICAgICAgc3VwZXIuZW1pdChtc2cudHlwZSwgY29udGVudCwgbXNnLm1ldGFkYXRhLCBtc2cuYnVmZmVycyk7XG4gICAgICAgIGV2ZW50RGF0YSA9IHtcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIG1ldGFkYXRhOiBtc2cubWV0YWRhdGEsXG4gICAgICAgICAgYnVmZmVyczogbXNnLmJ1ZmZlcnNcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW1pdCB0aGUgQUxMIGV2ZW50IHdpdGggc3RhbmRhcmRpemVkIGZvcm1hdFxuICAgIGlmIChldmVudERhdGEpIHtcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkFMTCwge1xuICAgICAgICB0eXBlOiBtc2cudHlwZSxcbiAgICAgICAgZGF0YTogZXZlbnREYXRhXG4gICAgICB9IGFzIElFdmVudERhdGEpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBrZXJuZWwgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbiAgICovXG4gIHB1YmxpYyBpc0luaXRpYWxpemVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVkO1xuICB9XG4gIFxuICAvKipcbiAgICogTWFrZXMgc3VyZSBweW9kaWRlIGlzIHJlYWR5IGJlZm9yZSBjb250aW51aW5nLCBhbmQgY2FjaGUgdGhlIHBhcmVudCBtZXNzYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXR1cChwYXJlbnQ6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMuX3BhcmVudF9oZWFkZXIgPSB0aGlzLnB5b2RpZGUudG9QeShwYXJlbnQgfHwge30pO1xuICB9XG4gIFxuICAvKipcbiAgICogRXhlY3V0ZSBjb2RlIGluIHRoZSBrZXJuZWwgd2l0aCBwcm9wZXIgbWVzc2FnZS1iYXNlZCBjb21wbGV0aW9uIGRldGVjdGlvblxuICAgKiBcbiAgICogQHBhcmFtIGNvZGUgVGhlIGNvZGUgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gcGFyZW50IFBhcmVudCBtZXNzYWdlIGhlYWRlclxuICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBleGVjdXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBleGVjdXRlKGNvZGU6IHN0cmluZywgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfT4ge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYnVzeVwiO1xuICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuS0VSTkVMX0JVU1ksIHt9KTtcbiAgICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICAgIFxuICAgICAgLy8gUmVzZXQgbmFtZXNwYWNlIGZvciB0aGlzIGtlcm5lbCB0byBlbnN1cmUgaXNvbGF0aW9uIGJldHdlZW4ga2VybmVsc1xuICAgICAgY29uc3QgbmFtZXNwYWNlUmVzZXQgPSBgXG4jIEtlcm5lbCBpc29sYXRpb24gLSByZXNldCBjb21tb25seSBjb25mbGljdGluZyB2YXJpYWJsZXMgdG8gcHJldmVudCBjcm9zcy1rZXJuZWwgc3RhdGUgc2hhcmluZ1xuZm9yIF92YXIgaW4gWyd4JywgJ3ZhbHVlJywgJ3Jlc3VsdCcsICdhJywgJ2InLCAnYycsICdkYXRhJywgJ3RlbXAnXTpcbiAgICBpZiBfdmFyIGluIGdsb2JhbHMoKTpcbiAgICAgICAgZGVsIGdsb2JhbHMoKVtfdmFyXVxuZGVsIF92YXJcbmA7XG4gICAgICB0aGlzLnB5b2RpZGUucnVuUHl0aG9uKG5hbWVzcGFjZVJlc2V0KTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9ubHkgd2hlbiBleGVjdXRpb24gaXMgdHJ1bHkgY29tcGxldGVcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvblN0YXRlID0ge1xuICAgICAgICAgIGFsbE1lc3NhZ2VzOiBbXSBhcyBJRXZlbnREYXRhW10sXG4gICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgIGV4ZWN1dGlvblJlc3VsdDogbnVsbCBhcyBhbnksXG4gICAgICAgICAgZXhlY3V0aW9uRXJyb3I6IG51bGwgYXMgRXJyb3IgfCBudWxsLFxuICAgICAgICAgIHRpbWVvdXQ6IG51bGwgYXMgbnVtYmVyIHwgbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCB1cCBtZXNzYWdlIGNvbGxlY3RvciB0aGF0IGNhcHR1cmVzIEFMTCBvdXRwdXQgYmVmb3JlIGNvbXBsZXRpb25cbiAgICAgICAgY29uc3QgbWVzc2FnZUNvbGxlY3RvciA9IChldmVudERhdGE6IElFdmVudERhdGEpID0+IHtcbiAgICAgICAgICBleGVjdXRpb25TdGF0ZS5hbGxNZXNzYWdlcy5wdXNoKGV2ZW50RGF0YSk7XG4gICAgICAgICAgLy8gRGVidWcgbG9nZ2luZyB0byB0cmFjZSBtZXNzYWdlIGZsb3dcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQ2FwdHVyZWQgbWVzc2FnZTogJHtldmVudERhdGEudHlwZX1gLCBldmVudERhdGEuZGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2V0IHVwIGNvbXBsZXRpb24gZGV0ZWN0b3JcbiAgICAgICAgY29uc3QgY29tcGxldGlvbkRldGVjdG9yID0gYXN5bmMgKGV4ZWN1dGVkQ29kZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaWYgKGV4ZWN1dGlvblN0YXRlLmV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgY29tcGxldGVkXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBFeGVjdXRpb24gY29tcGxldGVkLCBwcm9jZXNzaW5nICR7ZXhlY3V0aW9uU3RhdGUuYWxsTWVzc2FnZXMubGVuZ3RofSBtZXNzYWdlc2ApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1hcmsgYXMgY29tcGxldGUgdG8gcHJldmVudCBtdWx0aXBsZSByZXNvbHV0aW9uc1xuICAgICAgICAgIGV4ZWN1dGlvblN0YXRlLmV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhbiB1cCBsaXN0ZW5lcnNcbiAgICAgICAgICBzdXBlci5vZmYoS2VybmVsRXZlbnRzLkFMTCwgbWVzc2FnZUNvbGxlY3Rvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJvY2VzcyBjb2xsZWN0ZWQgbWVzc2FnZXMgdG8gZGV0ZXJtaW5lIGZpbmFsIHJlc3VsdCBhbmQgZXh0cmFjdCBjb21wdXRlZCB2YWx1ZVxuICAgICAgICAgIGxldCBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGxldCBlcnJvckluZm86IGFueSA9IG51bGw7XG4gICAgICAgICAgbGV0IGNvbXB1dGVkUmVzdWx0OiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIGRpcmVjdCByZXN1bHQgZnJvbSBfa2VybmVsLnJ1bigpIGluZGljYXRlcyBhbiBlcnJvclxuICAgICAgICAgIGNvbnN0IGRpcmVjdFJlc3VsdCA9IGV4ZWN1dGlvblN0YXRlLmV4ZWN1dGlvblJlc3VsdDtcbiAgICAgICAgICBpZiAoZGlyZWN0UmVzdWx0ICYmIGRpcmVjdFJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9ySW5mbyA9IHtcbiAgICAgICAgICAgICAgZW5hbWU6IGRpcmVjdFJlc3VsdC5lbmFtZSxcbiAgICAgICAgICAgICAgZXZhbHVlOiBkaXJlY3RSZXN1bHQuZXZhbHVlLFxuICAgICAgICAgICAgICB0cmFjZWJhY2s6IGRpcmVjdFJlc3VsdC50cmFjZWJhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRoZW4gY2hlY2sgbWVzc2FnZXMgZm9yIGV4ZWN1dGVfZXJyb3Igb3IgZXhlY3V0ZV9yZXN1bHRcbiAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgZXhlY3V0aW9uU3RhdGUuYWxsTWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdleGVjdXRlX2Vycm9yJykge1xuICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgIGVycm9ySW5mbyA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ2V4ZWN1dGVfcmVzdWx0Jykge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBleGVjdXRlX3Jlc3VsdCBmb3IgY29tcGF0aWJpbGl0eSBidXQgZG9uJ3QgZXh0cmFjdCBjb21wdXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgY29tcHV0ZWRSZXN1bHQgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuS0VSTkVMX0lETEUsIHt9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBFeGVjdXRpb24gZmFpbGVkIHdpdGggZXJyb3I6YCwgZXJyb3JJbmZvKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRW1pdCBleGVjdXRlX2Vycm9yIGV2ZW50IGZvciBlcnJvciBzdHJlYW1zXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBlcnJvciBuYW1lIGZvcm1hdCAocmVtb3ZlIDxjbGFzcyAnLi4uJz4gd3JhcHBlcilcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuRXJyb3JOYW1lID0gZXJyb3JJbmZvLmVuYW1lID8gZXJyb3JJbmZvLmVuYW1lLnJlcGxhY2UoL148Y2xhc3MgJyguKyknPiQvLCAnJDEnKSA6IGVycm9ySW5mby5lbmFtZTtcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIHtcbiAgICAgICAgICAgICAgZW5hbWU6IGNsZWFuRXJyb3JOYW1lLFxuICAgICAgICAgICAgICBldmFsdWU6IGVycm9ySW5mby5ldmFsdWUsXG4gICAgICAgICAgICAgIHRyYWNlYmFjazogZXJyb3JJbmZvLnRyYWNlYmFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID0gYCR7ZXJyb3JJbmZvLmVuYW1lIHx8ICdFcnJvcid9OiAke2Vycm9ySW5mby5ldmFsdWUgfHwgJ1Vua25vd24gZXJyb3InfWA7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoZXJyb3JNc2cpLFxuICAgICAgICAgICAgICByZXN1bHQ6IGV4ZWN1dGlvblN0YXRlLmV4ZWN1dGlvblJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBFeGVjdXRpb24gc3VjY2Vzc2Z1bCwgY2FwdHVyZWQgJHtleGVjdXRpb25TdGF0ZS5hbGxNZXNzYWdlcy5sZW5ndGh9IG91dHB1dCBtZXNzYWdlc2ApO1xuICAgICAgICAgICAgbGV0IGZpbmFsUmVzdWx0ID0gY29tcHV0ZWRSZXN1bHQgIT09IHVuZGVmaW5lZCA/IGNvbXB1dGVkUmVzdWx0IDogZXhlY3V0aW9uU3RhdGUuZXhlY3V0aW9uUmVzdWx0O1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgIHJlc3VsdDogZmluYWxSZXN1bHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnN0YWxsIG1lc3NhZ2UgY29sbGVjdG9yIEJFRk9SRSBleGVjdXRpbmcgY29kZVxuICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuQUxMLCBtZXNzYWdlQ29sbGVjdG9yKTtcblxuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjb2RlIGFuZCBoYW5kbGUgY29tcGxldGlvblxuICAgICAgICB0aGlzLl9rZXJuZWwucnVuKGNvZGUpLnRoZW4oKHJlc3VsdDogYW55KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJbS0VSTkVMXSBQeXRob24gZXhlY3V0aW9uIGZpbmlzaGVkLCB3YWl0aW5nIGZvciBtZXNzYWdlcyB0byBzZXR0bGVcIik7XG4gICAgICAgICAgZXhlY3V0aW9uU3RhdGUuZXhlY3V0aW9uUmVzdWx0ID0gdGhpcy5mb3JtYXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGEgc21hbGwgYW1vdW50IG9mIHRpbWUgZm9yIGFueSByZW1haW5pbmcgbWVzc2FnZXMgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIGFsbCBzdGRvdXQvc3RkZXJyIHN0cmVhbXMgaGF2ZSBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb21wbGV0aW9uRGV0ZWN0b3IoY29kZSk7XG4gICAgICAgICAgfSwgMTAwKTsgLy8gMTAwbXMgc2hvdWxkIGJlIGVub3VnaCBmb3IgbWVzc2FnZSBwcm9jZXNzaW5nXG4gICAgICAgICAgXG4gICAgICAgIH0pLmNhdGNoKChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIFB5dGhvbiBleGVjdXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICBleGVjdXRpb25TdGF0ZS5leGVjdXRpb25FcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdGlsbCB3YWl0IGZvciBtZXNzYWdlcyB0byBzZXR0bGUgYmVmb3JlIGNvbXBsZXRpbmdcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbXBsZXRpb25EZXRlY3Rvcihjb2RlKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbS0VSTkVMXSBFeGVjdXRlIHNldHVwIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICB0aGlzLl9zdGF0dXMgPSBcImFjdGl2ZVwiO1xuICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuS0VSTkVMX0lETEUsIHt9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRm9ybWF0IHRoZSByZXN1bHQgZnJvbSB0aGUgUHlvZGlkZSBldmFsdWF0aW9uXG4gICAqIEJhc2VkIG9uIFB5b2RpZGVSZW1vdGVLZXJuZWwgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHByaXZhdGUgZm9ybWF0UmVzdWx0KHJlczogYW55KTogYW55IHtcbiAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiB0aGlzLnB5b2RpZGUuZmZpLlB5UHJveHkpKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ29udmVydCBQeVByb3h5IHRvIEpTXG4gICAgICBjb25zdCBtID0gcmVzLnRvSnMoKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLm1hcFRvT2JqZWN0KG0pO1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmb3JtYXR0aW5nIHJlc3VsdDpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENvbnZlcnQgYSBNYXAgdG8gYSBKYXZhU2NyaXB0IG9iamVjdCByZWN1cnNpdmVseVxuICAgKiBCYXNlZCBvbiBQeW9kaWRlUmVtb3RlS2VybmVsIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBwcml2YXRlIG1hcFRvT2JqZWN0KG9iajogYW55KSB7XG4gICAgY29uc3Qgb3V0OiBhbnkgPSBvYmogaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge307XG4gICAgXG4gICAgb2JqLmZvckVhY2goKHZhbHVlOiBhbnksIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBvdXRba2V5XSA9IFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgPyB0aGlzLm1hcFRvT2JqZWN0KHZhbHVlKVxuICAgICAgICAgIDogdmFsdWU7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEhhbmRsZSBpbnB1dCByZXBseSBmcm9tIHVzZXJcbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbnB1dFJlcGx5KGNvbnRlbnQ6IHsgdmFsdWU6IHN0cmluZyB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuX3Jlc29sdmVJbnB1dFJlcGx5KSB7XG4gICAgICB0aGlzLl9yZXNvbHZlSW5wdXRSZXBseShjb250ZW50KTtcbiAgICAgIHRoaXMuX3Jlc29sdmVJbnB1dFJlcGx5ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZW5kIGEgaW5wdXQgcmVxdWVzdCB0byB0aGUgZnJvbnQtZW5kLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZW5kSW5wdXRSZXF1ZXN0KHByb21wdDogc3RyaW5nLCBwYXNzd29yZDogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgICBwcm9tcHQsXG4gICAgICBwYXNzd29yZCxcbiAgICB9O1xuXG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogJ2lucHV0X3JlcXVlc3QnLFxuICAgICAgY29udGVudCxcbiAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBhc3N3b3JkIGlucHV0ICh3aXRoIGhpZGRlbiBpbnB1dClcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0cGFzcyhwcm9tcHQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcHJvbXB0ID0gdHlwZW9mIHByb21wdCA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IHByb21wdDtcbiAgICBhd2FpdCB0aGlzLnNlbmRJbnB1dFJlcXVlc3QocHJvbXB0LCB0cnVlKTtcbiAgICBjb25zdCByZXBseVByb21pc2UgPSBuZXcgUHJvbWlzZTx7IHZhbHVlOiBzdHJpbmcgfT4oKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmVJbnB1dFJlcGx5ID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBseVByb21pc2U7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGV4dCBpbnB1dFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbnB1dChwcm9tcHQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcHJvbXB0ID0gdHlwZW9mIHByb21wdCA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IHByb21wdDtcbiAgICBhd2FpdCB0aGlzLnNlbmRJbnB1dFJlcXVlc3QocHJvbXB0LCBmYWxzZSk7XG4gICAgY29uc3QgcmVwbHlQcm9taXNlID0gbmV3IFByb21pc2U8eyB2YWx1ZTogc3RyaW5nIH0+KChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlSW5wdXRSZXBseSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbHlQcm9taXNlO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZW5kIGEgY29tbSBtZXNzYWdlIHRvIHRoZSBmcm9udC1lbmQuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNlbmRDb21tKHR5cGU6IHN0cmluZywgY29udGVudDogYW55LCBtZXRhZGF0YTogYW55LCBpZGVudDogYW55LCBidWZmZXJzOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgY29udGVudDogdGhpcy5mb3JtYXRSZXN1bHQoY29udGVudCksXG4gICAgICBtZXRhZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQobWV0YWRhdGEpLFxuICAgICAgaWRlbnQ6IHRoaXMuZm9ybWF0UmVzdWx0KGlkZW50KSxcbiAgICAgIGJ1ZmZlcnM6IHRoaXMuZm9ybWF0UmVzdWx0KGJ1ZmZlcnMpLFxuICAgICAgcGFyZW50SGVhZGVyOiB0aGlzLmZvcm1hdFJlc3VsdCh0aGlzLl9wYXJlbnRfaGVhZGVyKVsnaGVhZGVyJ10sXG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDb21wbGV0ZSB0aGUgY29kZSBzdWJtaXR0ZWQgYnkgYSB1c2VyLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvbXBsZXRlKGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBhd2FpdCB0aGlzLnNldHVwKHBhcmVudCk7XG4gICAgXG4gICAgY29uc3QgcmVzID0gdGhpcy5fa2VybmVsLmNvbXBsZXRlKGNvZGUsIGN1cnNvcl9wb3MpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3BlY3QgdGhlIGNvZGUgc3VibWl0dGVkIGJ5IGEgdXNlci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbnNwZWN0KGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBkZXRhaWxfbGV2ZWw6IDAgfCAxLCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBhd2FpdCB0aGlzLnNldHVwKHBhcmVudCk7XG4gICAgXG4gICAgY29uc3QgcmVzID0gdGhpcy5fa2VybmVsLmluc3BlY3QoY29kZSwgY3Vyc29yX3BvcywgZGV0YWlsX2xldmVsKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHQocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBjb2RlIGZvciBjb21wbGV0ZW5lc3MuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaXNDb21wbGV0ZShjb2RlOiBzdHJpbmcsIHBhcmVudDogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuaXNfY29tcGxldGUoY29kZSk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0KHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGF2YWlsYWJsZSBjb21tcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjb21tSW5mbyh0YXJnZXRfbmFtZTogc3RyaW5nIHwgbnVsbCwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5jb21tX2luZm8odGFyZ2V0X25hbWUpO1xuICAgIHJldHVybiB7XG4gICAgICBjb21tczogdGhpcy5mb3JtYXRSZXN1bHQocmVzKSxcbiAgICAgIHN0YXR1czogJ29rJyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gYSBDT01NXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29tbU9wZW4oY29udGVudDogYW55LCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5jb21tX21hbmFnZXIuY29tbV9vcGVuKFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkobnVsbCksXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShudWxsKSxcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KGNvbnRlbnQpXG4gICAgKTtcbiAgICBcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHQocmVzKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRocm91Z2ggYSBDT01NXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29tbU1zZyhjb250ZW50OiBhbnksIHBhcmVudDogYW55ID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnNldHVwKHBhcmVudCk7XG4gICAgXG4gICAgY29uc3QgcmVzID0gdGhpcy5fa2VybmVsLmNvbW1fbWFuYWdlci5jb21tX21zZyhcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkobnVsbCksXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShjb250ZW50KVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0KHJlcyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDbG9zZSBhIENPTU1cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjb21tQ2xvc2UoY29udGVudDogYW55LCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5jb21tX21hbmFnZXIuY29tbV9jbG9zZShcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkobnVsbCksXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShjb250ZW50KVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0KHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBQeXRob24gY29kZSB3aXRoIHN0cmVhbWluZyBvdXRwdXRcbiAgICogQHBhcmFtIGNvZGUgVGhlIFB5dGhvbiBjb2RlIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHBhcmVudCBQYXJlbnQgbWVzc2FnZSBoZWFkZXJcbiAgICogQHJldHVybnMgQXN5bmNHZW5lcmF0b3IgeWllbGRpbmcgaW50ZXJtZWRpYXRlIG91dHB1dHMgYW5kIGZpbmFsbHkgdGhlIGV4ZWN1dGlvbiByZXN1bHRcbiAgICovXG4gIHB1YmxpYyBhc3luYyogZXhlY3V0ZVN0cmVhbShjb2RlOiBzdHJpbmcsIHBhcmVudDogYW55ID0ge30pOiBBc3luY0dlbmVyYXRvcjxhbnksIHsgc3VjY2VzczogYm9vbGVhbiwgcmVzdWx0PzogYW55LCBlcnJvcj86IEVycm9yIH0sIHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBldmVudCBsaXN0ZW5lcnMgZm9yIHN0cmVhbWluZ1xuICAgICAgY29uc3QgZXZlbnRRdWV1ZTogSUV2ZW50RGF0YVtdID0gW107XG4gICAgICBcbiAgICAgIGNvbnN0IGhhbmRsZUFsbEV2ZW50cyA9IChldmVudERhdGE6IElFdmVudERhdGEpID0+IHtcbiAgICAgICAgZXZlbnRRdWV1ZS5wdXNoKGV2ZW50RGF0YSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBMaXN0ZW4gZm9yIGFsbCBldmVudHMgQkVGT1JFIGV4ZWN1dGluZyBjb2RlXG4gICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuQUxMLCBoYW5kbGVBbGxFdmVudHMpO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBVc2UgdGhlIGZpeGVkIGV4ZWN1dGUgbWV0aG9kIHdoaWNoIHByb3Blcmx5IHdhaXRzIGZvciBhbGwgbWVzc2FnZXNcbiAgICAgICAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IHRoaXMuZXhlY3V0ZShjb2RlLCBwYXJlbnQpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RyZWFtIGV2ZW50cyBhcyB0aGV5IGFycml2ZVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgcXVldWVkIGV2ZW50cyB0byB5aWVsZFxuICAgICAgICAgIGlmIChldmVudFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHlpZWxkIGV2ZW50UXVldWUuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgICAgY29uc3QgaXNDb21wbGV0ZSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICByZXN1bHRQcm9taXNlLnRoZW4oKCkgPT4gdHJ1ZSksXG4gICAgICAgICAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShmYWxzZSksIDEwKSlcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgLy8gWWllbGQgYW55IHJlbWFpbmluZyBldmVudHNcbiAgICAgICAgICAgIHdoaWxlIChldmVudFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgeWllbGQgZXZlbnRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdFByb21pc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZXhlY3V0ZVN0cmVhbTpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIENsZWFuIHVwIGxpc3RlbmVyIGluIGZpbmFsbHkgYmxvY2sgdG8gZW5zdXJlIGl0J3MgYWx3YXlzIHJlbW92ZWRcbiAgICAgICAgc3VwZXIub2ZmKEtlcm5lbEV2ZW50cy5BTEwsIGhhbmRsZUFsbEV2ZW50cyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBleGVjdXRlU3RyZWFtIHNldHVwOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnRlcnJ1cHQgZnVuY3Rpb25hbGl0eVxuICBwdWJsaWMgYXN5bmMgaW50ZXJydXB0KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCB8fCAhdGhpcy5weW9kaWRlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbS0VSTkVMXSBDYW5ub3QgaW50ZXJydXB0OiBrZXJuZWwgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYWluIHRocmVhZCBrZXJuZWxzIGhhdmUgbGltaXRlZCBpbnRlcnJ1cHQgc3VwcG9ydFxuICAgIC8vIEFjY29yZGluZyB0byBQeW9kaWRlIGRvY3MsIGludGVycnVwdHMgd29yayBiZXN0IGluIHdlYiB3b3JrZXJzXG4gICAgY29uc29sZS53YXJuKFwiW0tFUk5FTF0gTWFpbiB0aHJlYWQga2VybmVscyBoYXZlIGxpbWl0ZWQgaW50ZXJydXB0IHN1cHBvcnRcIik7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW50ZXJydXB0IGJ1ZmZlciBzZXQgdXAsIHRyeSB0byB1c2UgaXRcbiAgICAgIGlmICh0aGlzLl9pbnRlcnJ1cHRCdWZmZXIgJiYgdGhpcy5faW50ZXJydXB0U3VwcG9ydGVkKSB7XG4gICAgICAgIC8vIFNldCBpbnRlcnJ1cHQgc2lnbmFsICgyID0gU0lHSU5UKVxuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRCdWZmZXJbMF0gPSAyO1xuICAgICAgICBcbiAgICAgICAgLy8gR2l2ZSB0aGUgaW50ZXJydXB0IGEgbW9tZW50IHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW50ZXJydXB0IHdhcyBwcm9jZXNzZWQgKGJ1ZmZlciBzaG91bGQgYmUgcmVzZXQgdG8gMClcbiAgICAgICAgY29uc3Qgd2FzUHJvY2Vzc2VkID0gdGhpcy5faW50ZXJydXB0QnVmZmVyWzBdID09PSAwO1xuICAgICAgICByZXR1cm4gd2FzUHJvY2Vzc2VkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2s6IHRyeSB0byBmb3JjZSBhIFB5dGhvbiBpbnRlcnJ1cHQgdXNpbmcgdGhlIGludGVycHJldGVyXG4gICAgICAgXG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnByZXRlciAmJiB0eXBlb2YgdGhpcy5faW50ZXJwcmV0ZXIuaW50ZXJydXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5faW50ZXJwcmV0ZXIuaW50ZXJydXB0KCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNlbmQgc3RkZXJyIHN0cmVhbSBmaXJzdCAoZm9yIEp1cHl0ZXIgbm90ZWJvb2sgVUkgY29tcGF0aWJpbGl0eSlcbiAgICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6ICdzdHJlYW0nLFxuICAgICAgICAgIGJ1bmRsZToge1xuICAgICAgICAgICAgbmFtZTogJ3N0ZGVycicsXG4gICAgICAgICAgICB0ZXh0OiAnS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXFxuJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogJ2V4ZWN1dGVfZXJyb3InLFxuICAgICAgICAgIGJ1bmRsZToge1xuICAgICAgICAgICAgZW5hbWU6ICdLZXlib2FyZEludGVycnVwdCcsXG4gICAgICAgICAgICBldmFsdWU6ICdFeGVjdXRpb24gaW50ZXJydXB0ZWQgYnkgdXNlcicsXG4gICAgICAgICAgICB0cmFjZWJhY2s6IFsnS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyJ11cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbS0VSTkVMXSBFcnJvciBkdXJpbmcgaW50ZXJydXB0OlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldEludGVycnVwdEJ1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICB0aGlzLl9pbnRlcnJ1cHRCdWZmZXIgPSBidWZmZXI7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnB5b2RpZGUgJiYgdHlwZW9mIHRoaXMucHlvZGlkZS5zZXRJbnRlcnJ1cHRCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5weW9kaWRlLnNldEludGVycnVwdEJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW0tFUk5FTF0gcHlvZGlkZS5zZXRJbnRlcnJ1cHRCdWZmZXIgbm90IGF2YWlsYWJsZSwgaW50ZXJydXB0IHN1cHBvcnQgbGltaXRlZFwiKTtcbiAgICAgICAgdGhpcy5faW50ZXJydXB0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbS0VSTkVMXSBFcnJvciBzZXR0aW5nIGludGVycnVwdCBidWZmZXI6XCIsIGVycm9yKTtcbiAgICAgIHRoaXMuX2ludGVycnVwdFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpdGggcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uXG4gICAqIE9QVElNSVpFRDogUGFyYWxsZWwgdmFyaWFibGUgc2V0dGluZyBhbmQgdmFsaWRhdGlvbiB3aXRoIHByb3BlciBlc2NhcGluZyBhbmQgZWRnZSBjYXNlIGhhbmRsaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNldEVudmlyb25tZW50VmFyaWFibGVzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gTm8gdmFyaWFibGVzIHRvIHNldFxuICAgIH1cbiAgICBcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKGDwn4yNIFNldHRpbmcgJHtPYmplY3Qua2V5cyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKS5sZW5ndGh9IGVudmlyb25tZW50IHZhcmlhYmxlcy4uLmApO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBTZXQgZWFjaCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpbmRpdmlkdWFsbHkgdG8gYXZvaWQgZXNjYXBpbmcgaXNzdWVzXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKSkge1xuICAgICAgICAvLyBIYW5kbGUgZWRnZSBjYXNlczogbnVsbCwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGxldCBwcm9jZXNzZWRWYWx1ZTogc3RyaW5nO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBwcm9jZXNzZWRWYWx1ZSA9ICcnOyAgLy8gQ29udmVydCBudWxsIHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9jZXNzZWRWYWx1ZSA9ICcnOyAgLy8gQ29udmVydCB1bmRlZmluZWQgdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzc2VkVmFsdWUgPSBTdHJpbmcodmFsdWUpOyAgLy8gQ29udmVydCBldmVyeXRoaW5nIGVsc2UgdG8gc3RyaW5nXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHRoaXMucHlvZGlkZS5ydW5QeXRob25Bc3luYyhgXG5pbXBvcnQgb3Ncbm9zLmVudmlyb25bJHtKU09OLnN0cmluZ2lmeShrZXkpfV0gPSAke0pTT04uc3RyaW5naWZ5KHByb2Nlc3NlZFZhbHVlKX1cbmApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pqhIEVudmlyb25tZW50IHZhcmlhYmxlcyBzZXQgaW4gJHtkdXJhdGlvbn1tc2ApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEZhaWxlZCB0byBzZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLy8gT25seSBQeXRob24ga2VybmVsIGlzIHN1cHBvcnRlZFxuXG4vLyBFeHBvcnQgdGhlIG1hbmFnZXIgZm9yIGFkdmFuY2VkIHVzYWdlXG5leHBvcnQgeyBLZXJuZWxNYW5hZ2VyIH0gZnJvbSBcIi4vbWFuYWdlclwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.ts\n\n}");

/***/ }),

/***/ "./src/manager.ts":
/*!************************!*\
  !*** ./src/manager.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KernelEvents: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents),\n/* harmony export */   KernelLanguage: () => (/* binding */ KernelLanguage),\n/* harmony export */   KernelManager: () => (/* binding */ KernelManager),\n/* harmony export */   KernelMode: () => (/* binding */ KernelMode)\n/* harmony export */ });\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! comlink */ \"./node_modules/comlink/dist/esm/comlink.mjs\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ \"./src/index.ts\");\n// Kernel Manager for Deno App Engine\n// This file manages kernel instances in either main thread or worker mode\n\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    removeListener(eventName, listener) {\n        this.off(eventName, listener);\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n    setMaxListeners(n) {\n        // No-op for browser compatibility\n    }\n}\n\n\n// Re-export KernelEvents for test usage\n\n// Execution mode enum\nvar KernelMode;\n(function (KernelMode) {\n    KernelMode[\"MAIN_THREAD\"] = \"main_thread\";\n    KernelMode[\"WORKER\"] = \"worker\";\n})(KernelMode || (KernelMode = {}));\n// Kernel language enum\nvar KernelLanguage;\n(function (KernelLanguage) {\n    KernelLanguage[\"PYTHON\"] = \"python\";\n})(KernelLanguage || (KernelLanguage = {}));\n/**\n * KernelManager class manages multiple kernel instances\n * in either main thread or worker mode\n */\nclass KernelManager extends EventEmitter {\n    /**\n     * Helper function to check if an error is a KeyboardInterrupt\n     * @private\n     */\n    isKeyboardInterrupt(error) {\n        return error &&\n            typeof error === 'object' &&\n            (('type' in error && error.type === \"KeyboardInterrupt\") ||\n                ('message' in error && typeof error.message === 'string' && error.message.includes(\"KeyboardInterrupt\")));\n    }\n    /**\n     * Helper function to create a standardized KeyboardInterrupt error result\n     * @private\n     */\n    createKeyboardInterruptResult() {\n        return {\n            success: false,\n            error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n            result: {\n                status: \"error\",\n                ename: \"KeyboardInterrupt\",\n                evalue: \"Execution interrupted by user\",\n                traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n            }\n        };\n    }\n    /**\n     * Store an AbortController for a specific kernel execution\n     * @private\n     */\n    storeAbortController(kernelId, executionId, controller) {\n        if (!this.abortControllers.has(kernelId)) {\n            this.abortControllers.set(kernelId, new Map());\n        }\n        this.abortControllers.get(kernelId).set(executionId, controller);\n    }\n    /**\n     * Remove and return an AbortController for a specific kernel execution\n     * @private\n     */\n    removeAbortController(kernelId, executionId) {\n        const kernelControllers = this.abortControllers.get(kernelId);\n        if (!kernelControllers)\n            return undefined;\n        const controller = kernelControllers.get(executionId);\n        if (controller) {\n            kernelControllers.delete(executionId);\n            if (kernelControllers.size === 0) {\n                this.abortControllers.delete(kernelId);\n            }\n        }\n        return controller;\n    }\n    /**\n     * Abort all ongoing operations for a specific kernel\n     * @private\n     */\n    abortAllKernelOperations(kernelId) {\n        const kernelControllers = this.abortControllers.get(kernelId);\n        if (!kernelControllers)\n            return;\n        for (const [executionId, controller] of kernelControllers) {\n            try {\n                controller.abort();\n                console.log(`🚫 Aborted execution ${executionId} for kernel ${kernelId}`);\n            }\n            catch (error) {\n                console.warn(`⚠️ Error aborting execution ${executionId}:`, error);\n            }\n        }\n        // Clear all controllers for this kernel\n        this.abortControllers.delete(kernelId);\n    }\n    constructor(options = {}) {\n        super();\n        this.kernels = new Map();\n        // Track listeners for each kernel to enable individual removal\n        this.listenerWrappers = new Map();\n        // Track last activity time for each kernel\n        this.lastActivityTime = new Map();\n        // Store inactivity timers for each kernel\n        this.inactivityTimers = new Map();\n        // Track ongoing executions for each kernel\n        this.ongoingExecutions = new Map();\n        // Track execution timeouts for detecting stuck/dead kernels\n        this.executionTimeouts = new Map();\n        // Track execution start times for accurate duration calculation\n        this.executionStartTimes = new Map();\n        // Track execution metadata for better monitoring\n        this.executionMetadata = new Map();\n        // Track AbortControllers for each kernel's ongoing operations\n        this.abortControllers = new Map();\n        // Pool management - now using promises for immediate response\n        this.pool = new Map();\n        this.isPreloading = false;\n        // Track which pool keys are currently being prefilled to prevent duplicates\n        this.prefillingInProgress = new Map();\n        // Interrupt buffers for worker kernels (using SharedArrayBuffer)\n        this.interruptBuffers = new Map();\n        super.setMaxListeners(100); // Allow many listeners for kernel events\n        // Set default allowed kernel types (worker mode only for security)\n        this.allowedKernelTypes = options.allowedKernelTypes || [\n            { mode: KernelMode.WORKER, language: KernelLanguage.PYTHON }\n        ];\n        // Initialize pool configuration with defaults based on allowed types\n        const defaultPreloadConfigs = this.allowedKernelTypes.filter(type => type.language === KernelLanguage.PYTHON // Only preload Python kernels by default\n        );\n        this.poolConfig = {\n            enabled: false,\n            poolSize: 2,\n            autoRefill: true,\n            preloadConfigs: defaultPreloadConfigs,\n            ...options.pool\n        };\n        // Validate that pool preload configs are within allowed types\n        if (this.poolConfig.preloadConfigs) {\n            this.poolConfig.preloadConfigs = this.poolConfig.preloadConfigs.filter(config => {\n                const isAllowed = this.isKernelTypeAllowed(config.mode, config.language);\n                if (!isAllowed) {\n                    console.warn(`Pool preload config ${config.mode}-${config.language} is not in allowedKernelTypes, skipping`);\n                }\n                return isAllowed;\n            });\n        }\n        // Start preloading if pool is enabled\n        if (this.poolConfig.enabled) {\n            this.preloadPool().catch(error => {\n                console.error(\"Error preloading kernel pool:\", error);\n            });\n        }\n    }\n    /**\n     * Generate a pool key for a given mode and language combination\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Pool key string\n     * @private\n     */\n    getPoolKey(mode, language) {\n        return `${mode}-${language}`;\n    }\n    /**\n     * Get a kernel promise from the pool if available\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Kernel promise or null if none available\n     * @private\n     */\n    getFromPool(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return null;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        const poolPromises = this.pool.get(poolKey);\n        if (!poolPromises || poolPromises.length === 0) {\n            return null;\n        }\n        // Remove and return the first promise from the pool (FIFO)\n        const kernelPromise = poolPromises.shift();\n        // Immediately trigger background refill to add one promise back\n        if (this.poolConfig.autoRefill) {\n            setTimeout(() => {\n                this.refillPoolSingle(mode, language).catch(error => {\n                    console.error(`Error refilling single kernel for ${poolKey}:`, error);\n                });\n            }, 0);\n        }\n        return kernelPromise;\n    }\n    /**\n     * Add a kernel promise to the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @param kernelPromise Kernel promise\n     * @private\n     */\n    addToPool(mode, language, kernelPromise) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        if (!this.pool.has(poolKey)) {\n            this.pool.set(poolKey, []);\n        }\n        const poolPromises = this.pool.get(poolKey);\n        // Only add if we haven't reached the pool size limit\n        if (poolPromises.length < this.poolConfig.poolSize) {\n            poolPromises.push(kernelPromise);\n            // Handle promise rejection to prevent unhandled rejections\n            kernelPromise.catch(error => {\n                console.error(`Pool kernel promise rejected for ${poolKey}:`, error);\n                // Remove the failed promise from the pool\n                const index = poolPromises.indexOf(kernelPromise);\n                if (index !== -1) {\n                    poolPromises.splice(index, 1);\n                }\n            });\n        }\n        else {\n            // Pool is full, let the excess promise resolve and then destroy the kernel\n            kernelPromise.then(kernel => {\n                kernel.destroy().catch(error => {\n                    console.error(\"Error destroying excess pool kernel:\", error);\n                });\n            }).catch(error => {\n                console.error(\"Excess pool kernel promise rejected:\", error);\n            });\n        }\n    }\n    /**\n     * Refill the pool with a single kernel promise\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @private\n     */\n    async refillPoolSingle(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        const poolPromises = this.pool.get(poolKey) || [];\n        // Only add one if we're below the pool size\n        if (poolPromises.length < this.poolConfig.poolSize) {\n            const kernelPromise = this.createPoolKernelPromise(mode, language);\n            this.addToPool(mode, language, kernelPromise);\n        }\n    }\n    /**\n     * Refill the pool for a specific configuration with parallel creation\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @private\n     */\n    async refillPool(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        // Check if already prefilling this pool key to prevent duplicates\n        if (this.prefillingInProgress.get(poolKey)) {\n            return;\n        }\n        // Set prefilling flag\n        this.prefillingInProgress.set(poolKey, true);\n        try {\n            const poolPromises = this.pool.get(poolKey) || [];\n            const needed = this.poolConfig.poolSize - poolPromises.length;\n            if (needed <= 0) {\n                return;\n            }\n            // Create all needed kernel promises in parallel\n            const newPromises = Array.from({ length: needed }, () => this.createPoolKernelPromise(mode, language));\n            // Add all promises to the pool\n            for (const kernelPromise of newPromises) {\n                this.addToPool(mode, language, kernelPromise);\n            }\n        }\n        catch (error) {\n            console.error(`Error refilling pool for ${poolKey}:`, error);\n        }\n        finally {\n            // Always clear the prefilling flag\n            this.prefillingInProgress.set(poolKey, false);\n        }\n    }\n    /**\n     * Create a kernel promise for the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Promise that resolves to a kernel instance\n     * @private\n     */\n    createPoolKernelPromise(mode, language) {\n        return new Promise(async (resolve, reject) => {\n            try {\n                const kernel = await this.createPoolKernel(mode, language);\n                // Mark as taken from pool\n                kernel.isFromPool = true;\n                resolve(kernel);\n            }\n            catch (error) {\n                console.error(`Error creating pool kernel for ${mode}-${language}:`, error);\n                reject(error);\n            }\n        });\n    }\n    /**\n     * Create a kernel specifically for the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Kernel instance\n     * @private\n     */\n    async createPoolKernel(mode, language) {\n        // Generate a temporary ID for the pool kernel\n        const tempId = `pool-${crypto.randomUUID()}`;\n        // Create kernel with minimal configuration\n        const options = {\n            mode,\n            lang: language\n        };\n        // Store options temporarily - but don't store incomplete instance in kernels map\n        // Instead, we'll pass the options directly to the creation methods\n        let instance;\n        try {\n            if (mode === KernelMode.MAIN_THREAD) {\n                // For main thread, we need to temporarily store the instance for createMainThreadKernel\n                const tempInstance = {\n                    id: tempId,\n                    options,\n                    mode,\n                    language\n                };\n                this.kernels.set(tempId, tempInstance);\n                try {\n                    instance = await this.createMainThreadKernel(tempId);\n                }\n                finally {\n                    // Always clean up the temporary instance\n                    this.kernels.delete(tempId);\n                }\n            }\n            else {\n                // For worker mode, we need to temporarily store the instance for createWorkerKernel\n                const tempInstance = {\n                    id: tempId,\n                    options,\n                    mode,\n                    language\n                };\n                this.kernels.set(tempId, tempInstance);\n                try {\n                    instance = await this.createWorkerKernel(tempId);\n                }\n                finally {\n                    // Always clean up the temporary instance\n                    this.kernels.delete(tempId);\n                }\n            }\n        }\n        catch (error) {\n            // Ensure cleanup on any error\n            this.kernels.delete(tempId);\n            throw error;\n        }\n        return instance;\n    }\n    /**\n     * Preload the kernel pool with configured kernel types\n     * @private\n     */\n    async preloadPool() {\n        if (!this.poolConfig.enabled || this.isPreloading) {\n            return;\n        }\n        this.isPreloading = true;\n        try {\n            // Preload kernels for each configured type\n            for (const config of this.poolConfig.preloadConfigs) {\n                try {\n                    await this.refillPool(config.mode, config.language);\n                }\n                catch (error) {\n                    console.error(`Error preloading ${config.mode}-${config.language}:`, error);\n                    // Continue with other configurations\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Error during kernel pool preloading:\", error);\n        }\n        finally {\n            this.isPreloading = false;\n        }\n    }\n    /**\n     * Check if a kernel request can use the pool\n     * @param options Kernel creation options\n     * @returns True if the request can use pool\n     * @private\n     */\n    canUsePool(options) {\n        // Don't use pool if it's disabled\n        if (!this.poolConfig.enabled) {\n            return false;\n        }\n        // Don't use pool if custom filesystem or permissions are specified\n        if (options.filesystem || options.deno?.permissions) {\n            return false;\n        }\n        // Don't use pool if custom timeouts are specified\n        if (options.inactivityTimeout !== undefined || options.maxExecutionTime !== undefined) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Reassign a pool kernel with new ID and options\n     * @param poolKernel Kernel from pool\n     * @param newId New kernel ID\n     * @param options Kernel options\n     * @returns Updated kernel instance\n     * @private\n     */\n    reassignPoolKernel(poolKernel, newId, options) {\n        // Create a new instance object explicitly to avoid spread operator issues\n        const updatedInstance = {\n            id: newId,\n            kernel: poolKernel.kernel,\n            mode: poolKernel.mode,\n            language: poolKernel.language,\n            worker: poolKernel.worker,\n            created: new Date(), // Update creation time\n            options: { ...poolKernel.options, ...options },\n            isFromPool: true,\n            destroy: poolKernel.destroy // Preserve the original destroy function\n        };\n        // Verify the destroy function is properly set\n        if (typeof updatedInstance.destroy !== 'function') {\n            console.error('Failed to preserve destroy function during pool kernel reassignment');\n            console.error('poolKernel.destroy type:', typeof poolKernel.destroy);\n            console.error('updatedInstance.destroy type:', typeof updatedInstance.destroy);\n            throw new Error(`Failed to preserve destroy function during pool kernel reassignment`);\n        }\n        return updatedInstance;\n    }\n    /**\n     * Get pool statistics for debugging/monitoring\n     * @returns Pool statistics\n     */\n    getPoolStats() {\n        const stats = {};\n        for (const [poolKey, promises] of this.pool.entries()) {\n            stats[poolKey] = {\n                available: promises.length,\n                total: this.poolConfig.poolSize\n            };\n        }\n        return stats;\n    }\n    /**\n     * Get pool configuration information\n     * @returns Pool configuration details\n     */\n    getPoolConfig() {\n        return {\n            enabled: this.poolConfig.enabled,\n            poolSize: this.poolConfig.poolSize,\n            autoRefill: this.poolConfig.autoRefill,\n            preloadConfigs: [...this.poolConfig.preloadConfigs], // Return a copy to prevent modification\n            isPreloading: this.isPreloading\n        };\n    }\n    /**\n     * Create a new kernel instance\n     * @param options Options for creating the kernel\n     * @param options.id Optional custom ID for the kernel\n     * @param options.mode Optional kernel mode (main_thread or worker)\n     * @param options.lang Optional kernel language (python or typescript)\n     * @param options.namespace Optional namespace prefix for the kernel ID\n     * @param options.deno.permissions Optional Deno permissions for worker mode\n     * @param options.filesystem Optional filesystem mounting options\n     * @param options.inactivityTimeout Optional timeout in ms after which an inactive kernel will be shut down\n     * @param options.maxExecutionTime Optional maximum time in ms an execution can run before considered stuck\n     * @returns Promise resolving to the kernel instance ID\n     */\n    async createKernel(options = {}) {\n        // make sure the options.id does not contain colons because it will be used as a namespace prefix\n        if (options.id && options.id.includes(':')) {\n            throw new Error('Kernel ID cannot contain colons');\n        }\n        const baseId = options.id || crypto.randomUUID();\n        const mode = options.mode || KernelMode.WORKER;\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Check if the requested kernel type is allowed\n        if (!this.isKernelTypeAllowed(mode, language)) {\n            throw new Error(`Kernel type ${mode}-${language} is not allowed. Allowed types: ${this.allowedKernelTypes.map(t => `${t.mode}-${t.language}`).join(', ')}`);\n        }\n        // Apply namespace prefix if provided\n        const id = options.namespace ? `${options.namespace}:${baseId}` : baseId;\n        // Check if kernel with this ID already exists\n        if (this.kernels.has(id)) {\n            throw new Error(`Kernel with ID ${id} already exists`);\n        }\n        // Try to get from pool if possible\n        if (this.canUsePool(options)) {\n            const poolKey = this.getPoolKey(mode, language);\n            // Check if this kernel type is configured for pooling\n            const isPooledType = this.poolConfig.preloadConfigs.some(config => config.mode === mode && config.language === language);\n            if (isPooledType) {\n                // First try to get from existing pool\n                let poolKernelPromise = this.getFromPool(mode, language);\n                if (poolKernelPromise) {\n                    return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n                }\n                // Pool is empty, but this type should be pooled\n                // Create a new promise immediately and trigger background refill\n                try {\n                    // Create a new kernel promise specifically for this request\n                    const newKernelPromise = this.createPoolKernelPromise(mode, language);\n                    // Trigger background refill to replenish the pool for future requests\n                    if (this.poolConfig.autoRefill) {\n                        setTimeout(() => {\n                            this.refillPool(mode, language).catch(error => {\n                                console.error(`Error refilling exhausted pool for ${poolKey}:`, error);\n                            });\n                        }, 0);\n                    }\n                    return await this.setupPoolKernelFromPromise(newKernelPromise, id, options);\n                }\n                catch (error) {\n                    console.error(`Failed to create kernel promise for exhausted pool: ${error}`);\n                    // Fall through to on-demand creation as last resort\n                }\n            }\n            else {\n                // This kernel type is not configured for pooling, try to get from pool anyway\n                // in case there are kernels available from previous configurations\n                const poolKernelPromise = this.getFromPool(mode, language);\n                if (poolKernelPromise) {\n                    return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n                }\n            }\n        }\n        // Fall back to creating a new kernel on-demand\n        return this.createOnDemandKernel(id, mode, language, options);\n    }\n    /**\n     * Setup a pool kernel from a promise with new ID and options\n     * @param poolKernelPromise Kernel promise from pool\n     * @param id New kernel ID\n     * @param options Kernel options\n     * @returns Kernel ID (returned after kernel is ready)\n     * @private\n     */\n    async setupPoolKernelFromPromise(poolKernelPromise, id, options) {\n        try {\n            // Wait for the pool kernel to be ready\n            const poolKernel = await poolKernelPromise;\n            // Reassign the pool kernel with the new ID and options\n            const instance = this.reassignPoolKernel(poolKernel, id, options);\n            // For worker kernels, we need to recreate the event handler with the new ID\n            if (instance.mode === KernelMode.WORKER && instance.worker) {\n                // Get the worker and create new message channel\n                const worker = instance.worker;\n                // Create a new message channel for the reassigned kernel\n                const { port1, port2 } = new MessageChannel();\n                // Send the new event port to the worker\n                worker.postMessage({\n                    type: \"SET_EVENT_PORT\",\n                    port: port2\n                }, [port2]);\n                // Create a new event handler with the correct kernel ID\n                const eventHandler = (event) => {\n                    if (event.data && event.data.type) {\n                        // Emit the event from the manager with kernel ID\n                        // This structure matches the setupEventForwarding method for main thread kernels\n                        super.emit(event.data.type, {\n                            kernelId: id,\n                            data: event.data.data\n                        });\n                    }\n                };\n                // Listen for events from the worker with the new handler\n                port1.addEventListener('message', eventHandler);\n                port1.start();\n                // Update the destroy function to clean up the new event handler\n                const originalDestroy = instance.destroy;\n                instance.destroy = async () => {\n                    port1.removeEventListener('message', eventHandler);\n                    port1.close();\n                    return originalDestroy();\n                };\n            }\n            // Store the kernel instance\n            this.kernels.set(id, instance);\n            // Forward kernel events to manager (for main thread kernels)\n            this.setupEventForwarding(instance);\n            // Initialize activity tracking\n            this.updateKernelActivity(id);\n            // Set up inactivity timeout if specified and greater than 0\n            if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n                this.setupInactivityTimeout(id, options.inactivityTimeout);\n            }\n            // Setup handlers for stalled executions if maxExecutionTime is specified\n            if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n                this.setupStalledExecutionHandler(id);\n            }\n            return id;\n        }\n        catch (error) {\n            console.error(`Error setting up pool kernel ${id}:`, error);\n            // Emit an error event for this kernel\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: id,\n                data: {\n                    ename: \"KernelSetupError\",\n                    evalue: `Failed to setup kernel: ${error instanceof Error ? error.message : String(error)}`,\n                    traceback: [error instanceof Error ? (error.stack || error.message) : String(error)]\n                }\n            });\n            throw error; // Re-throw to let the caller handle it\n        }\n    }\n    /**\n     * Setup a pool kernel with new ID and options (for already resolved kernels)\n     * @param poolKernel Kernel from pool\n     * @param id New kernel ID\n     * @param options Kernel options\n     * @returns Kernel ID\n     * @private\n     */\n    setupPoolKernel(poolKernel, id, options) {\n        // Reassign the pool kernel with the new ID and options\n        const instance = this.reassignPoolKernel(poolKernel, id, options);\n        // For worker kernels, we need to recreate the event handler with the new ID\n        if (instance.mode === KernelMode.WORKER && instance.worker) {\n            // Get the worker and create new message channel\n            const worker = instance.worker;\n            // Create a new message channel for the reassigned kernel\n            const { port1, port2 } = new MessageChannel();\n            // Send the new event port to the worker\n            worker.postMessage({\n                type: \"SET_EVENT_PORT\",\n                port: port2\n            }, [port2]);\n            // Create a new event handler with the correct kernel ID\n            const eventHandler = (event) => {\n                if (event.data && event.data.type) {\n                    // Emit the event from the manager with kernel ID\n                    // This structure matches the setupEventForwarding method for main thread kernels\n                    super.emit(event.data.type, {\n                        kernelId: id,\n                        data: event.data.data\n                    });\n                }\n            };\n            // Listen for events from the worker with the new handler\n            port1.addEventListener('message', eventHandler);\n            port1.start();\n            // Update the destroy function to clean up the new event handler\n            const originalDestroy = instance.destroy;\n            instance.destroy = async () => {\n                port1.removeEventListener('message', eventHandler);\n                port1.close();\n                return originalDestroy();\n            };\n        }\n        // Store the kernel instance\n        this.kernels.set(id, instance);\n        // Forward kernel events to manager (for main thread kernels)\n        this.setupEventForwarding(instance);\n        // Initialize activity tracking\n        this.updateKernelActivity(id);\n        // Set up inactivity timeout if specified and greater than 0\n        if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n            this.setupInactivityTimeout(id, options.inactivityTimeout);\n        }\n        // Setup handlers for stalled executions if maxExecutionTime is specified\n        if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n            this.setupStalledExecutionHandler(id);\n        }\n        return id;\n    }\n    /**\n     * Create a kernel on-demand (not from pool)\n     * @param id Kernel ID\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @param options Kernel options\n     * @returns Kernel ID\n     * @private\n     */\n    async createOnDemandKernel(id, mode, language, options) {\n        // Store options temporarily to be used in createWorkerKernel\n        const tempInstance = {\n            id,\n            options: { ...options, lang: language },\n            mode,\n            language\n        };\n        this.kernels.set(id, tempInstance);\n        // Create the appropriate kernel instance\n        let instance;\n        if (mode === KernelMode.MAIN_THREAD) {\n            instance = await this.createMainThreadKernel(id);\n        }\n        else {\n            instance = await this.createWorkerKernel(id);\n        }\n        // Store the kernel instance\n        this.kernels.set(id, instance);\n        // Forward kernel events to manager\n        this.setupEventForwarding(instance);\n        // Initialize activity tracking\n        this.updateKernelActivity(id);\n        // Set up inactivity timeout if specified and greater than 0\n        if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n            this.setupInactivityTimeout(id, options.inactivityTimeout);\n        }\n        // Setup handlers for stalled executions if maxExecutionTime is specified\n        if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n            this.setupStalledExecutionHandler(id);\n        }\n        return id;\n    }\n    /**\n     * Create a kernel instance running in the main thread\n     * @param id Kernel ID\n     * @returns Kernel instance\n     */\n    async createMainThreadKernel(id) {\n        // Get options from the temporary instance\n        const options = this.kernels.get(id)?.options || {};\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Create the Python kernel\n        const kernel = new _index__WEBPACK_IMPORTED_MODULE_1__.Kernel();\n        // Create the kernel instance\n        const instance = {\n            id,\n            kernel,\n            mode: KernelMode.MAIN_THREAD,\n            language,\n            created: new Date(),\n            options,\n            destroy: async () => {\n                // Nothing special to do for main thread kernel\n                return Promise.resolve();\n            }\n        };\n        // Initialize the kernel with filesystem options\n        const kernelOptions = {};\n        // Add filesystem options if provided\n        if (options.filesystem) {\n            kernelOptions.filesystem = options.filesystem;\n        }\n        // Add environment variables if provided\n        if (options.env) {\n            kernelOptions.env = options.env;\n        }\n        // Initialize the kernel\n        await kernel.initialize(kernelOptions);\n        return instance;\n    }\n    /**\n     * Create a kernel instance running in a worker\n     * @param id Kernel ID\n     * @returns Kernel instance\n     */\n    async createWorkerKernel(id) {\n        // Get permissions from options when creating the kernel\n        const options = this.kernels.get(id)?.options || {};\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Create a new worker with optional permissions\n        const workerOptions = {\n            type: \"module\",\n        };\n        // If Deno permissions are provided, use them.\n        // Otherwise don't specify Deno permissions at all to inherit from host script\n        if (options.deno?.permissions) {\n            workerOptions.deno = {\n                permissions: options.deno.permissions\n            };\n        }\n        // Import worker using webpack worker-loader\n        // @ts-ignore: webpack will handle this require\n        const WorkerModule = __webpack_require__(/*! ./worker.worker */ \"./src/worker.worker.ts\");\n        // Create worker with permissions - worker-loader might export default or the class directly\n        const worker = WorkerModule.default ? new WorkerModule.default() : new WorkerModule();\n        // Create a message channel for events\n        const { port1, port2 } = new MessageChannel();\n        // Create a promise that will resolve when the kernel is initialized\n        const initPromise = new Promise((resolve, reject) => {\n            const initHandler = (event) => {\n                if (event.data?.type === \"KERNEL_INITIALIZED\") {\n                    if (event.data.data.success) {\n                        port1.removeEventListener('message', initHandler);\n                        resolve();\n                    }\n                    else {\n                        port1.removeEventListener('message', initHandler);\n                        reject(new Error(\"Kernel initialization failed\"));\n                    }\n                }\n            };\n            port1.addEventListener('message', initHandler);\n        });\n        // Send the port to the worker\n        worker.postMessage({ type: \"SET_EVENT_PORT\", port: port2 }, [port2]);\n        // Create a proxy to the worker using Comlink\n        const kernelProxy = comlink__WEBPACK_IMPORTED_MODULE_2__.wrap(worker);\n        // Add a local event handler to bridge the worker events\n        // This works around the limitation that Comlink doesn't proxy event emitters\n        const eventHandler = (event) => {\n            if (event.data && event.data.type) {\n                // Emit the event from the manager with kernel ID\n                // This structure matches the setupEventForwarding method for main thread kernels\n                super.emit(event.data.type, {\n                    kernelId: id,\n                    data: event.data.data\n                });\n            }\n        };\n        // Listen for events from the worker\n        port1.addEventListener('message', eventHandler);\n        port1.start();\n        // Initialize the kernel with filesystem options\n        // We need to pass these options to the worker\n        worker.postMessage({\n            type: \"INITIALIZE_KERNEL\",\n            options: {\n                filesystem: options.filesystem,\n                env: options.env,\n                lang: language\n            }\n        });\n        // Wait for kernel initialization\n        await initPromise;\n        // Set up interrupt buffer automatically for worker kernels\n        await this.setupWorkerInterruptBuffer(id, worker);\n        // Create the kernel instance\n        const instance = {\n            id,\n            kernel: {\n                // Map methods from the Comlink proxy to the IKernel interface\n                initialize: async (options) => {\n                    return kernelProxy.initialize(options);\n                },\n                execute: async (code, parent) => {\n                    const result = await kernelProxy.execute(code, parent);\n                    // Handle Python worker results (no special display reconstruction needed)\n                    return result;\n                },\n                isInitialized: () => {\n                    return kernelProxy.isInitialized();\n                },\n                inputReply: async (content) => {\n                    return kernelProxy.inputReply(content);\n                },\n                // Map async getStatus method\n                getStatus: async () => {\n                    try {\n                        if (typeof kernelProxy.getStatus === 'function') {\n                            return await kernelProxy.getStatus();\n                        }\n                        else {\n                            return \"unknown\";\n                        }\n                    }\n                    catch (error) {\n                        return \"unknown\";\n                    }\n                },\n                // Map completion methods\n                complete: async (code, cursor_pos, parent) => {\n                    try {\n                        if (typeof kernelProxy.complete === 'function') {\n                            return await kernelProxy.complete(code, cursor_pos, parent);\n                        }\n                        else {\n                            return { status: 'error', error: 'Completion not supported' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                inspect: async (code, cursor_pos, detail_level, parent) => {\n                    try {\n                        if (typeof kernelProxy.inspect === 'function') {\n                            return await kernelProxy.inspect(code, cursor_pos, detail_level, parent);\n                        }\n                        else {\n                            return { status: 'error', error: 'Inspection not supported' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                isComplete: async (code, parent) => {\n                    try {\n                        if (typeof kernelProxy.isComplete === 'function') {\n                            return await kernelProxy.isComplete(code, parent);\n                        }\n                        else {\n                            return { status: 'unknown' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                // Map interrupt methods\n                interrupt: async () => {\n                    try {\n                        if (typeof kernelProxy.interrupt === 'function') {\n                            return await kernelProxy.interrupt();\n                        }\n                        else {\n                            return false;\n                        }\n                    }\n                    catch (error) {\n                        return false;\n                    }\n                },\n                setInterruptBuffer: (buffer) => {\n                    try {\n                        if (typeof kernelProxy.setInterruptBuffer === 'function') {\n                            kernelProxy.setInterruptBuffer(buffer);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to set interrupt buffer:', error);\n                    }\n                },\n                // Map comm methods\n                commInfo: async (target_name, parent) => {\n                    try {\n                        if (typeof kernelProxy.commInfo === 'function') {\n                            return await kernelProxy.commInfo(target_name, parent);\n                        }\n                        else {\n                            return { comms: {}, status: 'ok' };\n                        }\n                    }\n                    catch (error) {\n                        return { comms: {}, status: 'error', error: String(error) };\n                    }\n                },\n                commOpen: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commOpen === 'function') {\n                            return await kernelProxy.commOpen(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to open comm:', error);\n                    }\n                },\n                commMsg: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commMsg === 'function') {\n                            return await kernelProxy.commMsg(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to send comm message:', error);\n                    }\n                },\n                commClose: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commClose === 'function') {\n                            return await kernelProxy.commClose(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to close comm:', error);\n                    }\n                }\n            },\n            mode: KernelMode.WORKER,\n            language,\n            worker,\n            created: new Date(),\n            options, // Store the options for reference\n            destroy: async () => {\n                // Clean up the worker and event listeners\n                port1.removeEventListener('message', eventHandler);\n                port1.close();\n                worker.terminate();\n                return Promise.resolve();\n            }\n        };\n        return instance;\n    }\n    /**\n     * Setup event forwarding from kernel to manager\n     * @param instance Kernel instance\n     */\n    setupEventForwarding(instance) {\n        // Only needed for main thread kernels as worker events are handled directly\n        if (instance.mode === KernelMode.MAIN_THREAD) {\n            // Forward all kernel events to the manager with kernel ID\n            Object.values(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents).forEach((eventType) => {\n                // Access the kernel as a Kernel instance which extends EventEmitter\n                const kernelEmitter = instance.kernel;\n                // Add event listener to forward events\n                kernelEmitter.on(eventType, (data) => {\n                    super.emit(eventType, {\n                        kernelId: instance.id,\n                        data\n                    });\n                });\n            });\n        }\n    }\n    /**\n     * Get a kernel instance by ID\n     * @param id Kernel ID\n     * @returns Kernel instance or undefined if not found\n     */\n    getKernel(id) {\n        return this.kernels.get(id);\n    }\n    /**\n     * Get a list of all kernel IDs\n     * @returns Array of kernel IDs\n     */\n    getKernelIds() {\n        return Array.from(this.kernels.keys());\n    }\n    /**\n     * Get a list of all kernels with their details\n     * @param namespace Optional namespace to filter kernels by\n     * @returns Array of kernel information objects\n     */\n    async listKernels(namespace) {\n        const filteredKernels = Array.from(this.kernels.entries())\n            .filter(([id]) => {\n            // Filter out pool kernels (temporary kernels with IDs starting with \"pool-\")\n            if (id.startsWith(\"pool-\"))\n                return false;\n            if (!namespace)\n                return true;\n            return id.startsWith(`${namespace}:`);\n        });\n        // Use Promise.all to get all statuses concurrently\n        const kernelInfos = await Promise.all(filteredKernels.map(async ([id, instance]) => {\n            // Extract namespace from id if present\n            const namespaceMatch = id.match(/^([^:]+):/);\n            const extractedNamespace = namespaceMatch ? namespaceMatch[1] : undefined;\n            // Get status using async getStatus method\n            let status = \"unknown\";\n            try {\n                if (instance && instance.kernel && typeof instance.kernel.getStatus === 'function') {\n                    status = await instance.kernel.getStatus();\n                }\n            }\n            catch (error) {\n                console.warn(`Error getting status for kernel ${id}:`, error);\n                status = \"unknown\";\n            }\n            return {\n                id,\n                mode: instance.mode,\n                language: instance.language,\n                status,\n                created: instance.created || new Date(),\n                namespace: extractedNamespace,\n                deno: instance.options?.deno\n            };\n        }));\n        return kernelInfos;\n    }\n    /**\n     * Destroy a kernel instance\n     * @param id Kernel ID\n     * @returns Promise resolving when kernel is destroyed\n     */\n    async destroyKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            // Handle gracefully - kernel may already be destroyed\n            return;\n        }\n        // Verify the destroy function exists\n        if (typeof instance.destroy !== 'function') {\n            throw new Error(`Kernel ${id} is missing destroy function (type: ${typeof instance.destroy})`);\n        }\n        // Abort all ongoing operations for this kernel first\n        this.abortAllKernelOperations(id);\n        // Clear any inactivity timer\n        this.clearInactivityTimeout(id);\n        // Clean up execution timeouts\n        if (this.executionTimeouts.has(id)) {\n            const timeouts = this.executionTimeouts.get(id);\n            for (const timeoutId of timeouts.values()) {\n                clearTimeout(timeoutId);\n            }\n            this.executionTimeouts.delete(id);\n        }\n        // Clean up execution start times\n        if (this.executionStartTimes.has(id)) {\n            this.executionStartTimes.delete(id);\n        }\n        // Clean up execution metadata\n        if (this.executionMetadata.has(id)) {\n            this.executionMetadata.delete(id);\n        }\n        // Clean up interrupt buffers\n        if (this.interruptBuffers.has(id)) {\n            this.interruptBuffers.delete(id);\n        }\n        // Clean up ongoing executions tracking\n        this.ongoingExecutions.delete(id);\n        // Clean up activity tracking\n        this.lastActivityTime.delete(id);\n        // Remove all event listeners for this kernel\n        this.removeAllKernelListeners(id);\n        // Destroy the kernel instance\n        await instance.destroy();\n        // Remove the kernel from the map\n        this.kernels.delete(id);\n    }\n    /**\n     * Destroy all kernel instances\n     * @param namespace Optional namespace to filter kernels to destroy\n     * @returns Promise resolving when all kernels are destroyed\n     */\n    async destroyAll(namespace) {\n        const ids = Array.from(this.kernels.keys())\n            .filter(id => {\n            if (!namespace)\n                return true;\n            return id.startsWith(`${namespace}:`);\n        });\n        // Destroy all kernels, but skip incomplete instances\n        const destroyPromises = ids.map(async (id) => {\n            const instance = this.kernels.get(id);\n            if (!instance || typeof instance.destroy !== 'function') {\n                console.warn(`Skipping incomplete kernel instance ${id} during destroyAll`);\n                // Just remove it from the map\n                this.kernels.delete(id);\n                return;\n            }\n            return this.destroyKernel(id);\n        });\n        await Promise.all(destroyPromises);\n        // If no namespace specified, also clean up the pool\n        if (!namespace) {\n            await this.destroyPool();\n        }\n    }\n    /**\n     * Destroy all kernels in the pool\n     * @private\n     */\n    async destroyPool() {\n        const destroyPromises = [];\n        for (const [poolKey, promises] of this.pool.entries()) {\n            for (const kernelPromise of promises) {\n                // Handle each promise - if it resolves, destroy the kernel\n                const destroyPromise = kernelPromise.then(kernel => {\n                    return kernel.destroy();\n                }).catch(error => {\n                    console.error(`Error destroying pool kernel from promise:`, error);\n                    // Don't re-throw to avoid unhandled rejections\n                });\n                destroyPromises.push(destroyPromise);\n            }\n        }\n        // Wait for all pool kernels to be destroyed\n        await Promise.all(destroyPromises);\n        // Clear the pool and prefilling flags\n        this.pool.clear();\n        this.prefillingInProgress.clear();\n    }\n    /**\n     * Register an event listener for a specific kernel's events\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @param listener Event listener\n     */\n    onKernelEvent(kernelId, eventType, listener) {\n        // Check if kernel exists\n        if (!this.kernels.has(kernelId)) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Create wrapper that filters events for this specific kernel\n        const wrapper = {\n            original: listener,\n            wrapped: (event) => {\n                if (event.kernelId === kernelId) {\n                    // Pass just the data to the listener\n                    // The data structure is consistent across main thread and worker modes\n                    listener(event.data);\n                }\n            }\n        };\n        // Store the wrapper for later removal\n        this.storeListener(kernelId, eventType, listener, wrapper);\n        // Add the wrapped listener to the manager\n        super.on(eventType, wrapper.wrapped);\n    }\n    /**\n     * Remove an event listener for a specific kernel\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @param listener Event listener\n     */\n    offKernelEvent(kernelId, eventType, listener) {\n        const wrapper = this.getListener(kernelId, eventType, listener);\n        if (wrapper) {\n            // Remove the wrapped listener from the manager\n            super.removeListener(eventType, wrapper.wrapped);\n            // Remove the wrapper from our tracking map\n            this.removeStoredListener(kernelId, eventType, listener);\n        }\n    }\n    /**\n     * Store a listener wrapper for later removal\n     */\n    storeListener(kernelId, eventType, original, wrapper) {\n        // Get or create kernel map\n        if (!this.listenerWrappers.has(kernelId)) {\n            this.listenerWrappers.set(kernelId, new Map());\n        }\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        // Get or create event type map\n        if (!kernelMap.has(eventType)) {\n            kernelMap.set(eventType, new Map());\n        }\n        const eventMap = kernelMap.get(eventType);\n        // Store the wrapper\n        eventMap.set(original, wrapper);\n    }\n    /**\n     * Get a stored listener wrapper\n     */\n    getListener(kernelId, eventType, original) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return undefined;\n        const eventMap = kernelMap.get(eventType);\n        if (!eventMap)\n            return undefined;\n        return eventMap.get(original);\n    }\n    /**\n     * Remove a stored listener wrapper\n     */\n    removeStoredListener(kernelId, eventType, original) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return;\n        const eventMap = kernelMap.get(eventType);\n        if (!eventMap)\n            return;\n        // Remove the listener\n        eventMap.delete(original);\n        // Clean up empty maps\n        if (eventMap.size === 0) {\n            kernelMap.delete(eventType);\n        }\n        if (kernelMap.size === 0) {\n            this.listenerWrappers.delete(kernelId);\n        }\n    }\n    /**\n     * Remove all listeners for a specific kernel\n     */\n    removeAllKernelListeners(kernelId) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return;\n        // For each event type\n        for (const [eventType, eventMap] of kernelMap.entries()) {\n            // For each original listener\n            for (const wrapper of eventMap.values()) {\n                // Remove the wrapped listener from the manager\n                super.removeListener(eventType, wrapper.wrapped);\n            }\n        }\n        // Clear the kernel's listener map\n        this.listenerWrappers.delete(kernelId);\n    }\n    /**\n     * Get all listeners for a specific kernel and event type\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @returns Array of listeners\n     */\n    getListeners(kernelId, eventType) {\n        const kernelListeners = this.listenerWrappers.get(kernelId);\n        if (!kernelListeners) {\n            return [];\n        }\n        const eventListeners = kernelListeners.get(eventType);\n        if (!eventListeners) {\n            return [];\n        }\n        return Array.from(eventListeners.keys());\n    }\n    /**\n     * Execute Python code with streaming output\n     * This method works in both main thread and worker modes\n     * @param kernelId ID of the kernel to use\n     * @param code The Python code to execute\n     * @param parent Optional parent message header\n     * @returns AsyncGenerator yielding intermediate outputs\n     */\n    async *executeStream(kernelId, code, parent = {}) {\n        const instance = this.getKernel(kernelId);\n        if (!instance) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Update kernel activity\n        this.updateKernelActivity(kernelId);\n        // Track this execution with the code for better monitoring\n        const executionId = this.trackExecution(kernelId, code);\n        // Create AbortController for this execution to enable cancellation\n        const abortController = new AbortController();\n        this.storeAbortController(kernelId, executionId, abortController);\n        try {\n            // For main thread kernels, we can use the executeStream method directly\n            if (instance.mode === KernelMode.MAIN_THREAD) {\n                const kernel = instance.kernel;\n                // Forward to the kernel's executeStream method\n                if (typeof kernel.executeStream === 'function') {\n                    try {\n                        yield* kernel.executeStream(code, parent);\n                        // Update activity after execution completes\n                        this.updateKernelActivity(kernelId);\n                        // Complete execution tracking\n                        this.completeExecution(kernelId, executionId);\n                        return { success: true };\n                    }\n                    catch (error) {\n                        console.error(`Error in main thread executeStream:`, error);\n                        // Update activity even if there's an error\n                        this.updateKernelActivity(kernelId);\n                        // Complete execution tracking even on error\n                        this.completeExecution(kernelId, executionId);\n                        return {\n                            success: false,\n                            error: error instanceof Error ? error : new Error(String(error))\n                        };\n                    }\n                }\n            }\n            // For worker mode, we need to implement streaming via events with proper isolation\n            try {\n                // Event-based approach for worker kernels or main thread kernels without executeStream\n                const streamQueue = [];\n                let executionComplete = false;\n                let executionResult = { success: true };\n                // Store handler references for guaranteed cleanup\n                const eventHandlers = new Map();\n                // Helper function to clean up all event handlers\n                const cleanupHandlers = () => {\n                    for (const [eventType, handler] of eventHandlers.entries()) {\n                        super.off(eventType, handler);\n                    }\n                    eventHandlers.clear();\n                };\n                // Create execution-specific event handlers that include executionId check\n                const createHandler = (eventType) => {\n                    const handler = (event) => {\n                        // Only process events for this specific kernel and while this execution is active\n                        if (event.kernelId === kernelId && !executionComplete) {\n                            streamQueue.push({\n                                type: eventType,\n                                data: event.data,\n                                executionId // Include execution ID for debugging\n                            });\n                            // Events also count as activity\n                            this.updateKernelActivity(kernelId);\n                        }\n                    };\n                    eventHandlers.set(eventType, handler);\n                    return handler;\n                };\n                // Create and register all event handlers\n                const handleStreamEvent = createHandler('stream');\n                const handleDisplayEvent = createHandler('display_data');\n                const handleUpdateDisplayEvent = createHandler('update_display_data');\n                const handleResultEvent = createHandler('execute_result');\n                const handleErrorEvent = createHandler('execute_error');\n                // Register handlers\n                super.on(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.STREAM, handleStreamEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.DISPLAY_DATA, handleDisplayEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.UPDATE_DISPLAY_DATA, handleUpdateDisplayEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTE_RESULT, handleResultEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTE_ERROR, handleErrorEvent);\n                // Create a promise that will resolve when execution is complete\n                const executionPromise = new Promise((resolve, reject) => {\n                    // Set up a handler for execution errors specifically\n                    const handleExecutionError = (event) => {\n                        if (event.kernelId === kernelId && !executionComplete) {\n                            // Mark execution as complete to stop processing more events\n                            executionComplete = true;\n                            // Store the error for the final result\n                            executionResult = {\n                                success: false,\n                                error: new Error(`${event.data.ename}: ${event.data.evalue}`),\n                                result: event.data\n                            };\n                            // Update activity\n                            this.updateKernelActivity(kernelId);\n                            resolve(executionResult);\n                        }\n                    };\n                    // Add error handler to our cleanup list\n                    eventHandlers.set('execute_error_completion', handleExecutionError);\n                    super.on(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTE_ERROR, handleExecutionError);\n                    // Check if already aborted\n                    if (abortController.signal.aborted) {\n                        executionComplete = true;\n                        resolve({\n                            success: false,\n                            error: new Error('Execution was aborted')\n                        });\n                        return;\n                    }\n                    // Set up abort handler\n                    const abortHandler = () => {\n                        if (!executionComplete) {\n                            console.log(`🚫 Execution ${executionId} aborted`);\n                            executionComplete = true;\n                            resolve({\n                                success: false,\n                                error: new Error('Execution was aborted')\n                            });\n                        }\n                    };\n                    abortController.signal.addEventListener('abort', abortHandler);\n                    // Execute the code\n                    // We know the execute method is available directly on the kernel object\n                    try {\n                        const executePromise = instance.kernel.execute(code, parent);\n                        executePromise.then((result) => {\n                            // Only process if execution hasn't been marked complete already\n                            if (!executionComplete) {\n                                // Check if the execution result indicates an error (for Python kernels)\n                                if (result.success && result.result && result.result.status === \"error\") {\n                                    // Handle as error\n                                    const errorData = {\n                                        status: result.result.status,\n                                        ename: result.result.ename,\n                                        evalue: result.result.evalue,\n                                        traceback: result.result.traceback\n                                    };\n                                    // Push error to stream queue directly \n                                    streamQueue.push({\n                                        type: 'error',\n                                        data: errorData,\n                                        executionId\n                                    });\n                                    // Update execution result to reflect the error\n                                    executionResult = {\n                                        success: false,\n                                        error: new Error(`${result.result.ename}: ${result.result.evalue}`),\n                                        result: result.result\n                                    };\n                                }\n                                else {\n                                    executionResult = result;\n                                }\n                                executionComplete = true;\n                                // Update activity when execution completes\n                                this.updateKernelActivity(kernelId);\n                                resolve(executionResult);\n                            }\n                        }).catch((error) => {\n                            // Only process if execution hasn't been marked complete already\n                            if (!executionComplete) {\n                                console.error(`Error in execute for kernel ${kernelId}:`, error);\n                                // Check if this is a KeyboardInterrupt and handle it specially\n                                let errorResult;\n                                if (this.isKeyboardInterrupt(error)) {\n                                    console.log(`KeyboardInterrupt caught in executeStream for kernel ${kernelId}`);\n                                    errorResult = this.createKeyboardInterruptResult();\n                                    // Also push to stream queue for immediate feedback\n                                    streamQueue.push({\n                                        type: 'error',\n                                        data: errorResult.result,\n                                        executionId\n                                    });\n                                }\n                                else {\n                                    // Handle other errors normally\n                                    errorResult = {\n                                        success: false,\n                                        error: error instanceof Error ? error : new Error(String(error))\n                                    };\n                                }\n                                executionComplete = true;\n                                executionResult = errorResult;\n                                // Update activity even on error\n                                this.updateKernelActivity(kernelId);\n                                resolve(errorResult);\n                            }\n                        });\n                    }\n                    catch (error) {\n                        // Only process if execution hasn't been marked complete already\n                        if (!executionComplete) {\n                            console.error(`Error calling execute for kernel ${kernelId}:`, error);\n                            // Simple error handling\n                            const errorResult = {\n                                success: false,\n                                error: error instanceof Error ? error : new Error(String(error))\n                            };\n                            executionComplete = true;\n                            executionResult = errorResult;\n                            // Update activity even on direct error\n                            this.updateKernelActivity(kernelId);\n                            resolve(errorResult);\n                        }\n                    }\n                });\n                // Use try/finally to guarantee cleanup\n                try {\n                    // Monitor the stream queue and yield results\n                    // Continue until execution is complete AND all queued events have been yielded\n                    while ((!executionComplete || streamQueue.length > 0) && !abortController.signal.aborted) {\n                        // If there are items in the queue, yield them\n                        if (streamQueue.length > 0) {\n                            const event = streamQueue.shift();\n                            yield event;\n                            continue;\n                        }\n                        // If no more events but execution is not complete, wait a little\n                        if (!executionComplete) {\n                            // Use abort signal to cancel the wait\n                            try {\n                                await new Promise((resolve, reject) => {\n                                    const timeoutId = setTimeout(resolve, 10);\n                                    abortController.signal.addEventListener('abort', () => {\n                                        clearTimeout(timeoutId);\n                                        reject(new Error('Aborted'));\n                                    });\n                                });\n                            }\n                            catch (error) {\n                                // If aborted, break out of loop\n                                if (abortController.signal.aborted) {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // Check if execution was aborted during stream monitoring\n                    if (abortController.signal.aborted && !executionComplete) {\n                        throw new Error('Execution was aborted during stream monitoring');\n                    }\n                    // Wait for the final result\n                    const result = await executionPromise;\n                    return result;\n                }\n                finally {\n                    // ALWAYS clean up event handlers regardless of how execution ends\n                    cleanupHandlers();\n                    // Remove AbortController to prevent memory leaks\n                    this.removeAbortController(kernelId, executionId);\n                    // Complete execution tracking\n                    this.completeExecution(kernelId, executionId);\n                }\n            }\n            catch (error) {\n                // Complete execution tracking on any outer error\n                this.completeExecution(kernelId, executionId);\n                console.error(`Unexpected error in executeStream:`, error);\n                return {\n                    success: false,\n                    error: error instanceof Error ? error : new Error(String(error))\n                };\n            }\n        }\n        catch (error) {\n            // Complete execution tracking on any outer error\n            this.completeExecution(kernelId, executionId);\n            console.error(`Unexpected error in executeStream:`, error);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Track a new execution task for a kernel\n     * @param kernelId Kernel ID\n     * @param code Optional code being executed for metadata\n     * @returns Unique execution ID\n     * @private\n     */\n    trackExecution(kernelId, code) {\n        // Create a unique execution ID\n        const executionId = `exec-${crypto.randomUUID()}`;\n        const startTime = Date.now();\n        // Reset interrupt buffer for worker kernels before each new execution\n        // This ensures the kernel can be interrupted multiple times\n        const instance = this.kernels.get(kernelId);\n        if (instance && instance.mode === KernelMode.WORKER && this.interruptBuffers.has(kernelId)) {\n            const interruptBuffer = this.interruptBuffers.get(kernelId);\n            // Reset buffer to 0 (no interrupt signal) to ensure clean state\n            interruptBuffer[0] = 0;\n        }\n        // Get or create the set of ongoing executions for this kernel\n        if (!this.ongoingExecutions.has(kernelId)) {\n            this.ongoingExecutions.set(kernelId, new Set());\n        }\n        // Add this execution to the set\n        this.ongoingExecutions.get(kernelId).add(executionId);\n        // Track execution start time\n        if (!this.executionStartTimes.has(kernelId)) {\n            this.executionStartTimes.set(kernelId, new Map());\n        }\n        this.executionStartTimes.get(kernelId).set(executionId, startTime);\n        // Track execution metadata\n        if (!this.executionMetadata.has(kernelId)) {\n            this.executionMetadata.set(kernelId, new Map());\n        }\n        // Update activity timestamp\n        this.updateKernelActivity(kernelId);\n        // If maxExecutionTime is set, create a timeout to detect stuck/dead kernels\n        if (instance && instance.options.maxExecutionTime && instance.options.maxExecutionTime > 0) {\n            // Get or create the map of execution timeouts for this kernel\n            if (!this.executionTimeouts.has(kernelId)) {\n                this.executionTimeouts.set(kernelId, new Map());\n            }\n            // Set a timeout for this execution with enhanced handling\n            const timeoutId = setTimeout(() => {\n                console.warn(`Execution ${executionId} on kernel ${kernelId} has been running for ${instance.options.maxExecutionTime}ms and may be stuck/dead.`);\n                // Get execution metadata for better error reporting\n                const metadata = this.executionMetadata.get(kernelId)?.get(executionId);\n                const actualRuntime = Date.now() - (metadata?.startTime || startTime);\n                // Emit a stalled execution event with enhanced information\n                super.emit('execution_stalled', {\n                    kernelId,\n                    executionId,\n                    maxExecutionTime: instance.options.maxExecutionTime,\n                    actualRuntime,\n                    code: metadata?.code || code,\n                    startTime: metadata?.startTime || startTime\n                });\n                // Auto-handle stuck execution if configured\n                this.handleStuckExecution(kernelId, executionId, actualRuntime, metadata?.code || code);\n            }, instance.options.maxExecutionTime);\n            // Store the timeout ID\n            this.executionTimeouts.get(kernelId).set(executionId, timeoutId);\n            // Store metadata including timeout ID\n            this.executionMetadata.get(kernelId).set(executionId, {\n                startTime,\n                code,\n                timeoutId\n            });\n        }\n        else {\n            // Store metadata without timeout ID\n            this.executionMetadata.get(kernelId).set(executionId, {\n                startTime,\n                code\n            });\n        }\n        return executionId;\n    }\n    /**\n     * Complete tracking for an execution\n     * @param kernelId Kernel ID\n     * @param executionId Execution ID\n     * @private\n     */\n    completeExecution(kernelId, executionId) {\n        // Clear any execution timeout\n        if (this.executionTimeouts.has(kernelId)) {\n            const timeouts = this.executionTimeouts.get(kernelId);\n            if (timeouts.has(executionId)) {\n                clearTimeout(timeouts.get(executionId));\n                timeouts.delete(executionId);\n            }\n            // Clean up empty maps\n            if (timeouts.size === 0) {\n                this.executionTimeouts.delete(kernelId);\n            }\n        }\n        // Clean up execution start times\n        if (this.executionStartTimes.has(kernelId)) {\n            const startTimes = this.executionStartTimes.get(kernelId);\n            startTimes.delete(executionId);\n            // Clean up empty maps\n            if (startTimes.size === 0) {\n                this.executionStartTimes.delete(kernelId);\n            }\n        }\n        // Clean up execution metadata\n        if (this.executionMetadata.has(kernelId)) {\n            const metadata = this.executionMetadata.get(kernelId);\n            metadata.delete(executionId);\n            // Clean up empty maps\n            if (metadata.size === 0) {\n                this.executionMetadata.delete(kernelId);\n            }\n        }\n        // Remove from ongoing executions\n        if (this.ongoingExecutions.has(kernelId)) {\n            const executions = this.ongoingExecutions.get(kernelId);\n            executions.delete(executionId);\n            // Clean up empty sets\n            if (executions.size === 0) {\n                this.ongoingExecutions.delete(kernelId);\n                // Update activity timestamp for completed execution\n                this.updateKernelActivity(kernelId);\n            }\n        }\n    }\n    /**\n     * Check if a kernel has any ongoing executions\n     * @param kernelId Kernel ID\n     * @returns True if the kernel has ongoing executions\n     * @private\n     */\n    hasOngoingExecutions(kernelId) {\n        return this.ongoingExecutions.has(kernelId) &&\n            this.ongoingExecutions.get(kernelId).size > 0;\n    }\n    /**\n     * Get the count of ongoing executions for a kernel\n     * @param id Kernel ID\n     * @returns Number of ongoing executions\n     */\n    getOngoingExecutionCount(id) {\n        if (!this.ongoingExecutions.has(id)) {\n            return 0;\n        }\n        return this.ongoingExecutions.get(id).size;\n    }\n    /**\n     * Set up an inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @param timeout Timeout in milliseconds\n     * @private\n     */\n    setupInactivityTimeout(id, timeout) {\n        // Don't set up a timer if timeout is 0 or negative\n        if (timeout <= 0) {\n            return;\n        }\n        // Always clear any existing timer first\n        this.clearInactivityTimeout(id);\n        // Calculate remaining time based on last activity\n        const lastActivity = this.lastActivityTime.get(id) || Date.now();\n        const elapsed = Date.now() - lastActivity;\n        const remainingTime = Math.max(0, timeout - elapsed);\n        // If no time remaining, destroy immediately\n        if (remainingTime === 0) {\n            // Check if the kernel has ongoing executions before shutting down\n            if (this.hasOngoingExecutions(id)) {\n                // Reset the timer to check again later\n                this.setupInactivityTimeout(id, timeout);\n                return;\n            }\n            // Destroy immediately\n            this.destroyKernel(id).catch(error => {\n                console.error(`Error destroying inactive kernel ${id}:`, error);\n            });\n            return;\n        }\n        // Create a timer to destroy the kernel after the remaining timeout\n        const timer = setTimeout(() => {\n            // Check if the kernel has ongoing executions before shutting down\n            if (this.hasOngoingExecutions(id)) {\n                // Reset the timer to check again later\n                this.setupInactivityTimeout(id, timeout);\n                return;\n            }\n            this.destroyKernel(id).catch(error => {\n                console.error(`Error destroying inactive kernel ${id}:`, error);\n            });\n        }, remainingTime);\n        // Store the timer ID\n        this.inactivityTimers.set(id, timer);\n    }\n    /**\n     * Clear any existing inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @private\n     */\n    clearInactivityTimeout(id) {\n        if (this.inactivityTimers.has(id)) {\n            const timerId = this.inactivityTimers.get(id);\n            clearTimeout(timerId);\n            this.inactivityTimers.delete(id);\n        }\n    }\n    /**\n     * Update activity timestamp for a kernel and reset inactivity timer if present\n     * @param id Kernel ID\n     * @private\n     */\n    updateKernelActivity(id) {\n        // Update the last activity time\n        this.lastActivityTime.set(id, Date.now());\n        // Get the kernel options\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return;\n        const timeout = instance.options.inactivityTimeout;\n        // Reset the inactivity timer if timeout is enabled (greater than 0)\n        if (timeout && timeout > 0) {\n            this.setupInactivityTimeout(id, timeout);\n        }\n    }\n    /**\n     * Get the last activity time for a kernel\n     * @param id Kernel ID\n     * @returns Last activity time in milliseconds since epoch, or undefined if not found\n     */\n    getLastActivityTime(id) {\n        return this.lastActivityTime.get(id);\n    }\n    /**\n     * Get the inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @returns Inactivity timeout in milliseconds, or undefined if not set\n     */\n    getInactivityTimeout(id) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return undefined;\n        return instance.options.inactivityTimeout;\n    }\n    /**\n     * Set or update the inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @param timeout Timeout in milliseconds, or 0 to disable\n     * @returns True if the timeout was set, false if the kernel was not found\n     */\n    setInactivityTimeout(id, timeout) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return false;\n        // Update the timeout in the options\n        instance.options.inactivityTimeout = timeout;\n        // Clear any existing timer\n        this.clearInactivityTimeout(id);\n        // If timeout is greater than 0, set up a new timer\n        if (timeout > 0) {\n            this.setupInactivityTimeout(id, timeout);\n        }\n        return true;\n    }\n    /**\n     * Get time until auto-shutdown for a kernel\n     * @param id Kernel ID\n     * @returns Time in milliseconds until auto-shutdown, or undefined if no timeout is set\n     */\n    getTimeUntilShutdown(id) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return undefined;\n        const timeout = instance.options.inactivityTimeout;\n        if (!timeout || timeout <= 0)\n            return undefined;\n        const lastActivity = this.lastActivityTime.get(id);\n        if (!lastActivity)\n            return undefined;\n        const elapsedTime = Date.now() - lastActivity;\n        const remainingTime = timeout - elapsedTime;\n        return Math.max(0, remainingTime);\n    }\n    /**\n     * Get the map of inactivity timers (for debugging/testing only)\n     * @returns Object with kernel IDs as keys and timer IDs as values\n     */\n    getInactivityTimers() {\n        // Convert Map to Object for easier inspection\n        const timers = {};\n        this.inactivityTimers.forEach((value, key) => {\n            timers[key] = value;\n        });\n        return timers;\n    }\n    /**\n     * Set up a handler for stalled executions\n     * @param id Kernel ID\n     * @private\n     */\n    setupStalledExecutionHandler(id) {\n        // Listen for stalled execution events\n        super.on(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTION_STALLED, (event) => {\n            if (event.kernelId === id) {\n                console.warn(`Handling stalled execution ${event.executionId} on kernel ${id} (running longer than ${event.maxExecutionTime}ms)`);\n                // Emit an event for clients to handle\n                const instance = this.kernels.get(id);\n                if (instance) {\n                    super.emit(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTE_ERROR, {\n                        kernelId: id,\n                        data: {\n                            ename: \"ExecutionStalledError\",\n                            evalue: `Execution stalled or potentially deadlocked (running > ${event.maxExecutionTime}ms)`,\n                            traceback: [\"Execution may be stuck in an infinite loop or deadlocked.\"]\n                        }\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Force terminate a potentially stuck kernel\n     * @param id Kernel ID\n     * @param reason Optional reason for termination\n     * @returns Promise resolving to true if the kernel was terminated\n     */\n    async forceTerminateKernel(id, reason = \"Force terminated due to stalled execution\") {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return false;\n        }\n        try {\n            // Log the forced termination\n            console.warn(`Force terminating kernel ${id}: ${reason}`);\n            // Emit an error event to notify clients\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: id,\n                data: {\n                    ename: \"KernelForcedTermination\",\n                    evalue: reason,\n                    traceback: [\"Kernel was forcefully terminated by the system.\"]\n                }\n            });\n            // Destroy the kernel\n            await this.destroyKernel(id);\n            return true;\n        }\n        catch (error) {\n            console.error(`Error during forced termination of kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Get information about ongoing executions for a kernel\n     * @param id Kernel ID\n     * @returns Information about ongoing executions with accurate timing\n     */\n    getExecutionInfo(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return { count: 0, isStuck: false, executionIds: [], executions: [] };\n        }\n        // Handle partially initialized kernels where options may not be fully set\n        if (!instance.options) {\n            return { count: 0, isStuck: false, executionIds: [], executions: [] };\n        }\n        const executionIds = this.ongoingExecutions.get(id)\n            ? Array.from(this.ongoingExecutions.get(id))\n            : [];\n        const count = executionIds.length;\n        const currentTime = Date.now();\n        const maxExecutionTime = instance.options.maxExecutionTime;\n        // Build detailed execution information\n        const executions = [];\n        let longestRunningTime = undefined;\n        let anyStuck = false;\n        // Get execution start times and metadata\n        const startTimes = this.executionStartTimes.get(id);\n        const metadata = this.executionMetadata.get(id);\n        for (const executionId of executionIds) {\n            const startTime = startTimes?.get(executionId);\n            const execMetadata = metadata?.get(executionId);\n            if (startTime !== undefined) {\n                const runtime = currentTime - startTime;\n                const isStuck = maxExecutionTime !== undefined && runtime > maxExecutionTime;\n                executions.push({\n                    id: executionId,\n                    startTime,\n                    runtime,\n                    code: execMetadata?.code,\n                    isStuck\n                });\n                // Track longest running time\n                if (longestRunningTime === undefined || runtime > longestRunningTime) {\n                    longestRunningTime = runtime;\n                }\n                // Track if any execution is stuck\n                if (isStuck) {\n                    anyStuck = true;\n                }\n            }\n            else {\n                // Fallback for executions without start time tracking\n                console.warn(`No start time found for execution ${executionId} on kernel ${id}`);\n                executions.push({\n                    id: executionId,\n                    startTime: 0,\n                    runtime: 0,\n                    code: execMetadata?.code,\n                    isStuck: false\n                });\n            }\n        }\n        // Sort executions by start time (oldest first)\n        executions.sort((a, b) => a.startTime - b.startTime);\n        return {\n            count,\n            isStuck: anyStuck,\n            executionIds,\n            longestRunningTime,\n            executions\n        };\n    }\n    /**\n     * Execute Python code in a kernel\n     * Overrides the kernel's execute method to track executions\n     * @param kernelId ID of the kernel to use\n     * @param code Python code to execute\n     * @param parent Optional parent message header\n     * @returns Promise resolving to execution result\n     */\n    async execute(kernelId, code, parent = {}) {\n        const instance = this.getKernel(kernelId);\n        if (!instance) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Update kernel activity\n        this.updateKernelActivity(kernelId);\n        // Track this execution with the code for better monitoring\n        const executionId = this.trackExecution(kernelId, code);\n        try {\n            // Execute the code\n            const result = await instance.kernel.execute(code, parent);\n            // Update activity after execution completes\n            this.updateKernelActivity(kernelId);\n            // Complete execution tracking\n            this.completeExecution(kernelId, executionId);\n            return result;\n        }\n        catch (error) {\n            // Update activity even if there's an error\n            this.updateKernelActivity(kernelId);\n            // Complete execution tracking even on error\n            this.completeExecution(kernelId, executionId);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Check if a kernel type is allowed\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns True if the kernel type is allowed\n     * @private\n     */\n    isKernelTypeAllowed(mode, language) {\n        return this.allowedKernelTypes.some(type => type.mode === mode && type.language === language);\n    }\n    /**\n     * Get the list of allowed kernel types\n     * @returns Array of allowed kernel type configurations\n     */\n    getAllowedKernelTypes() {\n        return [...this.allowedKernelTypes]; // Return a copy to prevent modification\n    }\n    /**\n     * Ping a kernel to reset its activity timer and extend the deadline\n     * @param id Kernel ID\n     * @returns True if the kernel was pinged successfully, false if not found\n     */\n    pingKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return false;\n        }\n        // Update kernel activity (this will reset the inactivity timer)\n        this.updateKernelActivity(id);\n        return true;\n    }\n    /**\n     * Restart a kernel by destroying it and creating a new one with the same ID and configuration\n     * @param id Kernel ID\n     * @returns Promise resolving to true if the kernel was restarted successfully, false if not found\n     */\n    async restartKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            console.warn(`Cannot restart kernel ${id}: kernel not found`);\n            return false;\n        }\n        try {\n            // Store the current configuration\n            const currentConfig = {\n                mode: instance.mode,\n                language: instance.language,\n                options: { ...instance.options }\n            };\n            // Extract namespace from ID if present\n            let namespace;\n            let baseId;\n            if (id.includes(':')) {\n                const parts = id.split(':');\n                namespace = parts[0];\n                baseId = parts[1];\n            }\n            else {\n                baseId = id;\n            }\n            // Destroy the existing kernel\n            await this.destroyKernel(id);\n            // Create a new kernel with the same configuration\n            const restartOptions = {\n                id: baseId,\n                mode: currentConfig.mode,\n                lang: currentConfig.language,\n                namespace,\n                deno: currentConfig.options.deno,\n                filesystem: currentConfig.options.filesystem,\n                inactivityTimeout: currentConfig.options.inactivityTimeout,\n                maxExecutionTime: currentConfig.options.maxExecutionTime\n            };\n            // Create the new kernel\n            const newKernelId = await this.createKernel(restartOptions);\n            // Verify the new kernel has the same ID\n            if (newKernelId !== id) {\n                console.error(`Kernel restart failed: expected ID ${id}, got ${newKernelId}`);\n                return false;\n            }\n            return true;\n        }\n        catch (error) {\n            console.error(`Error restarting kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Interrupt a running kernel execution\n     * @param id Kernel ID\n     * @returns Promise resolving to true if the interrupt was successful, false if not found or failed\n     */\n    async interruptKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            console.warn(`Cannot interrupt kernel ${id}: kernel not found`);\n            return false;\n        }\n        try {\n            if (instance.mode === KernelMode.WORKER && instance.worker) {\n                // For worker kernels, use SharedArrayBuffer interrupt method\n                return await this.interruptWorkerKernel(id, instance);\n            }\n            else {\n                // For main thread kernels, try to interrupt (will throw error if not supported)\n                return await this.interruptMainThreadKernel(id, instance);\n            }\n        }\n        catch (error) {\n            console.error(`Error interrupting kernel ${id}:`, error instanceof Error ? error.message : String(error));\n            return false;\n        }\n    }\n    /**\n     * Interrupt a main thread kernel\n     * @param id Kernel ID\n     * @param instance Kernel instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptMainThreadKernel(id, instance) {\n        // Main thread kernels don't support proper interruption like worker kernels do\n        // Even if they have an interrupt method, it's limited and unreliable\n        throw new Error(`Main thread kernel ${id} does not support reliable interruption. Use worker kernels for interruptible execution.`);\n    }\n    /**\n     * Interrupt a worker kernel using SharedArrayBuffer according to Pyodide documentation\n     * @param id Kernel ID\n     * @param instance Kernel instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptWorkerKernel(id, instance) {\n        try {\n            const worker = instance.worker;\n            if (!worker) {\n                console.error(`Worker not found for kernel ${id}`);\n                return false;\n            }\n            // Check if we already have an interrupt buffer for this kernel\n            let interruptBuffer = this.interruptBuffers.get(id);\n            if (!interruptBuffer) {\n                // Create a new SharedArrayBuffer for interrupt control\n                try {\n                    // Try to create SharedArrayBuffer (requires specific security headers)\n                    const sharedBuffer = new SharedArrayBuffer(1);\n                    interruptBuffer = new Uint8Array(sharedBuffer);\n                    // Initialize buffer to 0 (no interrupt signal)\n                    interruptBuffer[0] = 0;\n                    // Store the buffer for future use\n                    this.interruptBuffers.set(id, interruptBuffer);\n                    // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n                    worker.postMessage({\n                        type: \"SET_INTERRUPT_BUFFER\",\n                        buffer: interruptBuffer\n                    });\n                    // Wait for the worker to confirm buffer setup\n                    await new Promise((resolve, reject) => {\n                        const timeout = setTimeout(() => {\n                            reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n                        }, 2000);\n                        const handler = (event) => {\n                            if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                                worker.removeEventListener(\"message\", handler);\n                                clearTimeout(timeout);\n                                resolve();\n                            }\n                        };\n                        worker.addEventListener(\"message\", handler);\n                    });\n                    console.log(`Interrupt buffer set up for kernel ${id}`);\n                }\n                catch (error) {\n                    console.warn(`Failed to create SharedArrayBuffer for kernel ${id}, falling back to message-based interrupt:`, error);\n                    // Fallback: use message-based interrupt\n                    return await this.interruptWorkerKernelFallback(id, worker);\n                }\n            }\n            // According to Pyodide docs: Set interrupt signal (2 = SIGINT)\n            console.log(`Setting interrupt signal for kernel ${id}...`);\n            interruptBuffer[0] = 2;\n            // Wait for Pyodide to process the interrupt\n            // Pyodide will reset the buffer to 0 when it processes the interrupt\n            let attempts = 0;\n            const maxAttempts = 50; // Check for up to 5 seconds (50 * 100ms)\n            while (attempts < maxAttempts && interruptBuffer[0] !== 0) {\n                await new Promise(resolve => setTimeout(resolve, 100));\n                attempts++;\n            }\n            if (interruptBuffer[0] === 0) {\n                console.log(`Interrupt processed successfully for kernel ${id} after ${attempts * 100}ms`);\n                return true;\n            }\n            else {\n                console.warn(`Interrupt signal not processed for kernel ${id} after ${maxAttempts * 100}ms`);\n                // Still return true as we set the signal - the interrupt may be processed later\n                return true;\n            }\n        }\n        catch (error) {\n            console.error(`Error interrupting worker kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Fallback interrupt method for worker kernels when SharedArrayBuffer is not available\n     * @param id Kernel ID\n     * @param worker Worker instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptWorkerKernelFallback(id, worker) {\n        return new Promise((resolve) => {\n            // Set up a listener for the interrupt response\n            const responseHandler = (event) => {\n                if (event.data?.type === \"INTERRUPT_TRIGGERED\") {\n                    worker.removeEventListener(\"message\", responseHandler);\n                    const success = event.data.data?.success || false;\n                    resolve(success);\n                }\n            };\n            // Listen for the response\n            worker.addEventListener(\"message\", responseHandler);\n            // Send the interrupt message\n            worker.postMessage({\n                type: \"INTERRUPT_KERNEL\"\n            });\n            // Set a timeout in case we don't get a response\n            setTimeout(() => {\n                worker.removeEventListener(\"message\", responseHandler);\n                console.warn(`Timeout waiting for interrupt response from kernel ${id}`);\n                resolve(false);\n            }, 5000); // 5 second timeout\n        });\n    }\n    /**\n     * Handle a stuck execution with configurable strategies\n     * @param kernelId Kernel ID\n     * @param executionId Execution ID that's stuck\n     * @param actualRuntime How long the execution has been running\n     * @param code The code that was being executed\n     * @private\n     */\n    async handleStuckExecution(kernelId, executionId, actualRuntime, code) {\n        const instance = this.kernels.get(kernelId);\n        if (!instance) {\n            return;\n        }\n        console.warn(`Handling stuck execution ${executionId} on kernel ${kernelId} (runtime: ${actualRuntime}ms)`);\n        // Strategy 1: Try to interrupt the kernel first\n        const interruptSuccess = await this.interruptKernel(kernelId);\n        if (interruptSuccess) {\n            console.log(`Successfully interrupted kernel ${kernelId}`);\n            // Emit an execution error to notify clients\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: kernelId,\n                data: {\n                    ename: \"ExecutionInterrupted\",\n                    evalue: `Execution automatically interrupted after ${actualRuntime}ms (exceeded maxExecutionTime)`,\n                    traceback: [\n                        `Execution was automatically interrupted due to timeout.`,\n                        `Runtime: ${actualRuntime}ms`,\n                        `Max allowed: ${instance.options.maxExecutionTime}ms`,\n                        code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n                    ]\n                }\n            });\n            return;\n        }\n        // Strategy 2: If interrupt failed, try restarting the kernel\n        console.warn(`Interrupt failed for kernel ${kernelId}, attempting restart...`);\n        const restartSuccess = await this.restartKernel(kernelId);\n        if (restartSuccess) {\n            console.log(`Successfully restarted kernel ${kernelId}`);\n            // Emit a restart notification\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: kernelId,\n                data: {\n                    ename: \"KernelRestarted\",\n                    evalue: `Kernel automatically restarted due to stuck execution (runtime: ${actualRuntime}ms)`,\n                    traceback: [\n                        `Kernel was automatically restarted due to stuck execution.`,\n                        `Runtime: ${actualRuntime}ms`,\n                        `Max allowed: ${instance.options.maxExecutionTime}ms`,\n                        `Interrupt attempt failed, kernel was restarted instead.`,\n                        code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n                    ]\n                }\n            });\n            return;\n        }\n        // Strategy 3: If restart failed, force terminate the kernel\n        console.error(`Restart failed for kernel ${kernelId}, force terminating...`);\n        const terminateSuccess = await this.forceTerminateKernel(kernelId, `Stuck execution could not be interrupted or restarted (runtime: ${actualRuntime}ms)`);\n        if (terminateSuccess) {\n            console.log(`Successfully terminated kernel ${kernelId}`);\n        }\n        else {\n            console.error(`Failed to terminate kernel ${kernelId} - manual intervention may be required`);\n            // Emit a critical error\n            super.emit('kernel_unrecoverable', {\n                kernelId: kernelId,\n                executionId: executionId,\n                actualRuntime: actualRuntime,\n                code: code,\n                message: 'Kernel is stuck and could not be recovered through interrupt, restart, or termination'\n            });\n        }\n    }\n    /**\n     * Get detailed information about stuck executions across all kernels\n     * @returns Array of stuck execution details\n     */\n    getStuckExecutions() {\n        const stuckExecutions = [];\n        const currentTime = Date.now();\n        for (const [kernelId, instance] of this.kernels.entries()) {\n            // Skip pool kernels\n            if (kernelId.startsWith(\"pool-\"))\n                continue;\n            // Skip kernels without maxExecutionTime configured\n            if (!instance.options?.maxExecutionTime || instance.options.maxExecutionTime <= 0) {\n                continue;\n            }\n            const maxExecutionTime = instance.options.maxExecutionTime;\n            const startTimes = this.executionStartTimes.get(kernelId);\n            const metadata = this.executionMetadata.get(kernelId);\n            const ongoingExecs = this.ongoingExecutions.get(kernelId);\n            if (!ongoingExecs || ongoingExecs.size === 0) {\n                continue;\n            }\n            for (const executionId of ongoingExecs) {\n                const startTime = startTimes?.get(executionId);\n                if (startTime === undefined)\n                    continue;\n                const runtime = currentTime - startTime;\n                // Check if this execution is stuck\n                if (runtime > maxExecutionTime) {\n                    const execMetadata = metadata?.get(executionId);\n                    stuckExecutions.push({\n                        kernelId,\n                        executionId,\n                        startTime,\n                        runtime,\n                        maxAllowed: maxExecutionTime,\n                        code: execMetadata?.code,\n                        kernelMode: instance.mode,\n                        kernelLanguage: instance.language\n                    });\n                }\n            }\n        }\n        // Sort by runtime (longest running first)\n        stuckExecutions.sort((a, b) => b.runtime - a.runtime);\n        return stuckExecutions;\n    }\n    /**\n     * Force interrupt all stuck executions across all kernels\n     * @returns Promise resolving to array of intervention results\n     */\n    async handleAllStuckExecutions() {\n        const stuckExecutions = this.getStuckExecutions();\n        const results = [];\n        console.log(`Found ${stuckExecutions.length} stuck executions to handle`);\n        // Group by kernel to avoid multiple interventions on the same kernel\n        const kernelGroups = new Map();\n        for (const exec of stuckExecutions) {\n            if (!kernelGroups.has(exec.kernelId)) {\n                kernelGroups.set(exec.kernelId, []);\n            }\n            kernelGroups.get(exec.kernelId).push(exec);\n        }\n        // Handle each kernel's stuck executions\n        for (const [kernelId, executions] of kernelGroups) {\n            try {\n                // Pick the longest running execution as the primary one\n                const primaryExec = executions[0]; // Already sorted by runtime desc\n                console.log(`Handling stuck kernel ${kernelId} with ${executions.length} stuck executions (primary: ${primaryExec.runtime}ms)`);\n                // Use the automated handling system\n                await this.handleStuckExecution(kernelId, primaryExec.executionId, primaryExec.runtime, primaryExec.code);\n                // Mark all executions for this kernel as handled\n                for (const exec of executions) {\n                    results.push({\n                        kernelId: exec.kernelId,\n                        executionId: exec.executionId,\n                        action: 'interrupted', // We don't know the exact action, but it was handled\n                        success: true\n                    });\n                }\n            }\n            catch (error) {\n                console.error(`Error handling stuck executions for kernel ${kernelId}:`, error);\n                // Mark all executions for this kernel as failed\n                for (const exec of executions) {\n                    results.push({\n                        kernelId: exec.kernelId,\n                        executionId: exec.executionId,\n                        action: 'failed',\n                        success: false,\n                        error: error instanceof Error ? error.message : String(error)\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Set up interrupt buffer for a worker kernel during creation\n     * @param id Kernel ID\n     * @param worker Worker instance\n     * @private\n     */\n    async setupWorkerInterruptBuffer(id, worker) {\n        try {\n            // Python kernels support interrupt buffers\n            // For Python kernels, create actual SharedArrayBuffer\n            const sharedBuffer = new SharedArrayBuffer(1);\n            const interruptBuffer = new Uint8Array(sharedBuffer);\n            // Initialize buffer to 0 (no interrupt signal)\n            interruptBuffer[0] = 0;\n            // Store the buffer for future use\n            this.interruptBuffers.set(id, interruptBuffer);\n            // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n            worker.postMessage({\n                type: \"SET_INTERRUPT_BUFFER\",\n                buffer: interruptBuffer\n            });\n            // Wait for the worker to confirm buffer setup\n            await new Promise((resolve, reject) => {\n                const timeout = setTimeout(() => {\n                    reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n                }, 5000);\n                const handler = (event) => {\n                    if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                        worker.removeEventListener(\"message\", handler);\n                        clearTimeout(timeout);\n                        resolve();\n                    }\n                };\n                worker.addEventListener(\"message\", handler);\n            });\n        }\n        catch (error) {\n            console.warn(`Failed to set up interrupt buffer for kernel ${id}:`, error);\n            // Don't throw - kernel can still work without interrupt buffer\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUN2RSxNQUFNLENBQUMsV0FBVyxDQUFDO2dCQUNqQixJQUFJLEVBQUUsc0JBQXNCO2dCQUM1QixNQUFNLEVBQUUsZUFBZTthQUN4QixDQUFDLENBQUM7WUFFSCw4Q0FBOEM7WUFDOUMsTUFBTSxJQUFJLE9BQU8sQ0FBTyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtnQkFDMUMsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRTtvQkFDOUIsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUMsQ0FBQztnQkFDbEUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUVULE1BQU0sT0FBTyxHQUFHLENBQUMsS0FBbUIsRUFBRSxFQUFFO29CQUN0QyxJQUFJLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxLQUFLLHNCQUFzQixFQUFFLENBQUM7d0JBQ2hELE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7d0JBQy9DLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFDdEIsT0FBTyxFQUFFLENBQUM7b0JBQ1osQ0FBQztnQkFDSCxDQUFDLENBQUM7Z0JBRUYsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUM5QyxDQUFDLENBQUMsQ0FBQztRQUVMLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQyxnREFBZ0QsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDM0UsK0RBQStEO1FBQ2pFLENBQUM7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9XZWJQeXRob25LZXJuZWwvLi9zcmMvbWFuYWdlci50cz85MzZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEtlcm5lbCBNYW5hZ2VyIGZvciBEZW5vIEFwcCBFbmdpbmVcbi8vIFRoaXMgZmlsZSBtYW5hZ2VzIGtlcm5lbCBpbnN0YW5jZXMgaW4gZWl0aGVyIG1haW4gdGhyZWFkIG9yIHdvcmtlciBtb2RlXG5cbmltcG9ydCAqIGFzIENvbWxpbmsgZnJvbSBcImNvbWxpbmtcIjtcbi8vIEB0cy1pZ25vcmUgSW1wb3J0aW5nIGZyb20gbnBtXG4vLyBVc2UgYSBicm93c2VyLWNvbXBhdGlibGUgRXZlbnRFbWl0dGVyXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGV2ZW50czogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbltdIH0gPSB7fTtcblxuICBvbihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pIHtcbiAgICB0aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGVtaXQoZXZlbnROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSByZXR1cm47XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKC4uLmFyZ3MpKTtcbiAgfVxuXG4gIHNldE1heExpc3RlbmVycyhuOiBudW1iZXIpIHtcbiAgICAvLyBOby1vcCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gIH1cbn1cbmltcG9ydCB7IEtlcm5lbEV2ZW50cywgSUtlcm5lbCwgSUtlcm5lbE9wdGlvbnMsIElGaWxlc3lzdGVtTW91bnRPcHRpb25zIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IEtlcm5lbCB9IGZyb20gXCIuL2luZGV4XCI7XG5cbi8vIFJlLWV4cG9ydCBLZXJuZWxFdmVudHMgZm9yIHRlc3QgdXNhZ2VcbmV4cG9ydCB7IEtlcm5lbEV2ZW50cyB9O1xuXG4vLyBFeGVjdXRpb24gbW9kZSBlbnVtXG5leHBvcnQgZW51bSBLZXJuZWxNb2RlIHtcbiAgTUFJTl9USFJFQUQgPSBcIm1haW5fdGhyZWFkXCIsXG4gIFdPUktFUiA9IFwid29ya2VyXCJcbn1cblxuLy8gS2VybmVsIGxhbmd1YWdlIGVudW1cbmV4cG9ydCBlbnVtIEtlcm5lbExhbmd1YWdlIHtcbiAgUFlUSE9OID0gXCJweXRob25cIlxufVxuXG4vLyBFeHRlbmRlZCBXb3JrZXJPcHRpb25zIGludGVyZmFjZSB0byBpbmNsdWRlIERlbm8gcGVybWlzc2lvbnNcbmludGVyZmFjZSBXb3JrZXJPcHRpb25zIHtcbiAgdHlwZT86IFwiY2xhc3NpY1wiIHwgXCJtb2R1bGVcIjtcbiAgbmFtZT86IHN0cmluZztcbiAgZGVubz86IHtcbiAgICBwZXJtaXNzaW9ucz86IElEZW5vUGVybWlzc2lvbnM7XG4gIH07XG59XG5cbi8vIEludGVyZmFjZSBmb3Iga2VybmVsIHBvb2wgY29uZmlndXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsUG9vbENvbmZpZyB7XG4gIGVuYWJsZWQ6IGJvb2xlYW47XG4gIHBvb2xTaXplOiBudW1iZXI7IC8vIE51bWJlciBvZiBrZXJuZWxzIHRvIGtlZXAgcmVhZHkgcGVyIGNvbmZpZ3VyYXRpb25cbiAgYXV0b1JlZmlsbDogYm9vbGVhbjsgLy8gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IHJlZmlsbCB0aGUgcG9vbCB3aGVuIGtlcm5lbHMgYXJlIHRha2VuXG4gIHByZWxvYWRDb25maWdzOiBBcnJheTx7XG4gICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gIH0+OyAvLyBDb25maWd1cmF0aW9ucyB0byBwcmVsb2FkIGluIHRoZSBwb29sXG59XG5cbi8vIEludGVyZmFjZSBmb3Iga2VybmVsIG1hbmFnZXIgb3B0aW9uc1xuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsTWFuYWdlck9wdGlvbnMge1xuICBwb29sPzogSUtlcm5lbFBvb2xDb25maWc7XG4gIGFsbG93ZWRLZXJuZWxUeXBlcz86IEFycmF5PHtcbiAgICBtb2RlOiBLZXJuZWxNb2RlO1xuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgfT47IC8vIFJlc3RyaWN0IHdoaWNoIGtlcm5lbCB0eXBlcyBjYW4gYmUgY3JlYXRlZFxufVxuXG4vLyBJbnRlcmZhY2UgZm9yIGtlcm5lbCBpbnN0YW5jZVxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsSW5zdGFuY2Uge1xuICBpZDogc3RyaW5nO1xuICBrZXJuZWw6IElLZXJuZWw7XG4gIG1vZGU6IEtlcm5lbE1vZGU7XG4gIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgd29ya2VyPzogV29ya2VyO1xuICBjcmVhdGVkOiBEYXRlO1xuICBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnM7XG4gIGlzRnJvbVBvb2w/OiBib29sZWFuOyAvLyBUcmFjayBpZiB0aGlzIGtlcm5lbCBjYW1lIGZyb20gdGhlIHBvb2xcbiAgZGVzdHJveSgpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG4vLyBJbnRlcmZhY2UgZm9yIERlbm8gd29ya2VyIHBlcm1pc3Npb25zXG5leHBvcnQgaW50ZXJmYWNlIElEZW5vUGVybWlzc2lvbnMge1xuICByZWFkPzogKHN0cmluZyB8IFVSTClbXTtcbiAgd3JpdGU/OiAoc3RyaW5nIHwgVVJMKVtdO1xuICBuZXQ/OiBzdHJpbmdbXTtcbiAgZW52Pzogc3RyaW5nW107XG4gIHJ1bj86IHN0cmluZ1tdO1xuICBmZmk/OiBzdHJpbmdbXTtcbiAgaHJ0aW1lPzogYm9vbGVhbjtcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBrZXJuZWwgY3JlYXRpb24gb3B0aW9uc1xuZXhwb3J0IGludGVyZmFjZSBJTWFuYWdlcktlcm5lbE9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbiAgbW9kZT86IEtlcm5lbE1vZGU7XG4gIGxhbmc/OiBLZXJuZWxMYW5ndWFnZTtcbiAgbmFtZXNwYWNlPzogc3RyaW5nO1xuICBkZW5vPzoge1xuICAgIHBlcm1pc3Npb25zPzogSURlbm9QZXJtaXNzaW9ucztcbiAgfTtcbiAgZmlsZXN5c3RlbT86IElGaWxlc3lzdGVtTW91bnRPcHRpb25zO1xuICBlbnY/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+OyAvLyBFbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gc2V0IGluIHRoZSBrZXJuZWxcbiAgaW5hY3Rpdml0eVRpbWVvdXQ/OiBudW1iZXI7IC8vIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIGFuIGluYWN0aXZlIGtlcm5lbCB3aWxsIGJlIHNodXQgZG93blxuICBtYXhFeGVjdXRpb25UaW1lPzogbnVtYmVyOyAvLyBNYXhpbXVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGEgc2luZ2xlIGV4ZWN1dGlvbiBjYW4gcnVuIGJlZm9yZSBjb25zaWRlcmVkIHN0dWNrL2RlYWRcbn1cblxuLy8gSGVscGVyIHR5cGUgZm9yIGxpc3RlbmVyIG1hbmFnZW1lbnRcbnR5cGUgTGlzdGVuZXJXcmFwcGVyID0ge1xuICBvcmlnaW5hbDogKGRhdGE6IGFueSkgPT4gdm9pZDtcbiAgd3JhcHBlZDogKGV2ZW50OiB7IGtlcm5lbElkOiBzdHJpbmcsIGRhdGE6IGFueSB9KSA9PiB2b2lkO1xufTtcblxuLyoqXG4gKiBLZXJuZWxNYW5hZ2VyIGNsYXNzIG1hbmFnZXMgbXVsdGlwbGUga2VybmVsIGluc3RhbmNlcyBcbiAqIGluIGVpdGhlciBtYWluIHRocmVhZCBvciB3b3JrZXIgbW9kZVxuICovXG5leHBvcnQgY2xhc3MgS2VybmVsTWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUga2VybmVsczogTWFwPHN0cmluZywgSUtlcm5lbEluc3RhbmNlPiA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgbGlzdGVuZXJzIGZvciBlYWNoIGtlcm5lbCB0byBlbmFibGUgaW5kaXZpZHVhbCByZW1vdmFsXG4gIHByaXZhdGUgbGlzdGVuZXJXcmFwcGVyczogTWFwPHN0cmluZywgTWFwPHN0cmluZywgTWFwPEZ1bmN0aW9uLCBMaXN0ZW5lcldyYXBwZXI+Pj4gPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGxhc3QgYWN0aXZpdHkgdGltZSBmb3IgZWFjaCBrZXJuZWxcbiAgcHJpdmF0ZSBsYXN0QWN0aXZpdHlUaW1lOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICAvLyBTdG9yZSBpbmFjdGl2aXR5IHRpbWVycyBmb3IgZWFjaCBrZXJuZWxcbiAgcHJpdmF0ZSBpbmFjdGl2aXR5VGltZXJzOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBvbmdvaW5nIGV4ZWN1dGlvbnMgZm9yIGVhY2gga2VybmVsXG4gIHByaXZhdGUgb25nb2luZ0V4ZWN1dGlvbnM6IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PiA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgZXhlY3V0aW9uIHRpbWVvdXRzIGZvciBkZXRlY3Rpbmcgc3R1Y2svZGVhZCBrZXJuZWxzXG4gIHByaXZhdGUgZXhlY3V0aW9uVGltZW91dHM6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIGFueT4+ID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBleGVjdXRpb24gc3RhcnQgdGltZXMgZm9yIGFjY3VyYXRlIGR1cmF0aW9uIGNhbGN1bGF0aW9uXG4gIHByaXZhdGUgZXhlY3V0aW9uU3RhcnRUaW1lczogTWFwPHN0cmluZywgTWFwPHN0cmluZywgbnVtYmVyPj4gPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGV4ZWN1dGlvbiBtZXRhZGF0YSBmb3IgYmV0dGVyIG1vbml0b3JpbmdcbiAgcHJpdmF0ZSBleGVjdXRpb25NZXRhZGF0YTogTWFwPHN0cmluZywgTWFwPHN0cmluZywgeyBzdGFydFRpbWU6IG51bWJlcjsgY29kZT86IHN0cmluZzsgdGltZW91dElkPzogYW55IH0+PiA9IG5ldyBNYXAoKTtcbiAgXG4gIC8vIFRyYWNrIEFib3J0Q29udHJvbGxlcnMgZm9yIGVhY2gga2VybmVsJ3Mgb25nb2luZyBvcGVyYXRpb25zXG4gIHByaXZhdGUgYWJvcnRDb250cm9sbGVyczogTWFwPHN0cmluZywgTWFwPHN0cmluZywgQWJvcnRDb250cm9sbGVyPj4gPSBuZXcgTWFwKCk7XG4gIFxuICAvLyBQb29sIG1hbmFnZW1lbnQgLSBub3cgdXNpbmcgcHJvbWlzZXMgZm9yIGltbWVkaWF0ZSByZXNwb25zZVxuICBwcml2YXRlIHBvb2w6IE1hcDxzdHJpbmcsIFByb21pc2U8SUtlcm5lbEluc3RhbmNlPltdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBwb29sQ29uZmlnOiBJS2VybmVsUG9vbENvbmZpZztcbiAgcHJpdmF0ZSBpc1ByZWxvYWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgLy8gVHJhY2sgd2hpY2ggcG9vbCBrZXlzIGFyZSBjdXJyZW50bHkgYmVpbmcgcHJlZmlsbGVkIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICBwcml2YXRlIHByZWZpbGxpbmdJblByb2dyZXNzOiBNYXA8c3RyaW5nLCBib29sZWFuPiA9IG5ldyBNYXAoKTtcbiAgXG4gIC8vIEFsbG93ZWQga2VybmVsIHR5cGVzIGNvbmZpZ3VyYXRpb25cbiAgcHJpdmF0ZSBhbGxvd2VkS2VybmVsVHlwZXM6IEFycmF5PHtcbiAgICBtb2RlOiBLZXJuZWxNb2RlO1xuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgfT47XG4gIFxuICAvLyBJbnRlcnJ1cHQgYnVmZmVycyBmb3Igd29ya2VyIGtlcm5lbHMgKHVzaW5nIFNoYXJlZEFycmF5QnVmZmVyKVxuICBwcml2YXRlIGludGVycnVwdEJ1ZmZlcnM6IE1hcDxzdHJpbmcsIFVpbnQ4QXJyYXk+ID0gbmV3IE1hcCgpO1xuICBcbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBhbiBlcnJvciBpcyBhIEtleWJvYXJkSW50ZXJydXB0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGlzS2V5Ym9hcmRJbnRlcnJ1cHQoZXJyb3I6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBlcnJvciAmJiBcbiAgICAgICAgICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBcbiAgICAgICAgICAgKCgndHlwZScgaW4gZXJyb3IgJiYgZXJyb3IudHlwZSA9PT0gXCJLZXlib2FyZEludGVycnVwdFwiKSB8fFxuICAgICAgICAgICAgKCdtZXNzYWdlJyBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIktleWJvYXJkSW50ZXJydXB0XCIpKSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc3RhbmRhcmRpemVkIEtleWJvYXJkSW50ZXJydXB0IGVycm9yIHJlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVLZXlib2FyZEludGVycnVwdFJlc3VsdCgpOiB7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yOiBFcnJvcjsgcmVzdWx0OiBhbnkgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIktleWJvYXJkSW50ZXJydXB0OiBFeGVjdXRpb24gaW50ZXJydXB0ZWQgYnkgdXNlclwiKSxcbiAgICAgIHJlc3VsdDoge1xuICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgICAgZW5hbWU6IFwiS2V5Ym9hcmRJbnRlcnJ1cHRcIixcbiAgICAgICAgZXZhbHVlOiBcIkV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCIsXG4gICAgICAgIHRyYWNlYmFjazogW1wiS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCJdXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFN0b3JlIGFuIEFib3J0Q29udHJvbGxlciBmb3IgYSBzcGVjaWZpYyBrZXJuZWwgZXhlY3V0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0b3JlQWJvcnRDb250cm9sbGVyKGtlcm5lbElkOiBzdHJpbmcsIGV4ZWN1dGlvbklkOiBzdHJpbmcsIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5hYm9ydENvbnRyb2xsZXJzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVycy5zZXQoa2VybmVsSWQsIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIHRoaXMuYWJvcnRDb250cm9sbGVycy5nZXQoa2VybmVsSWQpIS5zZXQoZXhlY3V0aW9uSWQsIGNvbnRyb2xsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbmQgcmV0dXJuIGFuIEFib3J0Q29udHJvbGxlciBmb3IgYSBzcGVjaWZpYyBrZXJuZWwgZXhlY3V0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZUFib3J0Q29udHJvbGxlcihrZXJuZWxJZDogc3RyaW5nLCBleGVjdXRpb25JZDogc3RyaW5nKTogQWJvcnRDb250cm9sbGVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBrZXJuZWxDb250cm9sbGVycyA9IHRoaXMuYWJvcnRDb250cm9sbGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsQ29udHJvbGxlcnMpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgY29uc3QgY29udHJvbGxlciA9IGtlcm5lbENvbnRyb2xsZXJzLmdldChleGVjdXRpb25JZCk7XG4gICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGtlcm5lbENvbnRyb2xsZXJzLmRlbGV0ZShleGVjdXRpb25JZCk7XG4gICAgICBpZiAoa2VybmVsQ29udHJvbGxlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuZGVsZXRlKGtlcm5lbElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gIH1cblxuICAvKipcbiAgICogQWJvcnQgYWxsIG9uZ29pbmcgb3BlcmF0aW9ucyBmb3IgYSBzcGVjaWZpYyBrZXJuZWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYWJvcnRBbGxLZXJuZWxPcGVyYXRpb25zKGtlcm5lbElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBrZXJuZWxDb250cm9sbGVycyA9IHRoaXMuYWJvcnRDb250cm9sbGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsQ29udHJvbGxlcnMpIHJldHVybjtcblxuICAgIGZvciAoY29uc3QgW2V4ZWN1dGlvbklkLCBjb250cm9sbGVyXSBvZiBrZXJuZWxDb250cm9sbGVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+aqyBBYm9ydGVkIGV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfSBmb3Iga2VybmVsICR7a2VybmVsSWR9YCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBFcnJvciBhYm9ydGluZyBleGVjdXRpb24gJHtleGVjdXRpb25JZH06YCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhciBhbGwgY29udHJvbGxlcnMgZm9yIHRoaXMga2VybmVsXG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLmRlbGV0ZShrZXJuZWxJZCk7XG4gIH1cbiAgXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IElLZXJuZWxNYW5hZ2VyT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBzdXBlci5zZXRNYXhMaXN0ZW5lcnMoMTAwKTsgLy8gQWxsb3cgbWFueSBsaXN0ZW5lcnMgZm9yIGtlcm5lbCBldmVudHNcbiAgICBcbiAgICAvLyBTZXQgZGVmYXVsdCBhbGxvd2VkIGtlcm5lbCB0eXBlcyAod29ya2VyIG1vZGUgb25seSBmb3Igc2VjdXJpdHkpXG4gICAgdGhpcy5hbGxvd2VkS2VybmVsVHlwZXMgPSBvcHRpb25zLmFsbG93ZWRLZXJuZWxUeXBlcyB8fCBbXG4gICAgICB7IG1vZGU6IEtlcm5lbE1vZGUuV09SS0VSLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UuUFlUSE9OIH1cbiAgICBdO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgcG9vbCBjb25maWd1cmF0aW9uIHdpdGggZGVmYXVsdHMgYmFzZWQgb24gYWxsb3dlZCB0eXBlc1xuICAgIGNvbnN0IGRlZmF1bHRQcmVsb2FkQ29uZmlncyA9IHRoaXMuYWxsb3dlZEtlcm5lbFR5cGVzLmZpbHRlcih0eXBlID0+IFxuICAgICAgdHlwZS5sYW5ndWFnZSA9PT0gS2VybmVsTGFuZ3VhZ2UuUFlUSE9OIC8vIE9ubHkgcHJlbG9hZCBQeXRob24ga2VybmVscyBieSBkZWZhdWx0XG4gICAgKTtcbiAgICBcbiAgICB0aGlzLnBvb2xDb25maWcgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIHBvb2xTaXplOiAyLFxuICAgICAgYXV0b1JlZmlsbDogdHJ1ZSxcbiAgICAgIHByZWxvYWRDb25maWdzOiBkZWZhdWx0UHJlbG9hZENvbmZpZ3MsXG4gICAgICAuLi5vcHRpb25zLnBvb2xcbiAgICB9O1xuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRoYXQgcG9vbCBwcmVsb2FkIGNvbmZpZ3MgYXJlIHdpdGhpbiBhbGxvd2VkIHR5cGVzXG4gICAgaWYgKHRoaXMucG9vbENvbmZpZy5wcmVsb2FkQ29uZmlncykge1xuICAgICAgdGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzID0gdGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzLmZpbHRlcihjb25maWcgPT4ge1xuICAgICAgICBjb25zdCBpc0FsbG93ZWQgPSB0aGlzLmlzS2VybmVsVHlwZUFsbG93ZWQoY29uZmlnLm1vZGUsIGNvbmZpZy5sYW5ndWFnZSk7XG4gICAgICAgIGlmICghaXNBbGxvd2VkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBQb29sIHByZWxvYWQgY29uZmlnICR7Y29uZmlnLm1vZGV9LSR7Y29uZmlnLmxhbmd1YWdlfSBpcyBub3QgaW4gYWxsb3dlZEtlcm5lbFR5cGVzLCBza2lwcGluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FsbG93ZWQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RhcnQgcHJlbG9hZGluZyBpZiBwb29sIGlzIGVuYWJsZWRcbiAgICBpZiAodGhpcy5wb29sQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMucHJlbG9hZFBvb2woKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcmVsb2FkaW5nIGtlcm5lbCBwb29sOlwiLCBlcnJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogR2VuZXJhdGUgYSBwb29sIGtleSBmb3IgYSBnaXZlbiBtb2RlIGFuZCBsYW5ndWFnZSBjb21iaW5hdGlvblxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIFBvb2wga2V5IHN0cmluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRQb29sS2V5KG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke21vZGV9LSR7bGFuZ3VhZ2V9YDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIGtlcm5lbCBwcm9taXNlIGZyb20gdGhlIHBvb2wgaWYgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHJldHVybnMgS2VybmVsIHByb21pc2Ugb3IgbnVsbCBpZiBub25lIGF2YWlsYWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRGcm9tUG9vbChtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4gfCBudWxsIHtcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcG9vbEtleSA9IHRoaXMuZ2V0UG9vbEtleShtb2RlLCBsYW5ndWFnZSk7XG4gICAgY29uc3QgcG9vbFByb21pc2VzID0gdGhpcy5wb29sLmdldChwb29sS2V5KTtcbiAgICBcbiAgICBpZiAoIXBvb2xQcm9taXNlcyB8fCBwb29sUHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGZpcnN0IHByb21pc2UgZnJvbSB0aGUgcG9vbCAoRklGTylcbiAgICBjb25zdCBrZXJuZWxQcm9taXNlID0gcG9vbFByb21pc2VzLnNoaWZ0KCkhO1xuICAgIFxuICAgIC8vIEltbWVkaWF0ZWx5IHRyaWdnZXIgYmFja2dyb3VuZCByZWZpbGwgdG8gYWRkIG9uZSBwcm9taXNlIGJhY2tcbiAgICBpZiAodGhpcy5wb29sQ29uZmlnLmF1dG9SZWZpbGwpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnJlZmlsbFBvb2xTaW5nbGUobW9kZSwgbGFuZ3VhZ2UpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWZpbGxpbmcgc2luZ2xlIGtlcm5lbCBmb3IgJHtwb29sS2V5fTpgLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBrZXJuZWxQcm9taXNlO1xuICB9XG4gIFxuICAvKipcbiAgICogQWRkIGEga2VybmVsIHByb21pc2UgdG8gdGhlIHBvb2xcbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcGFyYW0ga2VybmVsUHJvbWlzZSBLZXJuZWwgcHJvbWlzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhZGRUb1Bvb2wobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlLCBrZXJuZWxQcm9taXNlOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvb2xLZXkgPSB0aGlzLmdldFBvb2xLZXkobW9kZSwgbGFuZ3VhZ2UpO1xuICAgIFxuICAgIGlmICghdGhpcy5wb29sLmhhcyhwb29sS2V5KSkge1xuICAgICAgdGhpcy5wb29sLnNldChwb29sS2V5LCBbXSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvb2xQcm9taXNlcyA9IHRoaXMucG9vbC5nZXQocG9vbEtleSkhO1xuICAgIFxuICAgIC8vIE9ubHkgYWRkIGlmIHdlIGhhdmVuJ3QgcmVhY2hlZCB0aGUgcG9vbCBzaXplIGxpbWl0XG4gICAgaWYgKHBvb2xQcm9taXNlcy5sZW5ndGggPCB0aGlzLnBvb2xDb25maWcucG9vbFNpemUpIHtcbiAgICAgIHBvb2xQcm9taXNlcy5wdXNoKGtlcm5lbFByb21pc2UpO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgcHJvbWlzZSByZWplY3Rpb24gdG8gcHJldmVudCB1bmhhbmRsZWQgcmVqZWN0aW9uc1xuICAgICAga2VybmVsUHJvbWlzZS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFBvb2wga2VybmVsIHByb21pc2UgcmVqZWN0ZWQgZm9yICR7cG9vbEtleX06YCwgZXJyb3IpO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGZhaWxlZCBwcm9taXNlIGZyb20gdGhlIHBvb2xcbiAgICAgICAgY29uc3QgaW5kZXggPSBwb29sUHJvbWlzZXMuaW5kZXhPZihrZXJuZWxQcm9taXNlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHBvb2xQcm9taXNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUG9vbCBpcyBmdWxsLCBsZXQgdGhlIGV4Y2VzcyBwcm9taXNlIHJlc29sdmUgYW5kIHRoZW4gZGVzdHJveSB0aGUga2VybmVsXG4gICAgICBrZXJuZWxQcm9taXNlLnRoZW4oa2VybmVsID0+IHtcbiAgICAgICAga2VybmVsLmRlc3Ryb3koKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlc3Ryb3lpbmcgZXhjZXNzIHBvb2wga2VybmVsOlwiLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXhjZXNzIHBvb2wga2VybmVsIHByb21pc2UgcmVqZWN0ZWQ6XCIsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlZmlsbCB0aGUgcG9vbCB3aXRoIGEgc2luZ2xlIGtlcm5lbCBwcm9taXNlXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVmaWxsUG9vbFNpbmdsZShtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvb2xLZXkgPSB0aGlzLmdldFBvb2xLZXkobW9kZSwgbGFuZ3VhZ2UpO1xuICAgIGNvbnN0IHBvb2xQcm9taXNlcyA9IHRoaXMucG9vbC5nZXQocG9vbEtleSkgfHwgW107XG4gICAgXG4gICAgLy8gT25seSBhZGQgb25lIGlmIHdlJ3JlIGJlbG93IHRoZSBwb29sIHNpemVcbiAgICBpZiAocG9vbFByb21pc2VzLmxlbmd0aCA8IHRoaXMucG9vbENvbmZpZy5wb29sU2l6ZSkge1xuICAgICAgY29uc3Qga2VybmVsUHJvbWlzZSA9IHRoaXMuY3JlYXRlUG9vbEtlcm5lbFByb21pc2UobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgdGhpcy5hZGRUb1Bvb2wobW9kZSwgbGFuZ3VhZ2UsIGtlcm5lbFByb21pc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZpbGwgdGhlIHBvb2wgZm9yIGEgc3BlY2lmaWMgY29uZmlndXJhdGlvbiB3aXRoIHBhcmFsbGVsIGNyZWF0aW9uXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVmaWxsUG9vbChtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvb2xLZXkgPSB0aGlzLmdldFBvb2xLZXkobW9kZSwgbGFuZ3VhZ2UpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJlZmlsbGluZyB0aGlzIHBvb2wga2V5IHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgIGlmICh0aGlzLnByZWZpbGxpbmdJblByb2dyZXNzLmdldChwb29sS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgcHJlZmlsbGluZyBmbGFnXG4gICAgdGhpcy5wcmVmaWxsaW5nSW5Qcm9ncmVzcy5zZXQocG9vbEtleSwgdHJ1ZSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvb2xQcm9taXNlcyA9IHRoaXMucG9vbC5nZXQocG9vbEtleSkgfHwgW107XG4gICAgICBjb25zdCBuZWVkZWQgPSB0aGlzLnBvb2xDb25maWcucG9vbFNpemUgLSBwb29sUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgXG4gICAgICBpZiAobmVlZGVkIDw9IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYWxsIG5lZWRlZCBrZXJuZWwgcHJvbWlzZXMgaW4gcGFyYWxsZWxcbiAgICAgIGNvbnN0IG5ld1Byb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbmVlZGVkIH0sICgpID0+IFxuICAgICAgICB0aGlzLmNyZWF0ZVBvb2xLZXJuZWxQcm9taXNlKG1vZGUsIGxhbmd1YWdlKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGFsbCBwcm9taXNlcyB0byB0aGUgcG9vbFxuICAgICAgZm9yIChjb25zdCBrZXJuZWxQcm9taXNlIG9mIG5ld1Byb21pc2VzKSB7XG4gICAgICAgIHRoaXMuYWRkVG9Qb29sKG1vZGUsIGxhbmd1YWdlLCBrZXJuZWxQcm9taXNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWZpbGxpbmcgcG9vbCBmb3IgJHtwb29sS2V5fTpgLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIEFsd2F5cyBjbGVhciB0aGUgcHJlZmlsbGluZyBmbGFnXG4gICAgICB0aGlzLnByZWZpbGxpbmdJblByb2dyZXNzLnNldChwb29sS2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEga2VybmVsIHByb21pc2UgZm9yIHRoZSBwb29sXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEga2VybmVsIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVBvb2xLZXJuZWxQcm9taXNlKG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSk6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGtlcm5lbCA9IGF3YWl0IHRoaXMuY3JlYXRlUG9vbEtlcm5lbChtb2RlLCBsYW5ndWFnZSk7XG4gICAgICAgIC8vIE1hcmsgYXMgdGFrZW4gZnJvbSBwb29sXG4gICAgICAgIGtlcm5lbC5pc0Zyb21Qb29sID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZShrZXJuZWwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgcG9vbCBrZXJuZWwgZm9yICR7bW9kZX0tJHtsYW5ndWFnZX06YCwgZXJyb3IpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtlcm5lbCBzcGVjaWZpY2FsbHkgZm9yIHRoZSBwb29sXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHJldHVybnMgS2VybmVsIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVBvb2xLZXJuZWwobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+IHtcbiAgICAvLyBHZW5lcmF0ZSBhIHRlbXBvcmFyeSBJRCBmb3IgdGhlIHBvb2wga2VybmVsXG4gICAgY29uc3QgdGVtcElkID0gYHBvb2wtJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWA7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGtlcm5lbCB3aXRoIG1pbmltYWwgY29uZmlndXJhdGlvblxuICAgIGNvbnN0IG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9ucyA9IHtcbiAgICAgIG1vZGUsXG4gICAgICBsYW5nOiBsYW5ndWFnZVxuICAgIH07XG4gICAgXG4gICAgLy8gU3RvcmUgb3B0aW9ucyB0ZW1wb3JhcmlseSAtIGJ1dCBkb24ndCBzdG9yZSBpbmNvbXBsZXRlIGluc3RhbmNlIGluIGtlcm5lbHMgbWFwXG4gICAgLy8gSW5zdGVhZCwgd2UnbGwgcGFzcyB0aGUgb3B0aW9ucyBkaXJlY3RseSB0byB0aGUgY3JlYXRpb24gbWV0aG9kc1xuICAgIGxldCBpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBpZiAobW9kZSA9PT0gS2VybmVsTW9kZS5NQUlOX1RIUkVBRCkge1xuICAgICAgICAvLyBGb3IgbWFpbiB0aHJlYWQsIHdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgc3RvcmUgdGhlIGluc3RhbmNlIGZvciBjcmVhdGVNYWluVGhyZWFkS2VybmVsXG4gICAgICAgIGNvbnN0IHRlbXBJbnN0YW5jZSA9IHtcbiAgICAgICAgICBpZDogdGVtcElkLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICBsYW5ndWFnZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmtlcm5lbHMuc2V0KHRlbXBJZCwgdGVtcEluc3RhbmNlIGFzIHVua25vd24gYXMgSUtlcm5lbEluc3RhbmNlKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLmNyZWF0ZU1haW5UaHJlYWRLZXJuZWwodGVtcElkKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBBbHdheXMgY2xlYW4gdXAgdGhlIHRlbXBvcmFyeSBpbnN0YW5jZVxuICAgICAgICAgIHRoaXMua2VybmVscy5kZWxldGUodGVtcElkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIHdvcmtlciBtb2RlLCB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHN0b3JlIHRoZSBpbnN0YW5jZSBmb3IgY3JlYXRlV29ya2VyS2VybmVsXG4gICAgICAgIGNvbnN0IHRlbXBJbnN0YW5jZSA9IHtcbiAgICAgICAgICBpZDogdGVtcElkLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICBsYW5ndWFnZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmtlcm5lbHMuc2V0KHRlbXBJZCwgdGVtcEluc3RhbmNlIGFzIHVua25vd24gYXMgSUtlcm5lbEluc3RhbmNlKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLmNyZWF0ZVdvcmtlcktlcm5lbCh0ZW1wSWQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIEFsd2F5cyBjbGVhbiB1cCB0aGUgdGVtcG9yYXJ5IGluc3RhbmNlXG4gICAgICAgICAgdGhpcy5rZXJuZWxzLmRlbGV0ZSh0ZW1wSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEVuc3VyZSBjbGVhbnVwIG9uIGFueSBlcnJvclxuICAgICAgdGhpcy5rZXJuZWxzLmRlbGV0ZSh0ZW1wSWQpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFByZWxvYWQgdGhlIGtlcm5lbCBwb29sIHdpdGggY29uZmlndXJlZCBrZXJuZWwgdHlwZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcHJlbG9hZFBvb2woKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCB8fCB0aGlzLmlzUHJlbG9hZGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmlzUHJlbG9hZGluZyA9IHRydWU7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFByZWxvYWQga2VybmVscyBmb3IgZWFjaCBjb25maWd1cmVkIHR5cGVcbiAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIHRoaXMucG9vbENvbmZpZy5wcmVsb2FkQ29uZmlncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucmVmaWxsUG9vbChjb25maWcubW9kZSwgY29uZmlnLmxhbmd1YWdlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcmVsb2FkaW5nICR7Y29uZmlnLm1vZGV9LSR7Y29uZmlnLmxhbmd1YWdlfTpgLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciBjb25maWd1cmF0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcga2VybmVsIHBvb2wgcHJlbG9hZGluZzpcIiwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzUHJlbG9hZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2VybmVsIHJlcXVlc3QgY2FuIHVzZSB0aGUgcG9vbFxuICAgKiBAcGFyYW0gb3B0aW9ucyBLZXJuZWwgY3JlYXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSByZXF1ZXN0IGNhbiB1c2UgcG9vbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjYW5Vc2VQb29sKG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIC8vIERvbid0IHVzZSBwb29sIGlmIGl0J3MgZGlzYWJsZWRcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIERvbid0IHVzZSBwb29sIGlmIGN1c3RvbSBmaWxlc3lzdGVtIG9yIHBlcm1pc3Npb25zIGFyZSBzcGVjaWZpZWRcbiAgICBpZiAob3B0aW9ucy5maWxlc3lzdGVtIHx8IG9wdGlvbnMuZGVubz8ucGVybWlzc2lvbnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gRG9uJ3QgdXNlIHBvb2wgaWYgY3VzdG9tIHRpbWVvdXRzIGFyZSBzcGVjaWZpZWRcbiAgICBpZiAob3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFxuICAvKipcbiAgICogUmVhc3NpZ24gYSBwb29sIGtlcm5lbCB3aXRoIG5ldyBJRCBhbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0gcG9vbEtlcm5lbCBLZXJuZWwgZnJvbSBwb29sXG4gICAqIEBwYXJhbSBuZXdJZCBOZXcga2VybmVsIElEXG4gICAqIEBwYXJhbSBvcHRpb25zIEtlcm5lbCBvcHRpb25zXG4gICAqIEByZXR1cm5zIFVwZGF0ZWQga2VybmVsIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlYXNzaWduUG9vbEtlcm5lbChcbiAgICBwb29sS2VybmVsOiBJS2VybmVsSW5zdGFuY2UsIFxuICAgIG5ld0lkOiBzdHJpbmcsIFxuICAgIG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9uc1xuICApOiBJS2VybmVsSW5zdGFuY2Uge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvYmplY3QgZXhwbGljaXRseSB0byBhdm9pZCBzcHJlYWQgb3BlcmF0b3IgaXNzdWVzXG4gICAgY29uc3QgdXBkYXRlZEluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2UgPSB7XG4gICAgICBpZDogbmV3SWQsXG4gICAgICBrZXJuZWw6IHBvb2xLZXJuZWwua2VybmVsLFxuICAgICAgbW9kZTogcG9vbEtlcm5lbC5tb2RlLFxuICAgICAgbGFuZ3VhZ2U6IHBvb2xLZXJuZWwubGFuZ3VhZ2UsXG4gICAgICB3b3JrZXI6IHBvb2xLZXJuZWwud29ya2VyLFxuICAgICAgY3JlYXRlZDogbmV3IERhdGUoKSwgLy8gVXBkYXRlIGNyZWF0aW9uIHRpbWVcbiAgICAgIG9wdGlvbnM6IHsgLi4ucG9vbEtlcm5lbC5vcHRpb25zLCAuLi5vcHRpb25zIH0sXG4gICAgICBpc0Zyb21Qb29sOiB0cnVlLFxuICAgICAgZGVzdHJveTogcG9vbEtlcm5lbC5kZXN0cm95IC8vIFByZXNlcnZlIHRoZSBvcmlnaW5hbCBkZXN0cm95IGZ1bmN0aW9uXG4gICAgfTtcbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIGRlc3Ryb3kgZnVuY3Rpb24gaXMgcHJvcGVybHkgc2V0XG4gICAgaWYgKHR5cGVvZiB1cGRhdGVkSW5zdGFuY2UuZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHByZXNlcnZlIGRlc3Ryb3kgZnVuY3Rpb24gZHVyaW5nIHBvb2wga2VybmVsIHJlYXNzaWdubWVudCcpO1xuICAgICAgY29uc29sZS5lcnJvcigncG9vbEtlcm5lbC5kZXN0cm95IHR5cGU6JywgdHlwZW9mIHBvb2xLZXJuZWwuZGVzdHJveSk7XG4gICAgICBjb25zb2xlLmVycm9yKCd1cGRhdGVkSW5zdGFuY2UuZGVzdHJveSB0eXBlOicsIHR5cGVvZiB1cGRhdGVkSW5zdGFuY2UuZGVzdHJveSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwcmVzZXJ2ZSBkZXN0cm95IGZ1bmN0aW9uIGR1cmluZyBwb29sIGtlcm5lbCByZWFzc2lnbm1lbnRgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHVwZGF0ZWRJbnN0YW5jZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwb29sIHN0YXRpc3RpY3MgZm9yIGRlYnVnZ2luZy9tb25pdG9yaW5nXG4gICAqIEByZXR1cm5zIFBvb2wgc3RhdGlzdGljc1xuICAgKi9cbiAgcHVibGljIGdldFBvb2xTdGF0cygpOiBSZWNvcmQ8c3RyaW5nLCB7IGF2YWlsYWJsZTogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH0+IHtcbiAgICBjb25zdCBzdGF0czogUmVjb3JkPHN0cmluZywgeyBhdmFpbGFibGU6IG51bWJlcjsgdG90YWw6IG51bWJlciB9PiA9IHt9O1xuICAgIFxuICAgIGZvciAoY29uc3QgW3Bvb2xLZXksIHByb21pc2VzXSBvZiB0aGlzLnBvb2wuZW50cmllcygpKSB7XG4gICAgICBzdGF0c1twb29sS2V5XSA9IHtcbiAgICAgICAgYXZhaWxhYmxlOiBwcm9taXNlcy5sZW5ndGgsXG4gICAgICAgIHRvdGFsOiB0aGlzLnBvb2xDb25maWcucG9vbFNpemVcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzdGF0cztcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwb29sIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb25cbiAgICogQHJldHVybnMgUG9vbCBjb25maWd1cmF0aW9uIGRldGFpbHNcbiAgICovXG4gIHB1YmxpYyBnZXRQb29sQ29uZmlnKCk6IHtcbiAgICBlbmFibGVkOiBib29sZWFuO1xuICAgIHBvb2xTaXplOiBudW1iZXI7XG4gICAgYXV0b1JlZmlsbDogYm9vbGVhbjtcbiAgICBwcmVsb2FkQ29uZmlnczogQXJyYXk8e1xuICAgICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgICB9PjtcbiAgICBpc1ByZWxvYWRpbmc6IGJvb2xlYW47XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBlbmFibGVkOiB0aGlzLnBvb2xDb25maWcuZW5hYmxlZCxcbiAgICAgIHBvb2xTaXplOiB0aGlzLnBvb2xDb25maWcucG9vbFNpemUsXG4gICAgICBhdXRvUmVmaWxsOiB0aGlzLnBvb2xDb25maWcuYXV0b1JlZmlsbCxcbiAgICAgIHByZWxvYWRDb25maWdzOiBbLi4udGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzXSwgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IG1vZGlmaWNhdGlvblxuICAgICAgaXNQcmVsb2FkaW5nOiB0aGlzLmlzUHJlbG9hZGluZ1xuICAgIH07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcga2VybmVsIGluc3RhbmNlXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBrZXJuZWxcbiAgICogQHBhcmFtIG9wdGlvbnMuaWQgT3B0aW9uYWwgY3VzdG9tIElEIGZvciB0aGUga2VybmVsXG4gICAqIEBwYXJhbSBvcHRpb25zLm1vZGUgT3B0aW9uYWwga2VybmVsIG1vZGUgKG1haW5fdGhyZWFkIG9yIHdvcmtlcilcbiAgICogQHBhcmFtIG9wdGlvbnMubGFuZyBPcHRpb25hbCBrZXJuZWwgbGFuZ3VhZ2UgKHB5dGhvbiBvciB0eXBlc2NyaXB0KVxuICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lc3BhY2UgT3B0aW9uYWwgbmFtZXNwYWNlIHByZWZpeCBmb3IgdGhlIGtlcm5lbCBJRFxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZW5vLnBlcm1pc3Npb25zIE9wdGlvbmFsIERlbm8gcGVybWlzc2lvbnMgZm9yIHdvcmtlciBtb2RlXG4gICAqIEBwYXJhbSBvcHRpb25zLmZpbGVzeXN0ZW0gT3B0aW9uYWwgZmlsZXN5c3RlbSBtb3VudGluZyBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0IE9wdGlvbmFsIHRpbWVvdXQgaW4gbXMgYWZ0ZXIgd2hpY2ggYW4gaW5hY3RpdmUga2VybmVsIHdpbGwgYmUgc2h1dCBkb3duXG4gICAqIEBwYXJhbSBvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgT3B0aW9uYWwgbWF4aW11bSB0aW1lIGluIG1zIGFuIGV4ZWN1dGlvbiBjYW4gcnVuIGJlZm9yZSBjb25zaWRlcmVkIHN0dWNrXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBrZXJuZWwgaW5zdGFuY2UgSURcbiAgICovXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVLZXJuZWwob3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zID0ge30pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgb3B0aW9ucy5pZCBkb2VzIG5vdCBjb250YWluIGNvbG9ucyBiZWNhdXNlIGl0IHdpbGwgYmUgdXNlZCBhcyBhIG5hbWVzcGFjZSBwcmVmaXhcbiAgICBpZiAob3B0aW9ucy5pZCAmJiBvcHRpb25zLmlkLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2VybmVsIElEIGNhbm5vdCBjb250YWluIGNvbG9ucycpO1xuICAgIH1cbiAgICBjb25zdCBiYXNlSWQgPSBvcHRpb25zLmlkIHx8IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCBLZXJuZWxNb2RlLldPUktFUjtcbiAgICBjb25zdCBsYW5ndWFnZSA9IG9wdGlvbnMubGFuZyB8fCBLZXJuZWxMYW5ndWFnZS5QWVRIT047XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlcXVlc3RlZCBrZXJuZWwgdHlwZSBpcyBhbGxvd2VkXG4gICAgaWYgKCF0aGlzLmlzS2VybmVsVHlwZUFsbG93ZWQobW9kZSwgbGFuZ3VhZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCB0eXBlICR7bW9kZX0tJHtsYW5ndWFnZX0gaXMgbm90IGFsbG93ZWQuIEFsbG93ZWQgdHlwZXM6ICR7XG4gICAgICAgIHRoaXMuYWxsb3dlZEtlcm5lbFR5cGVzLm1hcCh0ID0+IGAke3QubW9kZX0tJHt0Lmxhbmd1YWdlfWApLmpvaW4oJywgJylcbiAgICAgIH1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQXBwbHkgbmFtZXNwYWNlIHByZWZpeCBpZiBwcm92aWRlZFxuICAgIGNvbnN0IGlkID0gb3B0aW9ucy5uYW1lc3BhY2UgPyBgJHtvcHRpb25zLm5hbWVzcGFjZX06JHtiYXNlSWR9YCA6IGJhc2VJZDtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBrZXJuZWwgd2l0aCB0aGlzIElEIGFscmVhZHkgZXhpc3RzXG4gICAgaWYgKHRoaXMua2VybmVscy5oYXMoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCB3aXRoIElEICR7aWR9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBnZXQgZnJvbSBwb29sIGlmIHBvc3NpYmxlXG4gICAgaWYgKHRoaXMuY2FuVXNlUG9vbChvcHRpb25zKSkge1xuICAgICAgY29uc3QgcG9vbEtleSA9IHRoaXMuZ2V0UG9vbEtleShtb2RlLCBsYW5ndWFnZSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMga2VybmVsIHR5cGUgaXMgY29uZmlndXJlZCBmb3IgcG9vbGluZ1xuICAgICAgY29uc3QgaXNQb29sZWRUeXBlID0gdGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzLnNvbWUoY29uZmlnID0+IFxuICAgICAgICBjb25maWcubW9kZSA9PT0gbW9kZSAmJiBjb25maWcubGFuZ3VhZ2UgPT09IGxhbmd1YWdlXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoaXNQb29sZWRUeXBlKSB7XG4gICAgICAgIC8vIEZpcnN0IHRyeSB0byBnZXQgZnJvbSBleGlzdGluZyBwb29sXG4gICAgICAgIGxldCBwb29sS2VybmVsUHJvbWlzZSA9IHRoaXMuZ2V0RnJvbVBvb2wobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHBvb2xLZXJuZWxQcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0dXBQb29sS2VybmVsRnJvbVByb21pc2UocG9vbEtlcm5lbFByb21pc2UsIGlkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUG9vbCBpcyBlbXB0eSwgYnV0IHRoaXMgdHlwZSBzaG91bGQgYmUgcG9vbGVkXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwcm9taXNlIGltbWVkaWF0ZWx5IGFuZCB0cmlnZ2VyIGJhY2tncm91bmQgcmVmaWxsXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGtlcm5lbCBwcm9taXNlIHNwZWNpZmljYWxseSBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICAgICAgY29uc3QgbmV3S2VybmVsUHJvbWlzZSA9IHRoaXMuY3JlYXRlUG9vbEtlcm5lbFByb21pc2UobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyaWdnZXIgYmFja2dyb3VuZCByZWZpbGwgdG8gcmVwbGVuaXNoIHRoZSBwb29sIGZvciBmdXR1cmUgcmVxdWVzdHNcbiAgICAgICAgICBpZiAodGhpcy5wb29sQ29uZmlnLmF1dG9SZWZpbGwpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlZmlsbFBvb2wobW9kZSwgbGFuZ3VhZ2UpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWZpbGxpbmcgZXhoYXVzdGVkIHBvb2wgZm9yICR7cG9vbEtleX06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXR1cFBvb2xLZXJuZWxGcm9tUHJvbWlzZShuZXdLZXJuZWxQcm9taXNlLCBpZCwgb3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBrZXJuZWwgcHJvbWlzZSBmb3IgZXhoYXVzdGVkIHBvb2w6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgLy8gRmFsbCB0aHJvdWdoIHRvIG9uLWRlbWFuZCBjcmVhdGlvbiBhcyBsYXN0IHJlc29ydFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGtlcm5lbCB0eXBlIGlzIG5vdCBjb25maWd1cmVkIGZvciBwb29saW5nLCB0cnkgdG8gZ2V0IGZyb20gcG9vbCBhbnl3YXlcbiAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBhcmUga2VybmVscyBhdmFpbGFibGUgZnJvbSBwcmV2aW91cyBjb25maWd1cmF0aW9uc1xuICAgICAgICBjb25zdCBwb29sS2VybmVsUHJvbWlzZSA9IHRoaXMuZ2V0RnJvbVBvb2wobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgICBpZiAocG9vbEtlcm5lbFByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXR1cFBvb2xLZXJuZWxGcm9tUHJvbWlzZShwb29sS2VybmVsUHJvbWlzZSwgaWQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGwgYmFjayB0byBjcmVhdGluZyBhIG5ldyBrZXJuZWwgb24tZGVtYW5kXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlT25EZW1hbmRLZXJuZWwoaWQsIG1vZGUsIGxhbmd1YWdlLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldHVwIGEgcG9vbCBrZXJuZWwgZnJvbSBhIHByb21pc2Ugd2l0aCBuZXcgSUQgYW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHBvb2xLZXJuZWxQcm9taXNlIEtlcm5lbCBwcm9taXNlIGZyb20gcG9vbFxuICAgKiBAcGFyYW0gaWQgTmV3IGtlcm5lbCBJRFxuICAgKiBAcGFyYW0gb3B0aW9ucyBLZXJuZWwgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBLZXJuZWwgSUQgKHJldHVybmVkIGFmdGVyIGtlcm5lbCBpcyByZWFkeSlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2V0dXBQb29sS2VybmVsRnJvbVByb21pc2UoXG4gICAgcG9vbEtlcm5lbFByb21pc2U6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPiwgXG4gICAgaWQ6IHN0cmluZywgXG4gICAgb3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBwb29sIGtlcm5lbCB0byBiZSByZWFkeVxuICAgICAgY29uc3QgcG9vbEtlcm5lbCA9IGF3YWl0IHBvb2xLZXJuZWxQcm9taXNlO1xuICAgICAgXG4gICAgICAvLyBSZWFzc2lnbiB0aGUgcG9vbCBrZXJuZWwgd2l0aCB0aGUgbmV3IElEIGFuZCBvcHRpb25zXG4gICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMucmVhc3NpZ25Qb29sS2VybmVsKHBvb2xLZXJuZWwsIGlkLCBvcHRpb25zKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIHdvcmtlciBrZXJuZWxzLCB3ZSBuZWVkIHRvIHJlY3JlYXRlIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIG5ldyBJRFxuICAgICAgaWYgKGluc3RhbmNlLm1vZGUgPT09IEtlcm5lbE1vZGUuV09SS0VSICYmIGluc3RhbmNlLndvcmtlcikge1xuICAgICAgICAvLyBHZXQgdGhlIHdvcmtlciBhbmQgY3JlYXRlIG5ldyBtZXNzYWdlIGNoYW5uZWxcbiAgICAgICAgY29uc3Qgd29ya2VyID0gaW5zdGFuY2Uud29ya2VyO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgY2hhbm5lbCBmb3IgdGhlIHJlYXNzaWduZWQga2VybmVsXG4gICAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNlbmQgdGhlIG5ldyBldmVudCBwb3J0IHRvIHRoZSB3b3JrZXJcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICB0eXBlOiBcIlNFVF9FVkVOVF9QT1JUXCIsXG4gICAgICAgICAgcG9ydDogcG9ydDJcbiAgICAgICAgfSwgW3BvcnQyXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZXZlbnQgaGFuZGxlciB3aXRoIHRoZSBjb3JyZWN0IGtlcm5lbCBJRFxuICAgICAgICBjb25zdCBldmVudEhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEudHlwZSkge1xuICAgICAgICAgICAgLy8gRW1pdCB0aGUgZXZlbnQgZnJvbSB0aGUgbWFuYWdlciB3aXRoIGtlcm5lbCBJRFxuICAgICAgICAgICAgLy8gVGhpcyBzdHJ1Y3R1cmUgbWF0Y2hlcyB0aGUgc2V0dXBFdmVudEZvcndhcmRpbmcgbWV0aG9kIGZvciBtYWluIHRocmVhZCBrZXJuZWxzXG4gICAgICAgICAgICBzdXBlci5lbWl0KGV2ZW50LmRhdGEudHlwZSwge1xuICAgICAgICAgICAgICBrZXJuZWxJZDogaWQsXG4gICAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEuZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gTGlzdGVuIGZvciBldmVudHMgZnJvbSB0aGUgd29ya2VyIHdpdGggdGhlIG5ldyBoYW5kbGVyXG4gICAgICAgIHBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICBwb3J0MS5zdGFydCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBkZXN0cm95IGZ1bmN0aW9uIHRvIGNsZWFuIHVwIHRoZSBuZXcgZXZlbnQgaGFuZGxlclxuICAgICAgICBjb25zdCBvcmlnaW5hbERlc3Ryb3kgPSBpbnN0YW5jZS5kZXN0cm95O1xuICAgICAgICBpbnN0YW5jZS5kZXN0cm95ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICAgIHBvcnQxLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUga2VybmVsIGluc3RhbmNlXG4gICAgICB0aGlzLmtlcm5lbHMuc2V0KGlkLCBpbnN0YW5jZSk7XG4gICAgICBcbiAgICAgIC8vIEZvcndhcmQga2VybmVsIGV2ZW50cyB0byBtYW5hZ2VyIChmb3IgbWFpbiB0aHJlYWQga2VybmVscylcbiAgICAgIHRoaXMuc2V0dXBFdmVudEZvcndhcmRpbmcoaW5zdGFuY2UpO1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsaXplIGFjdGl2aXR5IHRyYWNraW5nXG4gICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGlkKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IHVwIGluYWN0aXZpdHkgdGltZW91dCBpZiBzcGVjaWZpZWQgYW5kIGdyZWF0ZXIgdGhhbiAwXG4gICAgICBpZiAob3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCAmJiBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ID4gMCkge1xuICAgICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXR1cCBoYW5kbGVycyBmb3Igc3RhbGxlZCBleGVjdXRpb25zIGlmIG1heEV4ZWN1dGlvblRpbWUgaXMgc3BlY2lmaWVkXG4gICAgICBpZiAob3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lICYmIG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSA+IDApIHtcbiAgICAgICAgdGhpcy5zZXR1cFN0YWxsZWRFeGVjdXRpb25IYW5kbGVyKGlkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGlkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzZXR0aW5nIHVwIHBvb2wga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIC8vIEVtaXQgYW4gZXJyb3IgZXZlbnQgZm9yIHRoaXMga2VybmVsXG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCB7XG4gICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYW1lOiBcIktlcm5lbFNldHVwRXJyb3JcIixcbiAgICAgICAgICBldmFsdWU6IGBGYWlsZWQgdG8gc2V0dXAga2VybmVsOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gLFxuICAgICAgICAgIHRyYWNlYmFjazogW2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAoZXJyb3Iuc3RhY2sgfHwgZXJyb3IubWVzc2FnZSkgOiBTdHJpbmcoZXJyb3IpXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yOyAvLyBSZS10aHJvdyB0byBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgYSBwb29sIGtlcm5lbCB3aXRoIG5ldyBJRCBhbmQgb3B0aW9ucyAoZm9yIGFscmVhZHkgcmVzb2x2ZWQga2VybmVscylcbiAgICogQHBhcmFtIHBvb2xLZXJuZWwgS2VybmVsIGZyb20gcG9vbFxuICAgKiBAcGFyYW0gaWQgTmV3IGtlcm5lbCBJRFxuICAgKiBAcGFyYW0gb3B0aW9ucyBLZXJuZWwgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBLZXJuZWwgSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc2V0dXBQb29sS2VybmVsKFxuICAgIHBvb2xLZXJuZWw6IElLZXJuZWxJbnN0YW5jZSwgXG4gICAgaWQ6IHN0cmluZywgXG4gICAgb3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zXG4gICk6IHN0cmluZyB7XG4gICAgLy8gUmVhc3NpZ24gdGhlIHBvb2wga2VybmVsIHdpdGggdGhlIG5ldyBJRCBhbmQgb3B0aW9uc1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5yZWFzc2lnblBvb2xLZXJuZWwocG9vbEtlcm5lbCwgaWQsIG9wdGlvbnMpO1xuICAgIFxuICAgIC8vIEZvciB3b3JrZXIga2VybmVscywgd2UgbmVlZCB0byByZWNyZWF0ZSB0aGUgZXZlbnQgaGFuZGxlciB3aXRoIHRoZSBuZXcgSURcbiAgICBpZiAoaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5XT1JLRVIgJiYgaW5zdGFuY2Uud29ya2VyKSB7XG4gICAgICAvLyBHZXQgdGhlIHdvcmtlciBhbmQgY3JlYXRlIG5ldyBtZXNzYWdlIGNoYW5uZWxcbiAgICAgIGNvbnN0IHdvcmtlciA9IGluc3RhbmNlLndvcmtlcjtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgY2hhbm5lbCBmb3IgdGhlIHJlYXNzaWduZWQga2VybmVsXG4gICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICBcbiAgICAgIC8vIFNlbmQgdGhlIG5ldyBldmVudCBwb3J0IHRvIHRoZSB3b3JrZXJcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiU0VUX0VWRU5UX1BPUlRcIixcbiAgICAgICAgcG9ydDogcG9ydDJcbiAgICAgIH0sIFtwb3J0Ml0pO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgZXZlbnQgaGFuZGxlciB3aXRoIHRoZSBjb3JyZWN0IGtlcm5lbCBJRFxuICAgICAgY29uc3QgZXZlbnRIYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlKSB7XG4gICAgICAgICAgLy8gRW1pdCB0aGUgZXZlbnQgZnJvbSB0aGUgbWFuYWdlciB3aXRoIGtlcm5lbCBJRFxuICAgICAgICAgIC8vIFRoaXMgc3RydWN0dXJlIG1hdGNoZXMgdGhlIHNldHVwRXZlbnRGb3J3YXJkaW5nIG1ldGhvZCBmb3IgbWFpbiB0aHJlYWQga2VybmVsc1xuICAgICAgICAgIHN1cGVyLmVtaXQoZXZlbnQuZGF0YS50eXBlLCB7XG4gICAgICAgICAgICBrZXJuZWxJZDogaWQsXG4gICAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTGlzdGVuIGZvciBldmVudHMgZnJvbSB0aGUgd29ya2VyIHdpdGggdGhlIG5ldyBoYW5kbGVyXG4gICAgICBwb3J0MS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgIHBvcnQxLnN0YXJ0KCk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGVzdHJveSBmdW5jdGlvbiB0byBjbGVhbiB1cCB0aGUgbmV3IGV2ZW50IGhhbmRsZXJcbiAgICAgIGNvbnN0IG9yaWdpbmFsRGVzdHJveSA9IGluc3RhbmNlLmRlc3Ryb3k7XG4gICAgICBpbnN0YW5jZS5kZXN0cm95ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBwb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgcG9ydDEuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRGVzdHJveSgpO1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RvcmUgdGhlIGtlcm5lbCBpbnN0YW5jZVxuICAgIHRoaXMua2VybmVscy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICBcbiAgICAvLyBGb3J3YXJkIGtlcm5lbCBldmVudHMgdG8gbWFuYWdlciAoZm9yIG1haW4gdGhyZWFkIGtlcm5lbHMpXG4gICAgdGhpcy5zZXR1cEV2ZW50Rm9yd2FyZGluZyhpbnN0YW5jZSk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBhY3Rpdml0eSB0cmFja2luZ1xuICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoaWQpO1xuICAgIFxuICAgIC8vIFNldCB1cCBpbmFjdGl2aXR5IHRpbWVvdXQgaWYgc3BlY2lmaWVkIGFuZCBncmVhdGVyIHRoYW4gMFxuICAgIGlmIChvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ICYmIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgPiAwKSB7XG4gICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXR1cCBoYW5kbGVycyBmb3Igc3RhbGxlZCBleGVjdXRpb25zIGlmIG1heEV4ZWN1dGlvblRpbWUgaXMgc3BlY2lmaWVkXG4gICAgaWYgKG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSAmJiBvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgPiAwKSB7XG4gICAgICB0aGlzLnNldHVwU3RhbGxlZEV4ZWN1dGlvbkhhbmRsZXIoaWQpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXJuZWwgb24tZGVtYW5kIChub3QgZnJvbSBwb29sKVxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHBhcmFtIG9wdGlvbnMgS2VybmVsIG9wdGlvbnNcbiAgICogQHJldHVybnMgS2VybmVsIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZU9uRGVtYW5kS2VybmVsKFxuICAgIGlkOiBzdHJpbmcsIFxuICAgIG1vZGU6IEtlcm5lbE1vZGUsIFxuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSwgXG4gICAgb3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gU3RvcmUgb3B0aW9ucyB0ZW1wb3JhcmlseSB0byBiZSB1c2VkIGluIGNyZWF0ZVdvcmtlcktlcm5lbFxuICAgIGNvbnN0IHRlbXBJbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAgb3B0aW9uczogeyAuLi5vcHRpb25zLCBsYW5nOiBsYW5ndWFnZSB9LFxuICAgICAgbW9kZSxcbiAgICAgIGxhbmd1YWdlXG4gICAgfTtcbiAgICB0aGlzLmtlcm5lbHMuc2V0KGlkLCB0ZW1wSW5zdGFuY2UgYXMgdW5rbm93biBhcyBJS2VybmVsSW5zdGFuY2UpO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUgYXBwcm9wcmlhdGUga2VybmVsIGluc3RhbmNlXG4gICAgbGV0IGluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2U7XG4gICAgXG4gICAgaWYgKG1vZGUgPT09IEtlcm5lbE1vZGUuTUFJTl9USFJFQUQpIHtcbiAgICAgIGluc3RhbmNlID0gYXdhaXQgdGhpcy5jcmVhdGVNYWluVGhyZWFkS2VybmVsKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLmNyZWF0ZVdvcmtlcktlcm5lbChpZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0b3JlIHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICB0aGlzLmtlcm5lbHMuc2V0KGlkLCBpbnN0YW5jZSk7XG4gICAgXG4gICAgLy8gRm9yd2FyZCBrZXJuZWwgZXZlbnRzIHRvIG1hbmFnZXJcbiAgICB0aGlzLnNldHVwRXZlbnRGb3J3YXJkaW5nKGluc3RhbmNlKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGFjdGl2aXR5IHRyYWNraW5nXG4gICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShpZCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGluYWN0aXZpdHkgdGltZW91dCBpZiBzcGVjaWZpZWQgYW5kIGdyZWF0ZXIgdGhhbiAwXG4gICAgaWYgKG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgJiYgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNldHVwIGhhbmRsZXJzIGZvciBzdGFsbGVkIGV4ZWN1dGlvbnMgaWYgbWF4RXhlY3V0aW9uVGltZSBpcyBzcGVjaWZpZWRcbiAgICBpZiAob3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lICYmIG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBTdGFsbGVkRXhlY3V0aW9uSGFuZGxlcihpZCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpZDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtlcm5lbCBpbnN0YW5jZSBydW5uaW5nIGluIHRoZSBtYWluIHRocmVhZFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIEtlcm5lbCBpbnN0YW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVNYWluVGhyZWFkS2VybmVsKGlkOiBzdHJpbmcpOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4ge1xuICAgIC8vIEdldCBvcHRpb25zIGZyb20gdGhlIHRlbXBvcmFyeSBpbnN0YW5jZVxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKT8ub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IG9wdGlvbnMubGFuZyB8fCBLZXJuZWxMYW5ndWFnZS5QWVRIT047XG4gICAgXG4gICAgLy8gQ3JlYXRlIHRoZSBQeXRob24ga2VybmVsXG4gICAgY29uc3Qga2VybmVsID0gbmV3IEtlcm5lbCgpO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUga2VybmVsIGluc3RhbmNlXG4gICAgY29uc3QgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAga2VybmVsLFxuICAgICAgbW9kZTogS2VybmVsTW9kZS5NQUlOX1RIUkVBRCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgY3JlYXRlZDogbmV3IERhdGUoKSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBkZXN0cm95OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIE5vdGhpbmcgc3BlY2lhbCB0byBkbyBmb3IgbWFpbiB0aHJlYWQga2VybmVsXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIGZpbGVzeXN0ZW0gb3B0aW9uc1xuICAgIGNvbnN0IGtlcm5lbE9wdGlvbnM6IElLZXJuZWxPcHRpb25zID0ge307XG4gICAgXG4gICAgLy8gQWRkIGZpbGVzeXN0ZW0gb3B0aW9ucyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zLmZpbGVzeXN0ZW0pIHtcbiAgICAgIGtlcm5lbE9wdGlvbnMuZmlsZXN5c3RlbSA9IG9wdGlvbnMuZmlsZXN5c3RlbTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGVudmlyb25tZW50IHZhcmlhYmxlcyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zLmVudikge1xuICAgICAga2VybmVsT3B0aW9ucy5lbnYgPSBvcHRpb25zLmVudjtcbiAgICB9XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUga2VybmVsXG4gICAgYXdhaXQga2VybmVsLmluaXRpYWxpemUoa2VybmVsT3B0aW9ucyk7XG4gICAgXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEga2VybmVsIGluc3RhbmNlIHJ1bm5pbmcgaW4gYSB3b3JrZXJcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBLZXJuZWwgaW5zdGFuY2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlV29ya2VyS2VybmVsKGlkOiBzdHJpbmcpOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4ge1xuICAgIC8vIEdldCBwZXJtaXNzaW9ucyBmcm9tIG9wdGlvbnMgd2hlbiBjcmVhdGluZyB0aGUga2VybmVsXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMua2VybmVscy5nZXQoaWQpPy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxhbmd1YWdlID0gb3B0aW9ucy5sYW5nIHx8IEtlcm5lbExhbmd1YWdlLlBZVEhPTjtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgd29ya2VyIHdpdGggb3B0aW9uYWwgcGVybWlzc2lvbnNcbiAgICBjb25zdCB3b3JrZXJPcHRpb25zOiBXb3JrZXJPcHRpb25zID0ge1xuICAgICAgdHlwZTogXCJtb2R1bGVcIixcbiAgICB9O1xuICAgIFxuICAgIC8vIElmIERlbm8gcGVybWlzc2lvbnMgYXJlIHByb3ZpZGVkLCB1c2UgdGhlbS5cbiAgICAvLyBPdGhlcndpc2UgZG9uJ3Qgc3BlY2lmeSBEZW5vIHBlcm1pc3Npb25zIGF0IGFsbCB0byBpbmhlcml0IGZyb20gaG9zdCBzY3JpcHRcbiAgICBpZiAob3B0aW9ucy5kZW5vPy5wZXJtaXNzaW9ucykge1xuICAgICAgd29ya2VyT3B0aW9ucy5kZW5vID0ge1xuICAgICAgICBwZXJtaXNzaW9uczogb3B0aW9ucy5kZW5vLnBlcm1pc3Npb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBJbXBvcnQgd29ya2VyIHVzaW5nIHdlYnBhY2sgd29ya2VyLWxvYWRlclxuICAgIC8vIEB0cy1pZ25vcmU6IHdlYnBhY2sgd2lsbCBoYW5kbGUgdGhpcyByZXF1aXJlXG4gICAgY29uc3QgV29ya2VyTW9kdWxlID0gcmVxdWlyZSgnLi93b3JrZXIud29ya2VyJyk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHdvcmtlciB3aXRoIHBlcm1pc3Npb25zIC0gd29ya2VyLWxvYWRlciBtaWdodCBleHBvcnQgZGVmYXVsdCBvciB0aGUgY2xhc3MgZGlyZWN0bHlcbiAgICBjb25zdCB3b3JrZXIgPSBXb3JrZXJNb2R1bGUuZGVmYXVsdCA/IG5ldyBXb3JrZXJNb2R1bGUuZGVmYXVsdCgpIDogbmV3IFdvcmtlck1vZHVsZSgpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIG1lc3NhZ2UgY2hhbm5lbCBmb3IgZXZlbnRzXG4gICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiB0aGUga2VybmVsIGlzIGluaXRpYWxpemVkXG4gICAgY29uc3QgaW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBpbml0SGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIktFUk5FTF9JTklUSUFMSVpFRFwiKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBwb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaW5pdEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaW5pdEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIktlcm5lbCBpbml0aWFsaXphdGlvbiBmYWlsZWRcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpbml0SGFuZGxlcik7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gU2VuZCB0aGUgcG9ydCB0byB0aGUgd29ya2VyXG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJTRVRfRVZFTlRfUE9SVFwiLCBwb3J0OiBwb3J0MiB9LCBbcG9ydDJdKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBwcm94eSB0byB0aGUgd29ya2VyIHVzaW5nIENvbWxpbmtcbiAgICBjb25zdCBrZXJuZWxQcm94eSA9IENvbWxpbmsud3JhcDxJS2VybmVsPih3b3JrZXIpO1xuICAgIFxuICAgIC8vIEFkZCBhIGxvY2FsIGV2ZW50IGhhbmRsZXIgdG8gYnJpZGdlIHRoZSB3b3JrZXIgZXZlbnRzXG4gICAgLy8gVGhpcyB3b3JrcyBhcm91bmQgdGhlIGxpbWl0YXRpb24gdGhhdCBDb21saW5rIGRvZXNuJ3QgcHJveHkgZXZlbnQgZW1pdHRlcnNcbiAgICBjb25zdCBldmVudEhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlKSB7XG4gICAgICAgIC8vIEVtaXQgdGhlIGV2ZW50IGZyb20gdGhlIG1hbmFnZXIgd2l0aCBrZXJuZWwgSURcbiAgICAgICAgLy8gVGhpcyBzdHJ1Y3R1cmUgbWF0Y2hlcyB0aGUgc2V0dXBFdmVudEZvcndhcmRpbmcgbWV0aG9kIGZvciBtYWluIHRocmVhZCBrZXJuZWxzXG4gICAgICAgIHN1cGVyLmVtaXQoZXZlbnQuZGF0YS50eXBlLCB7XG4gICAgICAgICAga2VybmVsSWQ6IGlkLFxuICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEuZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIExpc3RlbiBmb3IgZXZlbnRzIGZyb20gdGhlIHdvcmtlclxuICAgIHBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgIHBvcnQxLnN0YXJ0KCk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUga2VybmVsIHdpdGggZmlsZXN5c3RlbSBvcHRpb25zXG4gICAgLy8gV2UgbmVlZCB0byBwYXNzIHRoZXNlIG9wdGlvbnMgdG8gdGhlIHdvcmtlclxuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcIklOSVRJQUxJWkVfS0VSTkVMXCIsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGZpbGVzeXN0ZW06IG9wdGlvbnMuZmlsZXN5c3RlbSxcbiAgICAgICAgZW52OiBvcHRpb25zLmVudixcbiAgICAgICAgbGFuZzogbGFuZ3VhZ2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBXYWl0IGZvciBrZXJuZWwgaW5pdGlhbGl6YXRpb25cbiAgICBhd2FpdCBpbml0UHJvbWlzZTtcbiAgICBcbiAgICAvLyBTZXQgdXAgaW50ZXJydXB0IGJ1ZmZlciBhdXRvbWF0aWNhbGx5IGZvciB3b3JrZXIga2VybmVsc1xuICAgIGF3YWl0IHRoaXMuc2V0dXBXb3JrZXJJbnRlcnJ1cHRCdWZmZXIoaWQsIHdvcmtlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICBjb25zdCBpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBrZXJuZWw6IHtcbiAgICAgICAgLy8gTWFwIG1ldGhvZHMgZnJvbSB0aGUgQ29tbGluayBwcm94eSB0byB0aGUgSUtlcm5lbCBpbnRlcmZhY2VcbiAgICAgICAgaW5pdGlhbGl6ZTogYXN5bmMgKG9wdGlvbnM/OiBJS2VybmVsT3B0aW9ucykgPT4ge1xuICAgICAgICAgIHJldHVybiBrZXJuZWxQcm94eS5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBleGVjdXRlOiBhc3luYyAoY29kZTogc3RyaW5nLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWxQcm94eS5leGVjdXRlKGNvZGUsIHBhcmVudCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGFuZGxlIFB5dGhvbiB3b3JrZXIgcmVzdWx0cyAobm8gc3BlY2lhbCBkaXNwbGF5IHJlY29uc3RydWN0aW9uIG5lZWRlZClcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBpc0luaXRpYWxpemVkOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGtlcm5lbFByb3h5LmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXRSZXBseTogYXN5bmMgKGNvbnRlbnQ6IHsgdmFsdWU6IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGtlcm5lbFByb3h5LmlucHV0UmVwbHkoY29udGVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcCBhc3luYyBnZXRTdGF0dXMgbWV0aG9kXG4gICAgICAgIGdldFN0YXR1czogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmdldFN0YXR1cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBcInVua25vd25cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcCBjb21wbGV0aW9uIG1ldGhvZHNcbiAgICAgICAgY29tcGxldGU6IGFzeW5jIChjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuY29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmNvbXBsZXRlKGNvZGUsIGN1cnNvcl9wb3MsIHBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiAnQ29tcGxldGlvbiBub3Qgc3VwcG9ydGVkJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnNwZWN0OiBhc3luYyAoY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIGRldGFpbF9sZXZlbDogMCB8IDEsIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5Lmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5Lmluc3BlY3QoY29kZSwgY3Vyc29yX3BvcywgZGV0YWlsX2xldmVsLCBwYXJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogJ0luc3BlY3Rpb24gbm90IHN1cHBvcnRlZCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNDb21wbGV0ZTogYXN5bmMgKGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuaXNDb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuaXNDb21wbGV0ZShjb2RlLCBwYXJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAndW5rbm93bicgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFwIGludGVycnVwdCBtZXRob2RzXG4gICAgICAgIGludGVycnVwdDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuaW50ZXJydXB0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVycnVwdEJ1ZmZlcjogKGJ1ZmZlcjogVWludDhBcnJheSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LnNldEludGVycnVwdEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBrZXJuZWxQcm94eS5zZXRJbnRlcnJ1cHRCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2V0IGludGVycnVwdCBidWZmZXI6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFwIGNvbW0gbWV0aG9kc1xuICAgICAgICBjb21tSW5mbzogYXN5bmMgKHRhcmdldF9uYW1lOiBzdHJpbmcgfCBudWxsLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5jb21tSW5mbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuY29tbUluZm8odGFyZ2V0X25hbWUsIHBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBjb21tczoge30sIHN0YXR1czogJ29rJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb21tczoge30sIHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1PcGVuOiBhc3luYyAoY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5jb21tT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuY29tbU9wZW4oY29udGVudCwgcGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gb3BlbiBjb21tOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1Nc2c6IGFzeW5jIChjb250ZW50OiBhbnksIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmNvbW1Nc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmNvbW1Nc2coY29udGVudCwgcGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2VuZCBjb21tIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tbUNsb3NlOiBhc3luYyAoY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5jb21tQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmNvbW1DbG9zZShjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbG9zZSBjb21tOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBJS2VybmVsLFxuICAgICAgbW9kZTogS2VybmVsTW9kZS5XT1JLRVIsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIHdvcmtlcixcbiAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKCksXG4gICAgICBvcHRpb25zLCAvLyBTdG9yZSB0aGUgb3B0aW9ucyBmb3IgcmVmZXJlbmNlXG4gICAgICBkZXN0cm95OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIENsZWFuIHVwIHRoZSB3b3JrZXIgYW5kIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICBwb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgcG9ydDEuY2xvc2UoKTtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXR1cCBldmVudCBmb3J3YXJkaW5nIGZyb20ga2VybmVsIHRvIG1hbmFnZXJcbiAgICogQHBhcmFtIGluc3RhbmNlIEtlcm5lbCBpbnN0YW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50Rm9yd2FyZGluZyhpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlKTogdm9pZCB7XG4gICAgLy8gT25seSBuZWVkZWQgZm9yIG1haW4gdGhyZWFkIGtlcm5lbHMgYXMgd29ya2VyIGV2ZW50cyBhcmUgaGFuZGxlZCBkaXJlY3RseVxuICAgIGlmIChpbnN0YW5jZS5tb2RlID09PSBLZXJuZWxNb2RlLk1BSU5fVEhSRUFEKSB7XG4gICAgICAvLyBGb3J3YXJkIGFsbCBrZXJuZWwgZXZlbnRzIHRvIHRoZSBtYW5hZ2VyIHdpdGgga2VybmVsIElEXG4gICAgICBPYmplY3QudmFsdWVzKEtlcm5lbEV2ZW50cykuZm9yRWFjaCgoZXZlbnRUeXBlKSA9PiB7XG4gICAgICAgIC8vIEFjY2VzcyB0aGUga2VybmVsIGFzIGEgS2VybmVsIGluc3RhbmNlIHdoaWNoIGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gICAgICAgIGNvbnN0IGtlcm5lbEVtaXR0ZXIgPSBpbnN0YW5jZS5rZXJuZWwgYXMgdW5rbm93biBhcyBFdmVudEVtaXR0ZXI7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgdG8gZm9yd2FyZCBldmVudHNcbiAgICAgICAga2VybmVsRW1pdHRlci5vbihldmVudFR5cGUsIChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICBzdXBlci5lbWl0KGV2ZW50VHlwZSwge1xuICAgICAgICAgICAga2VybmVsSWQ6IGluc3RhbmNlLmlkLFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIGtlcm5lbCBpbnN0YW5jZSBieSBJRFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIEtlcm5lbCBpbnN0YW5jZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgZ2V0S2VybmVsKGlkOiBzdHJpbmcpOiBJS2VybmVsSW5zdGFuY2UgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgYWxsIGtlcm5lbCBJRHNcbiAgICogQHJldHVybnMgQXJyYXkgb2Yga2VybmVsIElEc1xuICAgKi9cbiAgcHVibGljIGdldEtlcm5lbElkcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5rZXJuZWxzLmtleXMoKSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBrZXJuZWxzIHdpdGggdGhlaXIgZGV0YWlsc1xuICAgKiBAcGFyYW0gbmFtZXNwYWNlIE9wdGlvbmFsIG5hbWVzcGFjZSB0byBmaWx0ZXIga2VybmVscyBieVxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBrZXJuZWwgaW5mb3JtYXRpb24gb2JqZWN0c1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RLZXJuZWxzKG5hbWVzcGFjZT86IHN0cmluZyk6IFByb21pc2U8QXJyYXk8e1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gICAgc3RhdHVzOiBcImFjdGl2ZVwiIHwgXCJidXN5XCIgfCBcInVua25vd25cIjtcbiAgICBjcmVhdGVkOiBEYXRlO1xuICAgIG5hbWVzcGFjZT86IHN0cmluZztcbiAgICBkZW5vPzoge1xuICAgICAgcGVybWlzc2lvbnM/OiBJRGVub1Blcm1pc3Npb25zO1xuICAgIH07XG4gIH0+PiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRLZXJuZWxzID0gQXJyYXkuZnJvbSh0aGlzLmtlcm5lbHMuZW50cmllcygpKVxuICAgICAgICAuZmlsdGVyKChbaWRdKSA9PiB7XG4gICAgICAgICAgLy8gRmlsdGVyIG91dCBwb29sIGtlcm5lbHMgKHRlbXBvcmFyeSBrZXJuZWxzIHdpdGggSURzIHN0YXJ0aW5nIHdpdGggXCJwb29sLVwiKVxuICAgICAgICAgIGlmIChpZC5zdGFydHNXaXRoKFwicG9vbC1cIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIW5hbWVzcGFjZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoYCR7bmFtZXNwYWNlfTpgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIFVzZSBQcm9taXNlLmFsbCB0byBnZXQgYWxsIHN0YXR1c2VzIGNvbmN1cnJlbnRseVxuICAgICAgY29uc3Qga2VybmVsSW5mb3MgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgZmlsdGVyZWRLZXJuZWxzLm1hcChhc3luYyAoW2lkLCBpbnN0YW5jZV0pID0+IHtcbiAgICAgICAgICAvLyBFeHRyYWN0IG5hbWVzcGFjZSBmcm9tIGlkIGlmIHByZXNlbnRcbiAgICAgICAgICBjb25zdCBuYW1lc3BhY2VNYXRjaCA9IGlkLm1hdGNoKC9eKFteOl0rKTovKTtcbiAgICAgICAgICBjb25zdCBleHRyYWN0ZWROYW1lc3BhY2UgPSBuYW1lc3BhY2VNYXRjaCA/IG5hbWVzcGFjZU1hdGNoWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCBzdGF0dXMgdXNpbmcgYXN5bmMgZ2V0U3RhdHVzIG1ldGhvZFxuICAgICAgICAgIGxldCBzdGF0dXM6IFwiYWN0aXZlXCIgfCBcImJ1c3lcIiB8IFwidW5rbm93blwiID0gXCJ1bmtub3duXCI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5rZXJuZWwgJiYgdHlwZW9mIGluc3RhbmNlLmtlcm5lbC5nZXRTdGF0dXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc3RhdHVzID0gYXdhaXQgaW5zdGFuY2Uua2VybmVsLmdldFN0YXR1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGdldHRpbmcgc3RhdHVzIGZvciBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgc3RhdHVzID0gXCJ1bmtub3duXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG1vZGU6IGluc3RhbmNlLm1vZGUsXG4gICAgICAgICAgICBsYW5ndWFnZTogaW5zdGFuY2UubGFuZ3VhZ2UsXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBjcmVhdGVkOiBpbnN0YW5jZS5jcmVhdGVkIHx8IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBuYW1lc3BhY2U6IGV4dHJhY3RlZE5hbWVzcGFjZSxcbiAgICAgICAgICAgIGRlbm86IGluc3RhbmNlLm9wdGlvbnM/LmRlbm9cbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGtlcm5lbEluZm9zO1xuICB9XG4gIFxuICAvKipcbiAgICogRGVzdHJveSBhIGtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4ga2VybmVsIGlzIGRlc3Ryb3llZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRlc3Ryb3lLZXJuZWwoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgLy8gSGFuZGxlIGdyYWNlZnVsbHkgLSBrZXJuZWwgbWF5IGFscmVhZHkgYmUgZGVzdHJveWVkXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFZlcmlmeSB0aGUgZGVzdHJveSBmdW5jdGlvbiBleGlzdHNcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmRlc3Ryb3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsICR7aWR9IGlzIG1pc3NpbmcgZGVzdHJveSBmdW5jdGlvbiAodHlwZTogJHt0eXBlb2YgaW5zdGFuY2UuZGVzdHJveX0pYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFib3J0IGFsbCBvbmdvaW5nIG9wZXJhdGlvbnMgZm9yIHRoaXMga2VybmVsIGZpcnN0XG4gICAgdGhpcy5hYm9ydEFsbEtlcm5lbE9wZXJhdGlvbnMoaWQpO1xuICAgIFxuICAgIC8vIENsZWFyIGFueSBpbmFjdGl2aXR5IHRpbWVyXG4gICAgdGhpcy5jbGVhckluYWN0aXZpdHlUaW1lb3V0KGlkKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleGVjdXRpb24gdGltZW91dHNcbiAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lb3V0cy5oYXMoaWQpKSB7XG4gICAgICBjb25zdCB0aW1lb3V0cyA9IHRoaXMuZXhlY3V0aW9uVGltZW91dHMuZ2V0KGlkKSE7XG4gICAgICBmb3IgKGNvbnN0IHRpbWVvdXRJZCBvZiB0aW1lb3V0cy52YWx1ZXMoKSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0aW9uVGltZW91dHMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhlY3V0aW9uIHN0YXJ0IHRpbWVzXG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhlY3V0aW9uIG1ldGFkYXRhXG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuaGFzKGlkKSkge1xuICAgICAgdGhpcy5leGVjdXRpb25NZXRhZGF0YS5kZWxldGUoaWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBpbnRlcnJ1cHQgYnVmZmVyc1xuICAgIGlmICh0aGlzLmludGVycnVwdEJ1ZmZlcnMuaGFzKGlkKSkge1xuICAgICAgdGhpcy5pbnRlcnJ1cHRCdWZmZXJzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIG9uZ29pbmcgZXhlY3V0aW9ucyB0cmFja2luZ1xuICAgIHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZGVsZXRlKGlkKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBhY3Rpdml0eSB0cmFja2luZ1xuICAgIHRoaXMubGFzdEFjdGl2aXR5VGltZS5kZWxldGUoaWQpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGlzIGtlcm5lbFxuICAgIHRoaXMucmVtb3ZlQWxsS2VybmVsTGlzdGVuZXJzKGlkKTtcbiAgICBcbiAgICAvLyBEZXN0cm95IHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICBhd2FpdCBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIHRoZSBrZXJuZWwgZnJvbSB0aGUgbWFwXG4gICAgdGhpcy5rZXJuZWxzLmRlbGV0ZShpZCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBEZXN0cm95IGFsbCBrZXJuZWwgaW5zdGFuY2VzXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgT3B0aW9uYWwgbmFtZXNwYWNlIHRvIGZpbHRlciBrZXJuZWxzIHRvIGRlc3Ryb3lcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhbGwga2VybmVscyBhcmUgZGVzdHJveWVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVzdHJveUFsbChuYW1lc3BhY2U/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBpZHMgPSBBcnJheS5mcm9tKHRoaXMua2VybmVscy5rZXlzKCkpXG4gICAgICAuZmlsdGVyKGlkID0+IHtcbiAgICAgICAgaWYgKCFuYW1lc3BhY2UpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgJHtuYW1lc3BhY2V9OmApO1xuICAgICAgfSk7XG4gICAgXG4gICAgLy8gRGVzdHJveSBhbGwga2VybmVscywgYnV0IHNraXAgaW5jb21wbGV0ZSBpbnN0YW5jZXNcbiAgICBjb25zdCBkZXN0cm95UHJvbWlzZXMgPSBpZHMubWFwKGFzeW5jIChpZCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICAgIGlmICghaW5zdGFuY2UgfHwgdHlwZW9mIGluc3RhbmNlLmRlc3Ryb3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBTa2lwcGluZyBpbmNvbXBsZXRlIGtlcm5lbCBpbnN0YW5jZSAke2lkfSBkdXJpbmcgZGVzdHJveUFsbGApO1xuICAgICAgICAvLyBKdXN0IHJlbW92ZSBpdCBmcm9tIHRoZSBtYXBcbiAgICAgICAgdGhpcy5rZXJuZWxzLmRlbGV0ZShpZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3lLZXJuZWwoaWQpO1xuICAgIH0pO1xuICAgIFxuICAgIGF3YWl0IFByb21pc2UuYWxsKGRlc3Ryb3lQcm9taXNlcyk7XG4gICAgXG4gICAgLy8gSWYgbm8gbmFtZXNwYWNlIHNwZWNpZmllZCwgYWxzbyBjbGVhbiB1cCB0aGUgcG9vbFxuICAgIGlmICghbmFtZXNwYWNlKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlc3Ryb3lQb29sKCk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRGVzdHJveSBhbGwga2VybmVscyBpbiB0aGUgcG9vbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkZXN0cm95UG9vbCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBcbiAgICBjb25zdCBkZXN0cm95UHJvbWlzZXM6IFByb21pc2U8dm9pZD5bXSA9IFtdO1xuICAgIFxuICAgIGZvciAoY29uc3QgW3Bvb2xLZXksIHByb21pc2VzXSBvZiB0aGlzLnBvb2wuZW50cmllcygpKSB7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qga2VybmVsUHJvbWlzZSBvZiBwcm9taXNlcykge1xuICAgICAgICAvLyBIYW5kbGUgZWFjaCBwcm9taXNlIC0gaWYgaXQgcmVzb2x2ZXMsIGRlc3Ryb3kgdGhlIGtlcm5lbFxuICAgICAgICBjb25zdCBkZXN0cm95UHJvbWlzZSA9IGtlcm5lbFByb21pc2UudGhlbihrZXJuZWwgPT4ge1xuICAgICAgICAgIHJldHVybiBrZXJuZWwuZGVzdHJveSgpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVzdHJveWluZyBwb29sIGtlcm5lbCBmcm9tIHByb21pc2U6YCwgZXJyb3IpO1xuICAgICAgICAgIC8vIERvbid0IHJlLXRocm93IHRvIGF2b2lkIHVuaGFuZGxlZCByZWplY3Rpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZGVzdHJveVByb21pc2VzLnB1c2goZGVzdHJveVByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBXYWl0IGZvciBhbGwgcG9vbCBrZXJuZWxzIHRvIGJlIGRlc3Ryb3llZFxuICAgIGF3YWl0IFByb21pc2UuYWxsKGRlc3Ryb3lQcm9taXNlcyk7XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIHBvb2wgYW5kIHByZWZpbGxpbmcgZmxhZ3NcbiAgICB0aGlzLnBvb2wuY2xlYXIoKTtcbiAgICB0aGlzLnByZWZpbGxpbmdJblByb2dyZXNzLmNsZWFyKCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciBmb3IgYSBzcGVjaWZpYyBrZXJuZWwncyBldmVudHNcbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIEV2ZW50IHR5cGVcbiAgICogQHBhcmFtIGxpc3RlbmVyIEV2ZW50IGxpc3RlbmVyXG4gICAqL1xuICBwdWJsaWMgb25LZXJuZWxFdmVudChrZXJuZWxJZDogc3RyaW5nLCBldmVudFR5cGU6IEtlcm5lbEV2ZW50cywgbGlzdGVuZXI6IChkYXRhOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAvLyBDaGVjayBpZiBrZXJuZWwgZXhpc3RzXG4gICAgaWYgKCF0aGlzLmtlcm5lbHMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgd2l0aCBJRCAke2tlcm5lbElkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIHdyYXBwZXIgdGhhdCBmaWx0ZXJzIGV2ZW50cyBmb3IgdGhpcyBzcGVjaWZpYyBrZXJuZWxcbiAgICBjb25zdCB3cmFwcGVyOiBMaXN0ZW5lcldyYXBwZXIgPSB7XG4gICAgICBvcmlnaW5hbDogbGlzdGVuZXIsXG4gICAgICB3cmFwcGVkOiAoZXZlbnQ6IHsga2VybmVsSWQ6IHN0cmluZywgZGF0YTogYW55IH0pID0+IHtcbiAgICAgICAgaWYgKGV2ZW50Lmtlcm5lbElkID09PSBrZXJuZWxJZCkge1xuICAgICAgICAgIC8vIFBhc3MganVzdCB0aGUgZGF0YSB0byB0aGUgbGlzdGVuZXJcbiAgICAgICAgICAvLyBUaGUgZGF0YSBzdHJ1Y3R1cmUgaXMgY29uc2lzdGVudCBhY3Jvc3MgbWFpbiB0aHJlYWQgYW5kIHdvcmtlciBtb2Rlc1xuICAgICAgICAgIGxpc3RlbmVyKGV2ZW50LmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBTdG9yZSB0aGUgd3JhcHBlciBmb3IgbGF0ZXIgcmVtb3ZhbFxuICAgIHRoaXMuc3RvcmVMaXN0ZW5lcihrZXJuZWxJZCwgZXZlbnRUeXBlLCBsaXN0ZW5lciwgd3JhcHBlcik7XG4gICAgXG4gICAgLy8gQWRkIHRoZSB3cmFwcGVkIGxpc3RlbmVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgc3VwZXIub24oZXZlbnRUeXBlLCB3cmFwcGVyLndyYXBwZWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBhIHNwZWNpZmljIGtlcm5lbFxuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBldmVudFR5cGUgRXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gbGlzdGVuZXIgRXZlbnQgbGlzdGVuZXJcbiAgICovXG4gIHB1YmxpYyBvZmZLZXJuZWxFdmVudChrZXJuZWxJZDogc3RyaW5nLCBldmVudFR5cGU6IEtlcm5lbEV2ZW50cywgbGlzdGVuZXI6IChkYXRhOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5nZXRMaXN0ZW5lcihrZXJuZWxJZCwgZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgXG4gICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgd3JhcHBlZCBsaXN0ZW5lciBmcm9tIHRoZSBtYW5hZ2VyXG4gICAgICBzdXBlci5yZW1vdmVMaXN0ZW5lcihldmVudFR5cGUsIHdyYXBwZXIud3JhcHBlZCk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSB0aGUgd3JhcHBlciBmcm9tIG91ciB0cmFja2luZyBtYXBcbiAgICAgIHRoaXMucmVtb3ZlU3RvcmVkTGlzdGVuZXIoa2VybmVsSWQsIGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFN0b3JlIGEgbGlzdGVuZXIgd3JhcHBlciBmb3IgbGF0ZXIgcmVtb3ZhbFxuICAgKi9cbiAgcHJpdmF0ZSBzdG9yZUxpc3RlbmVyKFxuICAgIGtlcm5lbElkOiBzdHJpbmcsIFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLCBcbiAgICBvcmlnaW5hbDogRnVuY3Rpb24sIFxuICAgIHdyYXBwZXI6IExpc3RlbmVyV3JhcHBlclxuICApOiB2b2lkIHtcbiAgICAvLyBHZXQgb3IgY3JlYXRlIGtlcm5lbCBtYXBcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJXcmFwcGVycy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuc2V0KGtlcm5lbElkLCBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBjb25zdCBrZXJuZWxNYXAgPSB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZ2V0KGtlcm5lbElkKSE7XG4gICAgXG4gICAgLy8gR2V0IG9yIGNyZWF0ZSBldmVudCB0eXBlIG1hcFxuICAgIGlmICgha2VybmVsTWFwLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICBrZXJuZWxNYXAuc2V0KGV2ZW50VHlwZSwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRNYXAgPSBrZXJuZWxNYXAuZ2V0KGV2ZW50VHlwZSkhO1xuICAgIFxuICAgIC8vIFN0b3JlIHRoZSB3cmFwcGVyXG4gICAgZXZlbnRNYXAuc2V0KG9yaWdpbmFsLCB3cmFwcGVyKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIHN0b3JlZCBsaXN0ZW5lciB3cmFwcGVyXG4gICAqL1xuICBwcml2YXRlIGdldExpc3RlbmVyKFxuICAgIGtlcm5lbElkOiBzdHJpbmcsIFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLCBcbiAgICBvcmlnaW5hbDogRnVuY3Rpb25cbiAgKTogTGlzdGVuZXJXcmFwcGVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBrZXJuZWxNYXAgPSB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbE1hcCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zdCBldmVudE1hcCA9IGtlcm5lbE1hcC5nZXQoZXZlbnRUeXBlKTtcbiAgICBpZiAoIWV2ZW50TWFwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIHJldHVybiBldmVudE1hcC5nZXQob3JpZ2luYWwpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmVtb3ZlIGEgc3RvcmVkIGxpc3RlbmVyIHdyYXBwZXJcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlU3RvcmVkTGlzdGVuZXIoXG4gICAga2VybmVsSWQ6IHN0cmluZywgXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsIFxuICAgIG9yaWdpbmFsOiBGdW5jdGlvblxuICApOiB2b2lkIHtcbiAgICBjb25zdCBrZXJuZWxNYXAgPSB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbE1hcCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGV2ZW50TWFwID0ga2VybmVsTWFwLmdldChldmVudFR5cGUpO1xuICAgIGlmICghZXZlbnRNYXApIHJldHVybjtcbiAgICBcbiAgICAvLyBSZW1vdmUgdGhlIGxpc3RlbmVyXG4gICAgZXZlbnRNYXAuZGVsZXRlKG9yaWdpbmFsKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBlbXB0eSBtYXBzXG4gICAgaWYgKGV2ZW50TWFwLnNpemUgPT09IDApIHtcbiAgICAgIGtlcm5lbE1hcC5kZWxldGUoZXZlbnRUeXBlKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGtlcm5lbE1hcC5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZGVsZXRlKGtlcm5lbElkKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBrZXJuZWxcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlQWxsS2VybmVsTGlzdGVuZXJzKGtlcm5lbElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBrZXJuZWxNYXAgPSB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbE1hcCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIEZvciBlYWNoIGV2ZW50IHR5cGVcbiAgICBmb3IgKGNvbnN0IFtldmVudFR5cGUsIGV2ZW50TWFwXSBvZiBrZXJuZWxNYXAuZW50cmllcygpKSB7XG4gICAgICAvLyBGb3IgZWFjaCBvcmlnaW5hbCBsaXN0ZW5lclxuICAgICAgZm9yIChjb25zdCB3cmFwcGVyIG9mIGV2ZW50TWFwLnZhbHVlcygpKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd3JhcHBlZCBsaXN0ZW5lciBmcm9tIHRoZSBtYW5hZ2VyXG4gICAgICAgIHN1cGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgd3JhcHBlci53cmFwcGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIGtlcm5lbCdzIGxpc3RlbmVyIG1hcFxuICAgIHRoaXMubGlzdGVuZXJXcmFwcGVycy5kZWxldGUoa2VybmVsSWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGFsbCBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMga2VybmVsIGFuZCBldmVudCB0eXBlXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGV2ZW50VHlwZSBFdmVudCB0eXBlXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGxpc3RlbmVyc1xuICAgKi9cbiAgcHVibGljIGdldExpc3RlbmVycyhrZXJuZWxJZDogc3RyaW5nLCBldmVudFR5cGU6IEtlcm5lbEV2ZW50cyk6ICgoZGF0YTogYW55KSA9PiB2b2lkKVtdIHtcbiAgICBjb25zdCBrZXJuZWxMaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbExpc3RlbmVycykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IGtlcm5lbExpc3RlbmVycy5nZXQoZXZlbnRUeXBlKTtcbiAgICBpZiAoIWV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBBcnJheS5mcm9tKGV2ZW50TGlzdGVuZXJzLmtleXMoKSkgYXMgKChkYXRhOiBhbnkpID0+IHZvaWQpW107XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBQeXRob24gY29kZSB3aXRoIHN0cmVhbWluZyBvdXRwdXRcbiAgICogVGhpcyBtZXRob2Qgd29ya3MgaW4gYm90aCBtYWluIHRocmVhZCBhbmQgd29ya2VyIG1vZGVzXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBJRCBvZiB0aGUga2VybmVsIHRvIHVzZVxuICAgKiBAcGFyYW0gY29kZSBUaGUgUHl0aG9uIGNvZGUgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gcGFyZW50IE9wdGlvbmFsIHBhcmVudCBtZXNzYWdlIGhlYWRlclxuICAgKiBAcmV0dXJucyBBc3luY0dlbmVyYXRvciB5aWVsZGluZyBpbnRlcm1lZGlhdGUgb3V0cHV0c1xuICAgKi9cbiAgcHVibGljIGFzeW5jKiBleGVjdXRlU3RyZWFtKFxuICAgIGtlcm5lbElkOiBzdHJpbmcsIFxuICAgIGNvZGU6IHN0cmluZywgXG4gICAgcGFyZW50OiBhbnkgPSB7fVxuICApOiBBc3luY0dlbmVyYXRvcjxhbnksIHsgc3VjY2VzczogYm9vbGVhbiwgcmVzdWx0PzogYW55LCBlcnJvcj86IEVycm9yIH0sIHZvaWQ+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0S2VybmVsKGtlcm5lbElkKTtcbiAgICBcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCB3aXRoIElEICR7a2VybmVsSWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUga2VybmVsIGFjdGl2aXR5XG4gICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgXG4gICAgLy8gVHJhY2sgdGhpcyBleGVjdXRpb24gd2l0aCB0aGUgY29kZSBmb3IgYmV0dGVyIG1vbml0b3JpbmdcbiAgICBjb25zdCBleGVjdXRpb25JZCA9IHRoaXMudHJhY2tFeGVjdXRpb24oa2VybmVsSWQsIGNvZGUpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBBYm9ydENvbnRyb2xsZXIgZm9yIHRoaXMgZXhlY3V0aW9uIHRvIGVuYWJsZSBjYW5jZWxsYXRpb25cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5zdG9yZUFib3J0Q29udHJvbGxlcihrZXJuZWxJZCwgZXhlY3V0aW9uSWQsIGFib3J0Q29udHJvbGxlcik7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZvciBtYWluIHRocmVhZCBrZXJuZWxzLCB3ZSBjYW4gdXNlIHRoZSBleGVjdXRlU3RyZWFtIG1ldGhvZCBkaXJlY3RseVxuICAgICAgaWYgKGluc3RhbmNlLm1vZGUgPT09IEtlcm5lbE1vZGUuTUFJTl9USFJFQUQpIHtcbiAgICAgICAgY29uc3Qga2VybmVsID0gaW5zdGFuY2Uua2VybmVsIGFzIHVua25vd24gYXMgeyBcbiAgICAgICAgICBleGVjdXRlU3RyZWFtOiAoY29kZTogc3RyaW5nLCBwYXJlbnQ6IGFueSkgPT4gQXN5bmNHZW5lcmF0b3I8YW55LCBhbnksIHZvaWQ+IFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yd2FyZCB0byB0aGUga2VybmVsJ3MgZXhlY3V0ZVN0cmVhbSBtZXRob2RcbiAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWwuZXhlY3V0ZVN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB5aWVsZCoga2VybmVsLmV4ZWN1dGVTdHJlYW0oY29kZSwgcGFyZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IGFmdGVyIGV4ZWN1dGlvbiBjb21wbGV0ZXNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDb21wbGV0ZSBleGVjdXRpb24gdHJhY2tpbmdcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBtYWluIHRocmVhZCBleGVjdXRlU3RyZWFtOmAsIGVycm9yKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IGV2ZW4gaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbXBsZXRlIGV4ZWN1dGlvbiB0cmFja2luZyBldmVuIG9uIGVycm9yXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlRXhlY3V0aW9uKGtlcm5lbElkLCBleGVjdXRpb25JZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvciB3b3JrZXIgbW9kZSwgd2UgbmVlZCB0byBpbXBsZW1lbnQgc3RyZWFtaW5nIHZpYSBldmVudHMgd2l0aCBwcm9wZXIgaXNvbGF0aW9uXG4gICAgICB0cnkge1xuICAgICAgICAvLyBFdmVudC1iYXNlZCBhcHByb2FjaCBmb3Igd29ya2VyIGtlcm5lbHMgb3IgbWFpbiB0aHJlYWQga2VybmVscyB3aXRob3V0IGV4ZWN1dGVTdHJlYW1cbiAgICAgICAgY29uc3Qgc3RyZWFtUXVldWU6IGFueVtdID0gW107XG4gICAgICAgIGxldCBleGVjdXRpb25Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgZXhlY3V0aW9uUmVzdWx0OiB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9ID0geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSBoYW5kbGVyIHJlZmVyZW5jZXMgZm9yIGd1YXJhbnRlZWQgY2xlYW51cFxuICAgICAgICBjb25zdCBldmVudEhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBkYXRhOiBhbnkgfSkgPT4gdm9pZD4oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjbGVhbiB1cCBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgY29uc3QgY2xlYW51cEhhbmRsZXJzID0gKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgW2V2ZW50VHlwZSwgaGFuZGxlcl0gb2YgZXZlbnRIYW5kbGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHN1cGVyLm9mZihldmVudFR5cGUgYXMgYW55LCBoYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnRIYW5kbGVycy5jbGVhcigpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGV4ZWN1dGlvbi1zcGVjaWZpYyBldmVudCBoYW5kbGVycyB0aGF0IGluY2x1ZGUgZXhlY3V0aW9uSWQgY2hlY2tcbiAgICAgICAgY29uc3QgY3JlYXRlSGFuZGxlciA9IChldmVudFR5cGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQ6IHsga2VybmVsSWQ6IHN0cmluZywgZGF0YTogYW55IH0pID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBldmVudHMgZm9yIHRoaXMgc3BlY2lmaWMga2VybmVsIGFuZCB3aGlsZSB0aGlzIGV4ZWN1dGlvbiBpcyBhY3RpdmVcbiAgICAgICAgICAgIGlmIChldmVudC5rZXJuZWxJZCA9PT0ga2VybmVsSWQgJiYgIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIHN0cmVhbVF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbklkIC8vIEluY2x1ZGUgZXhlY3V0aW9uIElEIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBFdmVudHMgYWxzbyBjb3VudCBhcyBhY3Rpdml0eVxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGV2ZW50SGFuZGxlcnMuc2V0KGV2ZW50VHlwZSwgaGFuZGxlcik7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYW5kIHJlZ2lzdGVyIGFsbCBldmVudCBoYW5kbGVyc1xuICAgICAgICBjb25zdCBoYW5kbGVTdHJlYW1FdmVudCA9IGNyZWF0ZUhhbmRsZXIoJ3N0cmVhbScpO1xuICAgICAgICBjb25zdCBoYW5kbGVEaXNwbGF5RXZlbnQgPSBjcmVhdGVIYW5kbGVyKCdkaXNwbGF5X2RhdGEnKTtcbiAgICAgICAgY29uc3QgaGFuZGxlVXBkYXRlRGlzcGxheUV2ZW50ID0gY3JlYXRlSGFuZGxlcigndXBkYXRlX2Rpc3BsYXlfZGF0YScpO1xuICAgICAgICBjb25zdCBoYW5kbGVSZXN1bHRFdmVudCA9IGNyZWF0ZUhhbmRsZXIoJ2V4ZWN1dGVfcmVzdWx0Jyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUVycm9yRXZlbnQgPSBjcmVhdGVIYW5kbGVyKCdleGVjdXRlX2Vycm9yJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWdpc3RlciBoYW5kbGVyc1xuICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuU1RSRUFNLCBoYW5kbGVTdHJlYW1FdmVudCk7XG4gICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5ESVNQTEFZX0RBVEEsIGhhbmRsZURpc3BsYXlFdmVudCk7XG4gICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5VUERBVEVfRElTUExBWV9EQVRBLCBoYW5kbGVVcGRhdGVEaXNwbGF5RXZlbnQpO1xuICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuRVhFQ1VURV9SRVNVTFQsIGhhbmRsZVJlc3VsdEV2ZW50KTtcbiAgICAgICAgc3VwZXIub24oS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIGhhbmRsZUVycm9yRXZlbnQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICBjb25zdCBleGVjdXRpb25Qcm9taXNlID0gbmV3IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIC8vIFNldCB1cCBhIGhhbmRsZXIgZm9yIGV4ZWN1dGlvbiBlcnJvcnMgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgY29uc3QgaGFuZGxlRXhlY3V0aW9uRXJyb3IgPSAoZXZlbnQ6IHsga2VybmVsSWQ6IHN0cmluZywgZGF0YTogYW55IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXJuZWxJZCA9PT0ga2VybmVsSWQgJiYgIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIC8vIE1hcmsgZXhlY3V0aW9uIGFzIGNvbXBsZXRlIHRvIHN0b3AgcHJvY2Vzc2luZyBtb3JlIGV2ZW50c1xuICAgICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgZXJyb3IgZm9yIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICAgICAgZXhlY3V0aW9uUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYCR7ZXZlbnQuZGF0YS5lbmFtZX06ICR7ZXZlbnQuZGF0YS5ldmFsdWV9YCksXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBldmVudC5kYXRhXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHlcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXNvbHZlKGV4ZWN1dGlvblJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgZXJyb3IgaGFuZGxlciB0byBvdXIgY2xlYW51cCBsaXN0XG4gICAgICAgICAgZXZlbnRIYW5kbGVycy5zZXQoJ2V4ZWN1dGVfZXJyb3JfY29tcGxldGlvbicsIGhhbmRsZUV4ZWN1dGlvbkVycm9yKTtcbiAgICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwgaGFuZGxlRXhlY3V0aW9uRXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgYWJvcnRlZFxuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignRXhlY3V0aW9uIHdhcyBhYm9ydGVkJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgdXAgYWJvcnQgaGFuZGxlclxuICAgICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfmqsgRXhlY3V0aW9uICR7ZXhlY3V0aW9uSWR9IGFib3J0ZWRgKTtcbiAgICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignRXhlY3V0aW9uIHdhcyBhYm9ydGVkJylcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBjb2RlXG4gICAgICAgICAgLy8gV2Uga25vdyB0aGUgZXhlY3V0ZSBtZXRob2QgaXMgYXZhaWxhYmxlIGRpcmVjdGx5IG9uIHRoZSBrZXJuZWwgb2JqZWN0XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVQcm9taXNlID0gaW5zdGFuY2Uua2VybmVsLmV4ZWN1dGUoY29kZSwgcGFyZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhlY3V0ZVByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBpZiBleGVjdXRpb24gaGFzbid0IGJlZW4gbWFya2VkIGNvbXBsZXRlIGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKCFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBleGVjdXRpb24gcmVzdWx0IGluZGljYXRlcyBhbiBlcnJvciAoZm9yIFB5dGhvbiBrZXJuZWxzKVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQucmVzdWx0ICYmIHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhcyBlcnJvclxuICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3VsdC5yZXN1bHQuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBlbmFtZTogcmVzdWx0LnJlc3VsdC5lbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVlOiByZXN1bHQucmVzdWx0LmV2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2ViYWNrOiByZXN1bHQucmVzdWx0LnRyYWNlYmFja1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gUHVzaCBlcnJvciB0byBzdHJlYW0gcXVldWUgZGlyZWN0bHkgXG4gICAgICAgICAgICAgICAgICBzdHJlYW1RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZXJyb3JEYXRhLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25JZFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBleGVjdXRpb24gcmVzdWx0IHRvIHJlZmxlY3QgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGAke3Jlc3VsdC5yZXN1bHQuZW5hbWV9OiAke3Jlc3VsdC5yZXN1bHQuZXZhbHVlfWApLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdC5yZXN1bHRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvblJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSB3aGVuIGV4ZWN1dGlvbiBjb21wbGV0ZXNcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXNvbHZlKGV4ZWN1dGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgaWYgZXhlY3V0aW9uIGhhc24ndCBiZWVuIG1hcmtlZCBjb21wbGV0ZSBhbHJlYWR5XG4gICAgICAgICAgICAgIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBleGVjdXRlIGZvciBrZXJuZWwgJHtrZXJuZWxJZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBLZXlib2FyZEludGVycnVwdCBhbmQgaGFuZGxlIGl0IHNwZWNpYWxseVxuICAgICAgICAgICAgICAgIGxldCBlcnJvclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0tleWJvYXJkSW50ZXJydXB0KGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEtleWJvYXJkSW50ZXJydXB0IGNhdWdodCBpbiBleGVjdXRlU3RyZWFtIGZvciBrZXJuZWwgJHtrZXJuZWxJZH1gKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yUmVzdWx0ID0gdGhpcy5jcmVhdGVLZXlib2FyZEludGVycnVwdFJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBBbHNvIHB1c2ggdG8gc3RyZWFtIHF1ZXVlIGZvciBpbW1lZGlhdGUgZmVlZGJhY2tcbiAgICAgICAgICAgICAgICAgIHN0cmVhbVF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBlcnJvclJlc3VsdC5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbklkXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG90aGVyIGVycm9ycyBub3JtYWxseVxuICAgICAgICAgICAgICAgICAgZXJyb3JSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uUmVzdWx0ID0gZXJyb3JSZXN1bHQ7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IGV2ZW4gb24gZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXNvbHZlKGVycm9yUmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBpZiBleGVjdXRpb24gaGFzbid0IGJlZW4gbWFya2VkIGNvbXBsZXRlIGFscmVhZHlcbiAgICAgICAgICAgIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY2FsbGluZyBleGVjdXRlIGZvciBrZXJuZWwgJHtrZXJuZWxJZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU2ltcGxlIGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZXhlY3V0aW9uUmVzdWx0ID0gZXJyb3JSZXN1bHQ7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHkgZXZlbiBvbiBkaXJlY3QgZXJyb3JcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXNvbHZlKGVycm9yUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVXNlIHRyeS9maW5hbGx5IHRvIGd1YXJhbnRlZSBjbGVhbnVwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gTW9uaXRvciB0aGUgc3RyZWFtIHF1ZXVlIGFuZCB5aWVsZCByZXN1bHRzXG4gICAgICAgICAgLy8gQ29udGludWUgdW50aWwgZXhlY3V0aW9uIGlzIGNvbXBsZXRlIEFORCBhbGwgcXVldWVkIGV2ZW50cyBoYXZlIGJlZW4geWllbGRlZFxuICAgICAgICAgIHdoaWxlICgoIWV4ZWN1dGlvbkNvbXBsZXRlIHx8IHN0cmVhbVF1ZXVlLmxlbmd0aCA+IDApICYmICFhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBpdGVtcyBpbiB0aGUgcXVldWUsIHlpZWxkIHRoZW1cbiAgICAgICAgICAgIGlmIChzdHJlYW1RdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gc3RyZWFtUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBubyBtb3JlIGV2ZW50cyBidXQgZXhlY3V0aW9uIGlzIG5vdCBjb21wbGV0ZSwgd2FpdCBhIGxpdHRsZVxuICAgICAgICAgICAgaWYgKCFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAvLyBVc2UgYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgd2FpdFxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApO1xuICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Fib3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhYm9ydGVkLCBicmVhayBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiBleGVjdXRpb24gd2FzIGFib3J0ZWQgZHVyaW5nIHN0cmVhbSBtb25pdG9yaW5nXG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJiAhZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhlY3V0aW9uIHdhcyBhYm9ydGVkIGR1cmluZyBzdHJlYW0gbW9uaXRvcmluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgZmluYWwgcmVzdWx0XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0aW9uUHJvbWlzZTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIEFMV0FZUyBjbGVhbiB1cCBldmVudCBoYW5kbGVycyByZWdhcmRsZXNzIG9mIGhvdyBleGVjdXRpb24gZW5kc1xuICAgICAgICAgIGNsZWFudXBIYW5kbGVycygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBBYm9ydENvbnRyb2xsZXIgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICB0aGlzLnJlbW92ZUFib3J0Q29udHJvbGxlcihrZXJuZWxJZCwgZXhlY3V0aW9uSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENvbXBsZXRlIGV4ZWN1dGlvbiB0cmFja2luZ1xuICAgICAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gQ29tcGxldGUgZXhlY3V0aW9uIHRyYWNraW5nIG9uIGFueSBvdXRlciBlcnJvclxuICAgICAgICB0aGlzLmNvbXBsZXRlRXhlY3V0aW9uKGtlcm5lbElkLCBleGVjdXRpb25JZCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmVycm9yKGBVbmV4cGVjdGVkIGVycm9yIGluIGV4ZWN1dGVTdHJlYW06YCwgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIENvbXBsZXRlIGV4ZWN1dGlvbiB0cmFja2luZyBvbiBhbnkgb3V0ZXIgZXJyb3JcbiAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5lcnJvcihgVW5leHBlY3RlZCBlcnJvciBpbiBleGVjdXRlU3RyZWFtOmAsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhY2sgYSBuZXcgZXhlY3V0aW9uIHRhc2sgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGNvZGUgT3B0aW9uYWwgY29kZSBiZWluZyBleGVjdXRlZCBmb3IgbWV0YWRhdGFcbiAgICogQHJldHVybnMgVW5pcXVlIGV4ZWN1dGlvbiBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSB0cmFja0V4ZWN1dGlvbihrZXJuZWxJZDogc3RyaW5nLCBjb2RlPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBDcmVhdGUgYSB1bmlxdWUgZXhlY3V0aW9uIElEXG4gICAgY29uc3QgZXhlY3V0aW9uSWQgPSBgZXhlYy0ke2NyeXB0by5yYW5kb21VVUlEKCl9YDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIFJlc2V0IGludGVycnVwdCBidWZmZXIgZm9yIHdvcmtlciBrZXJuZWxzIGJlZm9yZSBlYWNoIG5ldyBleGVjdXRpb25cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIGtlcm5lbCBjYW4gYmUgaW50ZXJydXB0ZWQgbXVsdGlwbGUgdGltZXNcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpO1xuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5tb2RlID09PSBLZXJuZWxNb2RlLldPUktFUiAmJiB0aGlzLmludGVycnVwdEJ1ZmZlcnMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgY29uc3QgaW50ZXJydXB0QnVmZmVyID0gdGhpcy5pbnRlcnJ1cHRCdWZmZXJzLmdldChrZXJuZWxJZCkhO1xuICAgICAgLy8gUmVzZXQgYnVmZmVyIHRvIDAgKG5vIGludGVycnVwdCBzaWduYWwpIHRvIGVuc3VyZSBjbGVhbiBzdGF0ZVxuICAgICAgaW50ZXJydXB0QnVmZmVyWzBdID0gMDtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IG9yIGNyZWF0ZSB0aGUgc2V0IG9mIG9uZ29pbmcgZXhlY3V0aW9ucyBmb3IgdGhpcyBrZXJuZWxcbiAgICBpZiAoIXRoaXMub25nb2luZ0V4ZWN1dGlvbnMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5zZXQoa2VybmVsSWQsIG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB0aGlzIGV4ZWN1dGlvbiB0byB0aGUgc2V0XG4gICAgdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoa2VybmVsSWQpIS5hZGQoZXhlY3V0aW9uSWQpO1xuICAgIFxuICAgIC8vIFRyYWNrIGV4ZWN1dGlvbiBzdGFydCB0aW1lXG4gICAgaWYgKCF0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLnNldChrZXJuZWxJZCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmdldChrZXJuZWxJZCkhLnNldChleGVjdXRpb25JZCwgc3RhcnRUaW1lKTtcbiAgICBcbiAgICAvLyBUcmFjayBleGVjdXRpb24gbWV0YWRhdGFcbiAgICBpZiAoIXRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhpcy5leGVjdXRpb25NZXRhZGF0YS5zZXQoa2VybmVsSWQsIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSB0aW1lc3RhbXBcbiAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICBcbiAgICAvLyBJZiBtYXhFeGVjdXRpb25UaW1lIGlzIHNldCwgY3JlYXRlIGEgdGltZW91dCB0byBkZXRlY3Qgc3R1Y2svZGVhZCBrZXJuZWxzXG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSAmJiBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgPiAwKSB7XG4gICAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBtYXAgb2YgZXhlY3V0aW9uIHRpbWVvdXRzIGZvciB0aGlzIGtlcm5lbFxuICAgICAgaWYgKCF0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgICAgdGhpcy5leGVjdXRpb25UaW1lb3V0cy5zZXQoa2VybmVsSWQsIG5ldyBNYXAoKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldCBhIHRpbWVvdXQgZm9yIHRoaXMgZXhlY3V0aW9uIHdpdGggZW5oYW5jZWQgaGFuZGxpbmdcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oYEV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfSBvbiBrZXJuZWwgJHtrZXJuZWxJZH0gaGFzIGJlZW4gcnVubmluZyBmb3IgJHtpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWV9bXMgYW5kIG1heSBiZSBzdHVjay9kZWFkLmApO1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGV4ZWN1dGlvbiBtZXRhZGF0YSBmb3IgYmV0dGVyIGVycm9yIHJlcG9ydGluZ1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZ2V0KGtlcm5lbElkKT8uZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICAgICAgY29uc3QgYWN0dWFsUnVudGltZSA9IERhdGUubm93KCkgLSAobWV0YWRhdGE/LnN0YXJ0VGltZSB8fCBzdGFydFRpbWUpO1xuICAgICAgICBcbiAgICAgICAgLy8gRW1pdCBhIHN0YWxsZWQgZXhlY3V0aW9uIGV2ZW50IHdpdGggZW5oYW5jZWQgaW5mb3JtYXRpb25cbiAgICAgICAgc3VwZXIuZW1pdCgnZXhlY3V0aW9uX3N0YWxsZWQnLCB7XG4gICAgICAgICAga2VybmVsSWQsXG4gICAgICAgICAgZXhlY3V0aW9uSWQsXG4gICAgICAgICAgbWF4RXhlY3V0aW9uVGltZTogaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lLFxuICAgICAgICAgIGFjdHVhbFJ1bnRpbWUsXG4gICAgICAgICAgY29kZTogbWV0YWRhdGE/LmNvZGUgfHwgY29kZSxcbiAgICAgICAgICBzdGFydFRpbWU6IG1ldGFkYXRhPy5zdGFydFRpbWUgfHwgc3RhcnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQXV0by1oYW5kbGUgc3R1Y2sgZXhlY3V0aW9uIGlmIGNvbmZpZ3VyZWRcbiAgICAgICAgdGhpcy5oYW5kbGVTdHVja0V4ZWN1dGlvbihrZXJuZWxJZCwgZXhlY3V0aW9uSWQsIGFjdHVhbFJ1bnRpbWUsIG1ldGFkYXRhPy5jb2RlIHx8IGNvZGUpO1xuICAgICAgfSwgaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lKTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgdGhlIHRpbWVvdXQgSURcbiAgICAgIHRoaXMuZXhlY3V0aW9uVGltZW91dHMuZ2V0KGtlcm5lbElkKSEuc2V0KGV4ZWN1dGlvbklkLCB0aW1lb3V0SWQpO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSBtZXRhZGF0YSBpbmNsdWRpbmcgdGltZW91dCBJRFxuICAgICAgdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoa2VybmVsSWQpIS5zZXQoZXhlY3V0aW9uSWQsIHtcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICBjb2RlLFxuICAgICAgICB0aW1lb3V0SWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdG9yZSBtZXRhZGF0YSB3aXRob3V0IHRpbWVvdXQgSURcbiAgICAgIHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZ2V0KGtlcm5lbElkKSEuc2V0KGV4ZWN1dGlvbklkLCB7XG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgY29kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBleGVjdXRpb25JZDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENvbXBsZXRlIHRyYWNraW5nIGZvciBhbiBleGVjdXRpb25cbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gZXhlY3V0aW9uSWQgRXhlY3V0aW9uIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNvbXBsZXRlRXhlY3V0aW9uKGtlcm5lbElkOiBzdHJpbmcsIGV4ZWN1dGlvbklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBDbGVhciBhbnkgZXhlY3V0aW9uIHRpbWVvdXRcbiAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lb3V0cy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICBjb25zdCB0aW1lb3V0cyA9IHRoaXMuZXhlY3V0aW9uVGltZW91dHMuZ2V0KGtlcm5lbElkKSE7XG4gICAgICBpZiAodGltZW91dHMuaGFzKGV4ZWN1dGlvbklkKSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dHMuZ2V0KGV4ZWN1dGlvbklkKSk7XG4gICAgICAgIHRpbWVvdXRzLmRlbGV0ZShleGVjdXRpb25JZCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIGVtcHR5IG1hcHNcbiAgICAgIGlmICh0aW1lb3V0cy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uVGltZW91dHMuZGVsZXRlKGtlcm5lbElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhlY3V0aW9uIHN0YXJ0IHRpbWVzXG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWVzID0gdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmdldChrZXJuZWxJZCkhO1xuICAgICAgc3RhcnRUaW1lcy5kZWxldGUoZXhlY3V0aW9uSWQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCBlbXB0eSBtYXBzXG4gICAgICBpZiAoc3RhcnRUaW1lcy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5kZWxldGUoa2VybmVsSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleGVjdXRpb24gbWV0YWRhdGFcbiAgICBpZiAodGhpcy5leGVjdXRpb25NZXRhZGF0YS5oYXMoa2VybmVsSWQpKSB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZ2V0KGtlcm5lbElkKSE7XG4gICAgICBtZXRhZGF0YS5kZWxldGUoZXhlY3V0aW9uSWQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCBlbXB0eSBtYXBzXG4gICAgICBpZiAobWV0YWRhdGEuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIG9uZ29pbmcgZXhlY3V0aW9uc1xuICAgIGlmICh0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGlvbnMgPSB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChrZXJuZWxJZCkhO1xuICAgICAgZXhlY3V0aW9ucy5kZWxldGUoZXhlY3V0aW9uSWQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCBlbXB0eSBzZXRzXG4gICAgICBpZiAoZXhlY3V0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZGVsZXRlKGtlcm5lbElkKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSB0aW1lc3RhbXAgZm9yIGNvbXBsZXRlZCBleGVjdXRpb25cbiAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXJuZWwgaGFzIGFueSBvbmdvaW5nIGV4ZWN1dGlvbnNcbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXJuZWwgaGFzIG9uZ29pbmcgZXhlY3V0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBoYXNPbmdvaW5nRXhlY3V0aW9ucyhrZXJuZWxJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuaGFzKGtlcm5lbElkKSAmJiBcbiAgICAgICAgICAgdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoa2VybmVsSWQpIS5zaXplID4gMDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgY291bnQgb2Ygb25nb2luZyBleGVjdXRpb25zIGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIE51bWJlciBvZiBvbmdvaW5nIGV4ZWN1dGlvbnNcbiAgICovXG4gIHB1YmxpYyBnZXRPbmdvaW5nRXhlY3V0aW9uQ291bnQoaWQ6IHN0cmluZyk6IG51bWJlciB7XG4gICAgaWYgKCF0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmhhcyhpZCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoaWQpIS5zaXplO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0IHVwIGFuIGluYWN0aXZpdHkgdGltZW91dCBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gdGltZW91dCBUaW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkOiBzdHJpbmcsIHRpbWVvdXQ6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIERvbid0IHNldCB1cCBhIHRpbWVyIGlmIHRpbWVvdXQgaXMgMCBvciBuZWdhdGl2ZVxuICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQWx3YXlzIGNsZWFyIGFueSBleGlzdGluZyB0aW1lciBmaXJzdFxuICAgIHRoaXMuY2xlYXJJbmFjdGl2aXR5VGltZW91dChpZCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHJlbWFpbmluZyB0aW1lIGJhc2VkIG9uIGxhc3QgYWN0aXZpdHlcbiAgICBjb25zdCBsYXN0QWN0aXZpdHkgPSB0aGlzLmxhc3RBY3Rpdml0eVRpbWUuZ2V0KGlkKSB8fCBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gbGFzdEFjdGl2aXR5O1xuICAgIGNvbnN0IHJlbWFpbmluZ1RpbWUgPSBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZWxhcHNlZCk7XG4gICAgXG4gICAgLy8gSWYgbm8gdGltZSByZW1haW5pbmcsIGRlc3Ryb3kgaW1tZWRpYXRlbHlcbiAgICBpZiAocmVtYWluaW5nVGltZSA9PT0gMCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGtlcm5lbCBoYXMgb25nb2luZyBleGVjdXRpb25zIGJlZm9yZSBzaHV0dGluZyBkb3duXG4gICAgICBpZiAodGhpcy5oYXNPbmdvaW5nRXhlY3V0aW9ucyhpZCkpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRpbWVyIHRvIGNoZWNrIGFnYWluIGxhdGVyXG4gICAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgdGltZW91dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGVzdHJveSBpbW1lZGlhdGVseVxuICAgICAgdGhpcy5kZXN0cm95S2VybmVsKGlkKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlc3Ryb3lpbmcgaW5hY3RpdmUga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgYSB0aW1lciB0byBkZXN0cm95IHRoZSBrZXJuZWwgYWZ0ZXIgdGhlIHJlbWFpbmluZyB0aW1lb3V0XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBrZXJuZWwgaGFzIG9uZ29pbmcgZXhlY3V0aW9ucyBiZWZvcmUgc2h1dHRpbmcgZG93blxuICAgICAgaWYgKHRoaXMuaGFzT25nb2luZ0V4ZWN1dGlvbnMoaWQpKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0aW1lciB0byBjaGVjayBhZ2FpbiBsYXRlclxuICAgICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIHRpbWVvdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuZGVzdHJveUtlcm5lbChpZCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZXN0cm95aW5nIGluYWN0aXZlIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICB9KTtcbiAgICB9LCByZW1haW5pbmdUaW1lKTtcbiAgICBcbiAgICAvLyBTdG9yZSB0aGUgdGltZXIgSURcbiAgICB0aGlzLmluYWN0aXZpdHlUaW1lcnMuc2V0KGlkLCB0aW1lcik7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDbGVhciBhbnkgZXhpc3RpbmcgaW5hY3Rpdml0eSB0aW1lb3V0IGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNsZWFySW5hY3Rpdml0eVRpbWVvdXQoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmluYWN0aXZpdHlUaW1lcnMuaGFzKGlkKSkge1xuICAgICAgY29uc3QgdGltZXJJZCA9IHRoaXMuaW5hY3Rpdml0eVRpbWVycy5nZXQoaWQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgdGhpcy5pbmFjdGl2aXR5VGltZXJzLmRlbGV0ZShpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhY3Rpdml0eSB0aW1lc3RhbXAgZm9yIGEga2VybmVsIGFuZCByZXNldCBpbmFjdGl2aXR5IHRpbWVyIGlmIHByZXNlbnRcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVLZXJuZWxBY3Rpdml0eShpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIHRoZSBsYXN0IGFjdGl2aXR5IHRpbWVcbiAgICB0aGlzLmxhc3RBY3Rpdml0eVRpbWUuc2V0KGlkLCBEYXRlLm5vdygpKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGtlcm5lbCBvcHRpb25zXG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdGltZW91dCA9IGluc3RhbmNlLm9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgXG4gICAgLy8gUmVzZXQgdGhlIGluYWN0aXZpdHkgdGltZXIgaWYgdGltZW91dCBpcyBlbmFibGVkIChncmVhdGVyIHRoYW4gMClcbiAgICBpZiAodGltZW91dCAmJiB0aW1lb3V0ID4gMCkge1xuICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCB0aW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IGFjdGl2aXR5IHRpbWUgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgTGFzdCBhY3Rpdml0eSB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCwgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIGdldExhc3RBY3Rpdml0eVRpbWUoaWQ6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubGFzdEFjdGl2aXR5VGltZS5nZXQoaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5hY3Rpdml0eSB0aW1lb3V0IGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIEluYWN0aXZpdHkgdGltZW91dCBpbiBtaWxsaXNlY29uZHMsIG9yIHVuZGVmaW5lZCBpZiBub3Qgc2V0XG4gICAqL1xuICBwdWJsaWMgZ2V0SW5hY3Rpdml0eVRpbWVvdXQoaWQ6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIHJldHVybiBpbnN0YW5jZS5vcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvciB1cGRhdGUgdGhlIGluYWN0aXZpdHkgdGltZW91dCBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gdGltZW91dCBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcywgb3IgMCB0byBkaXNhYmxlXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRpbWVvdXQgd2FzIHNldCwgZmFsc2UgaWYgdGhlIGtlcm5lbCB3YXMgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgc2V0SW5hY3Rpdml0eVRpbWVvdXQoaWQ6IHN0cmluZywgdGltZW91dDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gVXBkYXRlIHRoZSB0aW1lb3V0IGluIHRoZSBvcHRpb25zXG4gICAgaW5zdGFuY2Uub3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCA9IHRpbWVvdXQ7XG4gICAgXG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyXG4gICAgdGhpcy5jbGVhckluYWN0aXZpdHlUaW1lb3V0KGlkKTtcbiAgICBcbiAgICAvLyBJZiB0aW1lb3V0IGlzIGdyZWF0ZXIgdGhhbiAwLCBzZXQgdXAgYSBuZXcgdGltZXJcbiAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgdGltZW91dCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aW1lIHVudGlsIGF1dG8tc2h1dGRvd24gZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgVGltZSBpbiBtaWxsaXNlY29uZHMgdW50aWwgYXV0by1zaHV0ZG93biwgb3IgdW5kZWZpbmVkIGlmIG5vIHRpbWVvdXQgaXMgc2V0XG4gICAqL1xuICBwdWJsaWMgZ2V0VGltZVVudGlsU2h1dGRvd24oaWQ6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIGNvbnN0IHRpbWVvdXQgPSBpbnN0YW5jZS5vcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0O1xuICAgIGlmICghdGltZW91dCB8fCB0aW1lb3V0IDw9IDApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgY29uc3QgbGFzdEFjdGl2aXR5ID0gdGhpcy5sYXN0QWN0aXZpdHlUaW1lLmdldChpZCk7XG4gICAgaWYgKCFsYXN0QWN0aXZpdHkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBEYXRlLm5vdygpIC0gbGFzdEFjdGl2aXR5O1xuICAgIGNvbnN0IHJlbWFpbmluZ1RpbWUgPSB0aW1lb3V0IC0gZWxhcHNlZFRpbWU7XG4gICAgXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHJlbWFpbmluZ1RpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIG9mIGluYWN0aXZpdHkgdGltZXJzIChmb3IgZGVidWdnaW5nL3Rlc3Rpbmcgb25seSlcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGgga2VybmVsIElEcyBhcyBrZXlzIGFuZCB0aW1lciBJRHMgYXMgdmFsdWVzXG4gICAqL1xuICBwdWJsaWMgZ2V0SW5hY3Rpdml0eVRpbWVycygpOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHtcbiAgICAvLyBDb252ZXJ0IE1hcCB0byBPYmplY3QgZm9yIGVhc2llciBpbnNwZWN0aW9uXG4gICAgY29uc3QgdGltZXJzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgdGhpcy5pbmFjdGl2aXR5VGltZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRpbWVyc1trZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRpbWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYSBoYW5kbGVyIGZvciBzdGFsbGVkIGV4ZWN1dGlvbnNcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cFN0YWxsZWRFeGVjdXRpb25IYW5kbGVyKGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBMaXN0ZW4gZm9yIHN0YWxsZWQgZXhlY3V0aW9uIGV2ZW50c1xuICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5FWEVDVVRJT05fU1RBTExFRCwgKGV2ZW50OiB7IGtlcm5lbElkOiBzdHJpbmcsIGV4ZWN1dGlvbklkOiBzdHJpbmcsIG1heEV4ZWN1dGlvblRpbWU6IG51bWJlciB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQua2VybmVsSWQgPT09IGlkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSGFuZGxpbmcgc3RhbGxlZCBleGVjdXRpb24gJHtldmVudC5leGVjdXRpb25JZH0gb24ga2VybmVsICR7aWR9IChydW5uaW5nIGxvbmdlciB0aGFuICR7ZXZlbnQubWF4RXhlY3V0aW9uVGltZX1tcylgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEVtaXQgYW4gZXZlbnQgZm9yIGNsaWVudHMgdG8gaGFuZGxlXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIHtcbiAgICAgICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgZW5hbWU6IFwiRXhlY3V0aW9uU3RhbGxlZEVycm9yXCIsXG4gICAgICAgICAgICAgIGV2YWx1ZTogYEV4ZWN1dGlvbiBzdGFsbGVkIG9yIHBvdGVudGlhbGx5IGRlYWRsb2NrZWQgKHJ1bm5pbmcgPiAke2V2ZW50Lm1heEV4ZWN1dGlvblRpbWV9bXMpYCxcbiAgICAgICAgICAgICAgdHJhY2ViYWNrOiBbXCJFeGVjdXRpb24gbWF5IGJlIHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3Agb3IgZGVhZGxvY2tlZC5cIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIHRlcm1pbmF0ZSBhIHBvdGVudGlhbGx5IHN0dWNrIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSByZWFzb24gT3B0aW9uYWwgcmVhc29uIGZvciB0ZXJtaW5hdGlvblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIHRoZSBrZXJuZWwgd2FzIHRlcm1pbmF0ZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBmb3JjZVRlcm1pbmF0ZUtlcm5lbChpZDogc3RyaW5nLCByZWFzb24gPSBcIkZvcmNlIHRlcm1pbmF0ZWQgZHVlIHRvIHN0YWxsZWQgZXhlY3V0aW9uXCIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIFxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIExvZyB0aGUgZm9yY2VkIHRlcm1pbmF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oYEZvcmNlIHRlcm1pbmF0aW5nIGtlcm5lbCAke2lkfTogJHtyZWFzb259YCk7XG4gICAgICBcbiAgICAgIC8vIEVtaXQgYW4gZXJyb3IgZXZlbnQgdG8gbm90aWZ5IGNsaWVudHNcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIHtcbiAgICAgICAga2VybmVsSWQ6IGlkLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hbWU6IFwiS2VybmVsRm9yY2VkVGVybWluYXRpb25cIixcbiAgICAgICAgICBldmFsdWU6IHJlYXNvbixcbiAgICAgICAgICB0cmFjZWJhY2s6IFtcIktlcm5lbCB3YXMgZm9yY2VmdWxseSB0ZXJtaW5hdGVkIGJ5IHRoZSBzeXN0ZW0uXCJdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBEZXN0cm95IHRoZSBrZXJuZWxcbiAgICAgIGF3YWl0IHRoaXMuZGVzdHJveUtlcm5lbChpZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZHVyaW5nIGZvcmNlZCB0ZXJtaW5hdGlvbiBvZiBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgb25nb2luZyBleGVjdXRpb25zIGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIEluZm9ybWF0aW9uIGFib3V0IG9uZ29pbmcgZXhlY3V0aW9ucyB3aXRoIGFjY3VyYXRlIHRpbWluZ1xuICAgKi9cbiAgcHVibGljIGdldEV4ZWN1dGlvbkluZm8oaWQ6IHN0cmluZyk6IHsgXG4gICAgY291bnQ6IG51bWJlcjsgXG4gICAgaXNTdHVjazogYm9vbGVhbjsgXG4gICAgZXhlY3V0aW9uSWRzOiBzdHJpbmdbXTtcbiAgICBsb25nZXN0UnVubmluZ1RpbWU/OiBudW1iZXI7XG4gICAgZXhlY3V0aW9uczogQXJyYXk8e1xuICAgICAgaWQ6IHN0cmluZztcbiAgICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgICAgcnVudGltZTogbnVtYmVyO1xuICAgICAgY29kZT86IHN0cmluZztcbiAgICAgIGlzU3R1Y2s6IGJvb2xlYW47XG4gICAgfT47XG4gIH0ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIHsgY291bnQ6IDAsIGlzU3R1Y2s6IGZhbHNlLCBleGVjdXRpb25JZHM6IFtdLCBleGVjdXRpb25zOiBbXSB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgcGFydGlhbGx5IGluaXRpYWxpemVkIGtlcm5lbHMgd2hlcmUgb3B0aW9ucyBtYXkgbm90IGJlIGZ1bGx5IHNldFxuICAgIGlmICghaW5zdGFuY2Uub3B0aW9ucykge1xuICAgICAgcmV0dXJuIHsgY291bnQ6IDAsIGlzU3R1Y2s6IGZhbHNlLCBleGVjdXRpb25JZHM6IFtdLCBleGVjdXRpb25zOiBbXSB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBleGVjdXRpb25JZHMgPSB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChpZCkgXG4gICAgICA/IEFycmF5LmZyb20odGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoaWQpISlcbiAgICAgIDogW107XG4gICAgXG4gICAgY29uc3QgY291bnQgPSBleGVjdXRpb25JZHMubGVuZ3RoO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBtYXhFeGVjdXRpb25UaW1lID0gaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lO1xuICAgIFxuICAgIC8vIEJ1aWxkIGRldGFpbGVkIGV4ZWN1dGlvbiBpbmZvcm1hdGlvblxuICAgIGNvbnN0IGV4ZWN1dGlvbnM6IEFycmF5PHtcbiAgICAgIGlkOiBzdHJpbmc7XG4gICAgICBzdGFydFRpbWU6IG51bWJlcjtcbiAgICAgIHJ1bnRpbWU6IG51bWJlcjtcbiAgICAgIGNvZGU/OiBzdHJpbmc7XG4gICAgICBpc1N0dWNrOiBib29sZWFuO1xuICAgIH0+ID0gW107XG4gICAgXG4gICAgbGV0IGxvbmdlc3RSdW5uaW5nVGltZTogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGxldCBhbnlTdHVjayA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEdldCBleGVjdXRpb24gc3RhcnQgdGltZXMgYW5kIG1ldGFkYXRhXG4gICAgY29uc3Qgc3RhcnRUaW1lcyA9IHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5nZXQoaWQpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoaWQpO1xuICAgIFxuICAgIGZvciAoY29uc3QgZXhlY3V0aW9uSWQgb2YgZXhlY3V0aW9uSWRzKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBzdGFydFRpbWVzPy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgICAgY29uc3QgZXhlY01ldGFkYXRhID0gbWV0YWRhdGE/LmdldChleGVjdXRpb25JZCk7XG4gICAgICBcbiAgICAgIGlmIChzdGFydFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBydW50aW1lID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IGlzU3R1Y2sgPSBtYXhFeGVjdXRpb25UaW1lICE9PSB1bmRlZmluZWQgJiYgcnVudGltZSA+IG1heEV4ZWN1dGlvblRpbWU7XG4gICAgICAgIFxuICAgICAgICBleGVjdXRpb25zLnB1c2goe1xuICAgICAgICAgIGlkOiBleGVjdXRpb25JZCxcbiAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgcnVudGltZSxcbiAgICAgICAgICBjb2RlOiBleGVjTWV0YWRhdGE/LmNvZGUsXG4gICAgICAgICAgaXNTdHVja1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyYWNrIGxvbmdlc3QgcnVubmluZyB0aW1lXG4gICAgICAgIGlmIChsb25nZXN0UnVubmluZ1RpbWUgPT09IHVuZGVmaW5lZCB8fCBydW50aW1lID4gbG9uZ2VzdFJ1bm5pbmdUaW1lKSB7XG4gICAgICAgICAgbG9uZ2VzdFJ1bm5pbmdUaW1lID0gcnVudGltZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVHJhY2sgaWYgYW55IGV4ZWN1dGlvbiBpcyBzdHVja1xuICAgICAgICBpZiAoaXNTdHVjaykge1xuICAgICAgICAgIGFueVN0dWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgZm9yIGV4ZWN1dGlvbnMgd2l0aG91dCBzdGFydCB0aW1lIHRyYWNraW5nXG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gc3RhcnQgdGltZSBmb3VuZCBmb3IgZXhlY3V0aW9uICR7ZXhlY3V0aW9uSWR9IG9uIGtlcm5lbCAke2lkfWApO1xuICAgICAgICBleGVjdXRpb25zLnB1c2goe1xuICAgICAgICAgIGlkOiBleGVjdXRpb25JZCxcbiAgICAgICAgICBzdGFydFRpbWU6IDAsXG4gICAgICAgICAgcnVudGltZTogMCxcbiAgICAgICAgICBjb2RlOiBleGVjTWV0YWRhdGE/LmNvZGUsXG4gICAgICAgICAgaXNTdHVjazogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNvcnQgZXhlY3V0aW9ucyBieSBzdGFydCB0aW1lIChvbGRlc3QgZmlyc3QpXG4gICAgZXhlY3V0aW9ucy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0VGltZSAtIGIuc3RhcnRUaW1lKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQsXG4gICAgICBpc1N0dWNrOiBhbnlTdHVjayxcbiAgICAgIGV4ZWN1dGlvbklkcyxcbiAgICAgIGxvbmdlc3RSdW5uaW5nVGltZSxcbiAgICAgIGV4ZWN1dGlvbnNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgUHl0aG9uIGNvZGUgaW4gYSBrZXJuZWxcbiAgICogT3ZlcnJpZGVzIHRoZSBrZXJuZWwncyBleGVjdXRlIG1ldGhvZCB0byB0cmFjayBleGVjdXRpb25zXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBJRCBvZiB0aGUga2VybmVsIHRvIHVzZVxuICAgKiBAcGFyYW0gY29kZSBQeXRob24gY29kZSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBwYXJlbnQgT3B0aW9uYWwgcGFyZW50IG1lc3NhZ2UgaGVhZGVyXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGV4ZWN1dGlvbiByZXN1bHRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBleGVjdXRlKFxuICAgIGtlcm5lbElkOiBzdHJpbmcsXG4gICAgY29kZTogc3RyaW5nLFxuICAgIHBhcmVudDogYW55ID0ge31cbiAgKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldEtlcm5lbChrZXJuZWxJZCk7XG4gICAgXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgd2l0aCBJRCAke2tlcm5lbElkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIGtlcm5lbCBhY3Rpdml0eVxuICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgIFxuICAgIC8vIFRyYWNrIHRoaXMgZXhlY3V0aW9uIHdpdGggdGhlIGNvZGUgZm9yIGJldHRlciBtb25pdG9yaW5nXG4gICAgY29uc3QgZXhlY3V0aW9uSWQgPSB0aGlzLnRyYWNrRXhlY3V0aW9uKGtlcm5lbElkLCBjb2RlKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gRXhlY3V0ZSB0aGUgY29kZVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaW5zdGFuY2Uua2VybmVsLmV4ZWN1dGUoY29kZSwgcGFyZW50KTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IGFmdGVyIGV4ZWN1dGlvbiBjb21wbGV0ZXNcbiAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgXG4gICAgICAvLyBDb21wbGV0ZSBleGVjdXRpb24gdHJhY2tpbmdcbiAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IGV2ZW4gaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICBcbiAgICAgIC8vIENvbXBsZXRlIGV4ZWN1dGlvbiB0cmFja2luZyBldmVuIG9uIGVycm9yXG4gICAgICB0aGlzLmNvbXBsZXRlRXhlY3V0aW9uKGtlcm5lbElkLCBleGVjdXRpb25JZCk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtlcm5lbCB0eXBlIGlzIGFsbG93ZWRcbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXJuZWwgdHlwZSBpcyBhbGxvd2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGlzS2VybmVsVHlwZUFsbG93ZWQobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZEtlcm5lbFR5cGVzLnNvbWUodHlwZSA9PiBcbiAgICAgIHR5cGUubW9kZSA9PT0gbW9kZSAmJiB0eXBlLmxhbmd1YWdlID09PSBsYW5ndWFnZVxuICAgICk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgYWxsb3dlZCBrZXJuZWwgdHlwZXNcbiAgICogQHJldHVybnMgQXJyYXkgb2YgYWxsb3dlZCBrZXJuZWwgdHlwZSBjb25maWd1cmF0aW9uc1xuICAgKi9cbiAgcHVibGljIGdldEFsbG93ZWRLZXJuZWxUeXBlcygpOiBBcnJheTx7XG4gICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gIH0+IHtcbiAgICByZXR1cm4gWy4uLnRoaXMuYWxsb3dlZEtlcm5lbFR5cGVzXTsgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IG1vZGlmaWNhdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIFBpbmcgYSBrZXJuZWwgdG8gcmVzZXQgaXRzIGFjdGl2aXR5IHRpbWVyIGFuZCBleHRlbmQgdGhlIGRlYWRsaW5lXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2VybmVsIHdhcyBwaW5nZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBub3QgZm91bmRcbiAgICovXG4gIHB1YmxpYyBwaW5nS2VybmVsKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIGtlcm5lbCBhY3Rpdml0eSAodGhpcyB3aWxsIHJlc2V0IHRoZSBpbmFjdGl2aXR5IHRpbWVyKVxuICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoaWQpO1xuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RhcnQgYSBrZXJuZWwgYnkgZGVzdHJveWluZyBpdCBhbmQgY3JlYXRpbmcgYSBuZXcgb25lIHdpdGggdGhlIHNhbWUgSUQgYW5kIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIHRoZSBrZXJuZWwgd2FzIHJlc3RhcnRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlc3RhcnRLZXJuZWwoaWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgcmVzdGFydCBrZXJuZWwgJHtpZH06IGtlcm5lbCBub3QgZm91bmRgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb25cbiAgICAgIGNvbnN0IGN1cnJlbnRDb25maWcgPSB7XG4gICAgICAgIG1vZGU6IGluc3RhbmNlLm1vZGUsXG4gICAgICAgIGxhbmd1YWdlOiBpbnN0YW5jZS5sYW5ndWFnZSxcbiAgICAgICAgb3B0aW9uczogeyAuLi5pbnN0YW5jZS5vcHRpb25zIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgbmFtZXNwYWNlIGZyb20gSUQgaWYgcHJlc2VudFxuICAgICAgbGV0IG5hbWVzcGFjZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgbGV0IGJhc2VJZDogc3RyaW5nO1xuICAgICAgXG4gICAgICBpZiAoaWQuaW5jbHVkZXMoJzonKSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGlkLnNwbGl0KCc6Jyk7XG4gICAgICAgIG5hbWVzcGFjZSA9IHBhcnRzWzBdO1xuICAgICAgICBiYXNlSWQgPSBwYXJ0c1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VJZCA9IGlkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZXN0cm95IHRoZSBleGlzdGluZyBrZXJuZWxcbiAgICAgIGF3YWl0IHRoaXMuZGVzdHJveUtlcm5lbChpZCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBrZXJuZWwgd2l0aCB0aGUgc2FtZSBjb25maWd1cmF0aW9uXG4gICAgICBjb25zdCByZXN0YXJ0T3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zID0ge1xuICAgICAgICBpZDogYmFzZUlkLFxuICAgICAgICBtb2RlOiBjdXJyZW50Q29uZmlnLm1vZGUsXG4gICAgICAgIGxhbmc6IGN1cnJlbnRDb25maWcubGFuZ3VhZ2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgZGVubzogY3VycmVudENvbmZpZy5vcHRpb25zLmRlbm8sXG4gICAgICAgIGZpbGVzeXN0ZW06IGN1cnJlbnRDb25maWcub3B0aW9ucy5maWxlc3lzdGVtLFxuICAgICAgICBpbmFjdGl2aXR5VGltZW91dDogY3VycmVudENvbmZpZy5vcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICBtYXhFeGVjdXRpb25UaW1lOiBjdXJyZW50Q29uZmlnLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcga2VybmVsXG4gICAgICBjb25zdCBuZXdLZXJuZWxJZCA9IGF3YWl0IHRoaXMuY3JlYXRlS2VybmVsKHJlc3RhcnRPcHRpb25zKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHRoZSBuZXcga2VybmVsIGhhcyB0aGUgc2FtZSBJRFxuICAgICAgaWYgKG5ld0tlcm5lbElkICE9PSBpZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBLZXJuZWwgcmVzdGFydCBmYWlsZWQ6IGV4cGVjdGVkIElEICR7aWR9LCBnb3QgJHtuZXdLZXJuZWxJZH1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZXN0YXJ0aW5nIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVycnVwdCBhIHJ1bm5pbmcga2VybmVsIGV4ZWN1dGlvblxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgdGhlIGludGVycnVwdCB3YXMgc3VjY2Vzc2Z1bCwgZmFsc2UgaWYgbm90IGZvdW5kIG9yIGZhaWxlZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGludGVycnVwdEtlcm5lbChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBpbnRlcnJ1cHQga2VybmVsICR7aWR9OiBrZXJuZWwgbm90IGZvdW5kYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBpZiAoaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5XT1JLRVIgJiYgaW5zdGFuY2Uud29ya2VyKSB7XG4gICAgICAgIC8vIEZvciB3b3JrZXIga2VybmVscywgdXNlIFNoYXJlZEFycmF5QnVmZmVyIGludGVycnVwdCBtZXRob2RcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW50ZXJydXB0V29ya2VyS2VybmVsKGlkLCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgbWFpbiB0aHJlYWQga2VybmVscywgdHJ5IHRvIGludGVycnVwdCAod2lsbCB0aHJvdyBlcnJvciBpZiBub3Qgc3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbnRlcnJ1cHRNYWluVGhyZWFkS2VybmVsKGlkLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGludGVycnVwdGluZyBrZXJuZWwgJHtpZH06YCwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbnRlcnJ1cHQgYSBtYWluIHRocmVhZCBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gaW5zdGFuY2UgS2VybmVsIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGludGVycnVwdCBzdWNjZXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGludGVycnVwdE1haW5UaHJlYWRLZXJuZWwoaWQ6IHN0cmluZywgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIC8vIE1haW4gdGhyZWFkIGtlcm5lbHMgZG9uJ3Qgc3VwcG9ydCBwcm9wZXIgaW50ZXJydXB0aW9uIGxpa2Ugd29ya2VyIGtlcm5lbHMgZG9cbiAgICAvLyBFdmVuIGlmIHRoZXkgaGF2ZSBhbiBpbnRlcnJ1cHQgbWV0aG9kLCBpdCdzIGxpbWl0ZWQgYW5kIHVucmVsaWFibGVcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1haW4gdGhyZWFkIGtlcm5lbCAke2lkfSBkb2VzIG5vdCBzdXBwb3J0IHJlbGlhYmxlIGludGVycnVwdGlvbi4gVXNlIHdvcmtlciBrZXJuZWxzIGZvciBpbnRlcnJ1cHRpYmxlIGV4ZWN1dGlvbi5gKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEludGVycnVwdCBhIHdvcmtlciBrZXJuZWwgdXNpbmcgU2hhcmVkQXJyYXlCdWZmZXIgYWNjb3JkaW5nIHRvIFB5b2RpZGUgZG9jdW1lbnRhdGlvblxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBpbnN0YW5jZSBLZXJuZWwgaW5zdGFuY2VcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gaW50ZXJydXB0IHN1Y2Nlc3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW50ZXJydXB0V29ya2VyS2VybmVsKGlkOiBzdHJpbmcsIGluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgd29ya2VyID0gaW5zdGFuY2Uud29ya2VyO1xuICAgICAgaWYgKCF3b3JrZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV29ya2VyIG5vdCBmb3VuZCBmb3Iga2VybmVsICR7aWR9YCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGFuIGludGVycnVwdCBidWZmZXIgZm9yIHRoaXMga2VybmVsXG4gICAgICBsZXQgaW50ZXJydXB0QnVmZmVyID0gdGhpcy5pbnRlcnJ1cHRCdWZmZXJzLmdldChpZCk7XG4gICAgICBcbiAgICAgIGlmICghaW50ZXJydXB0QnVmZmVyKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBTaGFyZWRBcnJheUJ1ZmZlciBmb3IgaW50ZXJydXB0IGNvbnRyb2xcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIFNoYXJlZEFycmF5QnVmZmVyIChyZXF1aXJlcyBzcGVjaWZpYyBzZWN1cml0eSBoZWFkZXJzKVxuICAgICAgICAgIGNvbnN0IHNoYXJlZEJ1ZmZlciA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKTtcbiAgICAgICAgICBpbnRlcnJ1cHRCdWZmZXIgPSBuZXcgVWludDhBcnJheShzaGFyZWRCdWZmZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEluaXRpYWxpemUgYnVmZmVyIHRvIDAgKG5vIGludGVycnVwdCBzaWduYWwpXG4gICAgICAgICAgaW50ZXJydXB0QnVmZmVyWzBdID0gMDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdG9yZSB0aGUgYnVmZmVyIGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgdGhpcy5pbnRlcnJ1cHRCdWZmZXJzLnNldChpZCwgaW50ZXJydXB0QnVmZmVyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZW5kIHRoZSBidWZmZXIgdG8gdGhlIHdvcmtlciB0byBzZXQgdXAgcHlvZGlkZS5zZXRJbnRlcnJ1cHRCdWZmZXIoKVxuICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBcIlNFVF9JTlRFUlJVUFRfQlVGRkVSXCIsXG4gICAgICAgICAgICBidWZmZXI6IGludGVycnVwdEJ1ZmZlclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3b3JrZXIgdG8gY29uZmlybSBidWZmZXIgc2V0dXBcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGludGVycnVwdCBidWZmZXIgc2V0dXBcIikpO1xuICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJJTlRFUlJVUFRfQlVGRkVSX1NFVFwiKSB7XG4gICAgICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgSW50ZXJydXB0IGJ1ZmZlciBzZXQgdXAgZm9yIGtlcm5lbCAke2lkfWApO1xuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGNyZWF0ZSBTaGFyZWRBcnJheUJ1ZmZlciBmb3Iga2VybmVsICR7aWR9LCBmYWxsaW5nIGJhY2sgdG8gbWVzc2FnZS1iYXNlZCBpbnRlcnJ1cHQ6YCwgZXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZhbGxiYWNrOiB1c2UgbWVzc2FnZS1iYXNlZCBpbnRlcnJ1cHRcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbnRlcnJ1cHRXb3JrZXJLZXJuZWxGYWxsYmFjayhpZCwgd29ya2VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBY2NvcmRpbmcgdG8gUHlvZGlkZSBkb2NzOiBTZXQgaW50ZXJydXB0IHNpZ25hbCAoMiA9IFNJR0lOVClcbiAgICAgIGNvbnNvbGUubG9nKGBTZXR0aW5nIGludGVycnVwdCBzaWduYWwgZm9yIGtlcm5lbCAke2lkfS4uLmApO1xuICAgICAgaW50ZXJydXB0QnVmZmVyWzBdID0gMjtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgUHlvZGlkZSB0byBwcm9jZXNzIHRoZSBpbnRlcnJ1cHRcbiAgICAgIC8vIFB5b2RpZGUgd2lsbCByZXNldCB0aGUgYnVmZmVyIHRvIDAgd2hlbiBpdCBwcm9jZXNzZXMgdGhlIGludGVycnVwdFxuICAgICAgbGV0IGF0dGVtcHRzID0gMDtcbiAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNTA7IC8vIENoZWNrIGZvciB1cCB0byA1IHNlY29uZHMgKDUwICogMTAwbXMpXG4gICAgICBcbiAgICAgIHdoaWxlIChhdHRlbXB0cyA8IG1heEF0dGVtcHRzICYmIGludGVycnVwdEJ1ZmZlclswXSAhPT0gMCkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgIGF0dGVtcHRzKys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChpbnRlcnJ1cHRCdWZmZXJbMF0gPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYEludGVycnVwdCBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5IGZvciBrZXJuZWwgJHtpZH0gYWZ0ZXIgJHthdHRlbXB0cyAqIDEwMH1tc2ApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW50ZXJydXB0IHNpZ25hbCBub3QgcHJvY2Vzc2VkIGZvciBrZXJuZWwgJHtpZH0gYWZ0ZXIgJHttYXhBdHRlbXB0cyAqIDEwMH1tc2ApO1xuICAgICAgICAvLyBTdGlsbCByZXR1cm4gdHJ1ZSBhcyB3ZSBzZXQgdGhlIHNpZ25hbCAtIHRoZSBpbnRlcnJ1cHQgbWF5IGJlIHByb2Nlc3NlZCBsYXRlclxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbnRlcnJ1cHRpbmcgd29ya2VyIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRmFsbGJhY2sgaW50ZXJydXB0IG1ldGhvZCBmb3Igd29ya2VyIGtlcm5lbHMgd2hlbiBTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIHdvcmtlciBXb3JrZXIgaW5zdGFuY2VcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gaW50ZXJydXB0IHN1Y2Nlc3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW50ZXJydXB0V29ya2VyS2VybmVsRmFsbGJhY2soaWQ6IHN0cmluZywgd29ya2VyOiBXb3JrZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpID0+IHtcbiAgICAgIC8vIFNldCB1cCBhIGxpc3RlbmVyIGZvciB0aGUgaW50ZXJydXB0IHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJJTlRFUlJVUFRfVFJJR0dFUkVEXCIpIHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICAgICAgICBjb25zdCBzdWNjZXNzID0gZXZlbnQuZGF0YS5kYXRhPy5zdWNjZXNzIHx8IGZhbHNlO1xuICAgICAgICAgIHJlc29sdmUoc3VjY2Vzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIExpc3RlbiBmb3IgdGhlIHJlc3BvbnNlXG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0aGUgaW50ZXJydXB0IG1lc3NhZ2VcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiSU5URVJSVVBUX0tFUk5FTFwiXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2V0IGEgdGltZW91dCBpbiBjYXNlIHdlIGRvbid0IGdldCBhIHJlc3BvbnNlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgICAgIGNvbnNvbGUud2FybihgVGltZW91dCB3YWl0aW5nIGZvciBpbnRlcnJ1cHQgcmVzcG9uc2UgZnJvbSBrZXJuZWwgJHtpZH1gKTtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9LCA1MDAwKTsgLy8gNSBzZWNvbmQgdGltZW91dFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIHN0dWNrIGV4ZWN1dGlvbiB3aXRoIGNvbmZpZ3VyYWJsZSBzdHJhdGVnaWVzXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGV4ZWN1dGlvbklkIEV4ZWN1dGlvbiBJRCB0aGF0J3Mgc3R1Y2tcbiAgICogQHBhcmFtIGFjdHVhbFJ1bnRpbWUgSG93IGxvbmcgdGhlIGV4ZWN1dGlvbiBoYXMgYmVlbiBydW5uaW5nXG4gICAqIEBwYXJhbSBjb2RlIFRoZSBjb2RlIHRoYXQgd2FzIGJlaW5nIGV4ZWN1dGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZVN0dWNrRXhlY3V0aW9uKGtlcm5lbElkOiBzdHJpbmcsIGV4ZWN1dGlvbklkOiBzdHJpbmcsIGFjdHVhbFJ1bnRpbWU6IG51bWJlciwgY29kZT86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLndhcm4oYEhhbmRsaW5nIHN0dWNrIGV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfSBvbiBrZXJuZWwgJHtrZXJuZWxJZH0gKHJ1bnRpbWU6ICR7YWN0dWFsUnVudGltZX1tcylgKTtcbiAgICBcbiAgICAvLyBTdHJhdGVneSAxOiBUcnkgdG8gaW50ZXJydXB0IHRoZSBrZXJuZWwgZmlyc3RcbiAgICBjb25zdCBpbnRlcnJ1cHRTdWNjZXNzID0gYXdhaXQgdGhpcy5pbnRlcnJ1cHRLZXJuZWwoa2VybmVsSWQpO1xuICAgIFxuICAgIGlmIChpbnRlcnJ1cHRTdWNjZXNzKSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGludGVycnVwdGVkIGtlcm5lbCAke2tlcm5lbElkfWApO1xuICAgICAgXG4gICAgICAvLyBFbWl0IGFuIGV4ZWN1dGlvbiBlcnJvciB0byBub3RpZnkgY2xpZW50c1xuICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwge1xuICAgICAgICBrZXJuZWxJZDoga2VybmVsSWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBlbmFtZTogXCJFeGVjdXRpb25JbnRlcnJ1cHRlZFwiLFxuICAgICAgICAgIGV2YWx1ZTogYEV4ZWN1dGlvbiBhdXRvbWF0aWNhbGx5IGludGVycnVwdGVkIGFmdGVyICR7YWN0dWFsUnVudGltZX1tcyAoZXhjZWVkZWQgbWF4RXhlY3V0aW9uVGltZSlgLFxuICAgICAgICAgIHRyYWNlYmFjazogW1xuICAgICAgICAgICAgYEV4ZWN1dGlvbiB3YXMgYXV0b21hdGljYWxseSBpbnRlcnJ1cHRlZCBkdWUgdG8gdGltZW91dC5gLFxuICAgICAgICAgICAgYFJ1bnRpbWU6ICR7YWN0dWFsUnVudGltZX1tc2AsXG4gICAgICAgICAgICBgTWF4IGFsbG93ZWQ6ICR7aW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lfW1zYCxcbiAgICAgICAgICAgIGNvZGUgPyBgQ29kZTogJHtjb2RlLnN1YnN0cmluZygwLCAyMDApfSR7Y29kZS5sZW5ndGggPiAyMDAgPyAnLi4uJyA6ICcnfWAgOiAnQ29kZTogPHVua25vd24+J1xuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RyYXRlZ3kgMjogSWYgaW50ZXJydXB0IGZhaWxlZCwgdHJ5IHJlc3RhcnRpbmcgdGhlIGtlcm5lbFxuICAgIGNvbnNvbGUud2FybihgSW50ZXJydXB0IGZhaWxlZCBmb3Iga2VybmVsICR7a2VybmVsSWR9LCBhdHRlbXB0aW5nIHJlc3RhcnQuLi5gKTtcbiAgICBjb25zdCByZXN0YXJ0U3VjY2VzcyA9IGF3YWl0IHRoaXMucmVzdGFydEtlcm5lbChrZXJuZWxJZCk7XG4gICAgXG4gICAgaWYgKHJlc3RhcnRTdWNjZXNzKSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHJlc3RhcnRlZCBrZXJuZWwgJHtrZXJuZWxJZH1gKTtcbiAgICAgIFxuICAgICAgLy8gRW1pdCBhIHJlc3RhcnQgbm90aWZpY2F0aW9uXG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCB7XG4gICAgICAgIGtlcm5lbElkOiBrZXJuZWxJZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYW1lOiBcIktlcm5lbFJlc3RhcnRlZFwiLFxuICAgICAgICAgIGV2YWx1ZTogYEtlcm5lbCBhdXRvbWF0aWNhbGx5IHJlc3RhcnRlZCBkdWUgdG8gc3R1Y2sgZXhlY3V0aW9uIChydW50aW1lOiAke2FjdHVhbFJ1bnRpbWV9bXMpYCxcbiAgICAgICAgICB0cmFjZWJhY2s6IFtcbiAgICAgICAgICAgIGBLZXJuZWwgd2FzIGF1dG9tYXRpY2FsbHkgcmVzdGFydGVkIGR1ZSB0byBzdHVjayBleGVjdXRpb24uYCxcbiAgICAgICAgICAgIGBSdW50aW1lOiAke2FjdHVhbFJ1bnRpbWV9bXNgLFxuICAgICAgICAgICAgYE1heCBhbGxvd2VkOiAke2luc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZX1tc2AsXG4gICAgICAgICAgICBgSW50ZXJydXB0IGF0dGVtcHQgZmFpbGVkLCBrZXJuZWwgd2FzIHJlc3RhcnRlZCBpbnN0ZWFkLmAsXG4gICAgICAgICAgICBjb2RlID8gYENvZGU6ICR7Y29kZS5zdWJzdHJpbmcoMCwgMjAwKX0ke2NvZGUubGVuZ3RoID4gMjAwID8gJy4uLicgOiAnJ31gIDogJ0NvZGU6IDx1bmtub3duPidcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFN0cmF0ZWd5IDM6IElmIHJlc3RhcnQgZmFpbGVkLCBmb3JjZSB0ZXJtaW5hdGUgdGhlIGtlcm5lbFxuICAgIGNvbnNvbGUuZXJyb3IoYFJlc3RhcnQgZmFpbGVkIGZvciBrZXJuZWwgJHtrZXJuZWxJZH0sIGZvcmNlIHRlcm1pbmF0aW5nLi4uYCk7XG4gICAgY29uc3QgdGVybWluYXRlU3VjY2VzcyA9IGF3YWl0IHRoaXMuZm9yY2VUZXJtaW5hdGVLZXJuZWwoXG4gICAgICBrZXJuZWxJZCwgXG4gICAgICBgU3R1Y2sgZXhlY3V0aW9uIGNvdWxkIG5vdCBiZSBpbnRlcnJ1cHRlZCBvciByZXN0YXJ0ZWQgKHJ1bnRpbWU6ICR7YWN0dWFsUnVudGltZX1tcylgXG4gICAgKTtcbiAgICBcbiAgICBpZiAodGVybWluYXRlU3VjY2Vzcykge1xuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSB0ZXJtaW5hdGVkIGtlcm5lbCAke2tlcm5lbElkfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gdGVybWluYXRlIGtlcm5lbCAke2tlcm5lbElkfSAtIG1hbnVhbCBpbnRlcnZlbnRpb24gbWF5IGJlIHJlcXVpcmVkYCk7XG4gICAgICBcbiAgICAgIC8vIEVtaXQgYSBjcml0aWNhbCBlcnJvclxuICAgICAgc3VwZXIuZW1pdCgna2VybmVsX3VucmVjb3ZlcmFibGUnLCB7XG4gICAgICAgIGtlcm5lbElkOiBrZXJuZWxJZCxcbiAgICAgICAgZXhlY3V0aW9uSWQ6IGV4ZWN1dGlvbklkLFxuICAgICAgICBhY3R1YWxSdW50aW1lOiBhY3R1YWxSdW50aW1lLFxuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICBtZXNzYWdlOiAnS2VybmVsIGlzIHN0dWNrIGFuZCBjb3VsZCBub3QgYmUgcmVjb3ZlcmVkIHRocm91Z2ggaW50ZXJydXB0LCByZXN0YXJ0LCBvciB0ZXJtaW5hdGlvbidcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgc3R1Y2sgZXhlY3V0aW9ucyBhY3Jvc3MgYWxsIGtlcm5lbHNcbiAgICogQHJldHVybnMgQXJyYXkgb2Ygc3R1Y2sgZXhlY3V0aW9uIGRldGFpbHNcbiAgICovXG4gIHB1YmxpYyBnZXRTdHVja0V4ZWN1dGlvbnMoKTogQXJyYXk8e1xuICAgIGtlcm5lbElkOiBzdHJpbmc7XG4gICAgZXhlY3V0aW9uSWQ6IHN0cmluZztcbiAgICBzdGFydFRpbWU6IG51bWJlcjtcbiAgICBydW50aW1lOiBudW1iZXI7XG4gICAgbWF4QWxsb3dlZDogbnVtYmVyO1xuICAgIGNvZGU/OiBzdHJpbmc7XG4gICAga2VybmVsTW9kZTogS2VybmVsTW9kZTtcbiAgICBrZXJuZWxMYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gIH0+IHtcbiAgICBjb25zdCBzdHVja0V4ZWN1dGlvbnM6IEFycmF5PHtcbiAgICAgIGtlcm5lbElkOiBzdHJpbmc7XG4gICAgICBleGVjdXRpb25JZDogc3RyaW5nO1xuICAgICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgICBydW50aW1lOiBudW1iZXI7XG4gICAgICBtYXhBbGxvd2VkOiBudW1iZXI7XG4gICAgICBjb2RlPzogc3RyaW5nO1xuICAgICAga2VybmVsTW9kZTogS2VybmVsTW9kZTtcbiAgICAgIGtlcm5lbExhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgICB9PiA9IFtdO1xuICAgIFxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IFtrZXJuZWxJZCwgaW5zdGFuY2VdIG9mIHRoaXMua2VybmVscy5lbnRyaWVzKCkpIHtcbiAgICAgIC8vIFNraXAgcG9vbCBrZXJuZWxzXG4gICAgICBpZiAoa2VybmVsSWQuc3RhcnRzV2l0aChcInBvb2wtXCIpKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBrZXJuZWxzIHdpdGhvdXQgbWF4RXhlY3V0aW9uVGltZSBjb25maWd1cmVkXG4gICAgICBpZiAoIWluc3RhbmNlLm9wdGlvbnM/Lm1heEV4ZWN1dGlvblRpbWUgfHwgaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lIDw9IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG1heEV4ZWN1dGlvblRpbWUgPSBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWU7XG4gICAgICBjb25zdCBzdGFydFRpbWVzID0gdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmdldChrZXJuZWxJZCk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZ2V0KGtlcm5lbElkKTtcbiAgICAgIGNvbnN0IG9uZ29pbmdFeGVjcyA9IHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZ2V0KGtlcm5lbElkKTtcbiAgICAgIFxuICAgICAgaWYgKCFvbmdvaW5nRXhlY3MgfHwgb25nb2luZ0V4ZWNzLnNpemUgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgZXhlY3V0aW9uSWQgb2Ygb25nb2luZ0V4ZWNzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHN0YXJ0VGltZXM/LmdldChleGVjdXRpb25JZCk7XG4gICAgICAgIGlmIChzdGFydFRpbWUgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBydW50aW1lID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGV4ZWN1dGlvbiBpcyBzdHVja1xuICAgICAgICBpZiAocnVudGltZSA+IG1heEV4ZWN1dGlvblRpbWUpIHtcbiAgICAgICAgICBjb25zdCBleGVjTWV0YWRhdGEgPSBtZXRhZGF0YT8uZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzdHVja0V4ZWN1dGlvbnMucHVzaCh7XG4gICAgICAgICAgICBrZXJuZWxJZCxcbiAgICAgICAgICAgIGV4ZWN1dGlvbklkLFxuICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgcnVudGltZSxcbiAgICAgICAgICAgIG1heEFsbG93ZWQ6IG1heEV4ZWN1dGlvblRpbWUsXG4gICAgICAgICAgICBjb2RlOiBleGVjTWV0YWRhdGE/LmNvZGUsXG4gICAgICAgICAgICBrZXJuZWxNb2RlOiBpbnN0YW5jZS5tb2RlLFxuICAgICAgICAgICAga2VybmVsTGFuZ3VhZ2U6IGluc3RhbmNlLmxhbmd1YWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU29ydCBieSBydW50aW1lIChsb25nZXN0IHJ1bm5pbmcgZmlyc3QpXG4gICAgc3R1Y2tFeGVjdXRpb25zLnNvcnQoKGEsIGIpID0+IGIucnVudGltZSAtIGEucnVudGltZSk7XG4gICAgXG4gICAgcmV0dXJuIHN0dWNrRXhlY3V0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSBpbnRlcnJ1cHQgYWxsIHN0dWNrIGV4ZWN1dGlvbnMgYWNyb3NzIGFsbCBrZXJuZWxzXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIGludGVydmVudGlvbiByZXN1bHRzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaGFuZGxlQWxsU3R1Y2tFeGVjdXRpb25zKCk6IFByb21pc2U8QXJyYXk8e1xuICAgIGtlcm5lbElkOiBzdHJpbmc7XG4gICAgZXhlY3V0aW9uSWQ6IHN0cmluZztcbiAgICBhY3Rpb246ICdpbnRlcnJ1cHRlZCcgfCAncmVzdGFydGVkJyB8ICd0ZXJtaW5hdGVkJyB8ICdmYWlsZWQnO1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgZXJyb3I/OiBzdHJpbmc7XG4gIH0+PiB7XG4gICAgY29uc3Qgc3R1Y2tFeGVjdXRpb25zID0gdGhpcy5nZXRTdHVja0V4ZWN1dGlvbnMoKTtcbiAgICBjb25zdCByZXN1bHRzOiBBcnJheTx7XG4gICAgICBrZXJuZWxJZDogc3RyaW5nO1xuICAgICAgZXhlY3V0aW9uSWQ6IHN0cmluZztcbiAgICAgIGFjdGlvbjogJ2ludGVycnVwdGVkJyB8ICdyZXN0YXJ0ZWQnIHwgJ3Rlcm1pbmF0ZWQnIHwgJ2ZhaWxlZCc7XG4gICAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgICAgZXJyb3I/OiBzdHJpbmc7XG4gICAgfT4gPSBbXTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtzdHVja0V4ZWN1dGlvbnMubGVuZ3RofSBzdHVjayBleGVjdXRpb25zIHRvIGhhbmRsZWApO1xuICAgIFxuICAgIC8vIEdyb3VwIGJ5IGtlcm5lbCB0byBhdm9pZCBtdWx0aXBsZSBpbnRlcnZlbnRpb25zIG9uIHRoZSBzYW1lIGtlcm5lbFxuICAgIGNvbnN0IGtlcm5lbEdyb3VwcyA9IG5ldyBNYXA8c3RyaW5nLCB0eXBlb2Ygc3R1Y2tFeGVjdXRpb25zPigpO1xuICAgIGZvciAoY29uc3QgZXhlYyBvZiBzdHVja0V4ZWN1dGlvbnMpIHtcbiAgICAgIGlmICgha2VybmVsR3JvdXBzLmhhcyhleGVjLmtlcm5lbElkKSkge1xuICAgICAgICBrZXJuZWxHcm91cHMuc2V0KGV4ZWMua2VybmVsSWQsIFtdKTtcbiAgICAgIH1cbiAgICAgIGtlcm5lbEdyb3Vwcy5nZXQoZXhlYy5rZXJuZWxJZCkhLnB1c2goZXhlYyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBlYWNoIGtlcm5lbCdzIHN0dWNrIGV4ZWN1dGlvbnNcbiAgICBmb3IgKGNvbnN0IFtrZXJuZWxJZCwgZXhlY3V0aW9uc10gb2Yga2VybmVsR3JvdXBzKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBQaWNrIHRoZSBsb25nZXN0IHJ1bm5pbmcgZXhlY3V0aW9uIGFzIHRoZSBwcmltYXJ5IG9uZVxuICAgICAgICBjb25zdCBwcmltYXJ5RXhlYyA9IGV4ZWN1dGlvbnNbMF07IC8vIEFscmVhZHkgc29ydGVkIGJ5IHJ1bnRpbWUgZGVzY1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYEhhbmRsaW5nIHN0dWNrIGtlcm5lbCAke2tlcm5lbElkfSB3aXRoICR7ZXhlY3V0aW9ucy5sZW5ndGh9IHN0dWNrIGV4ZWN1dGlvbnMgKHByaW1hcnk6ICR7cHJpbWFyeUV4ZWMucnVudGltZX1tcylgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSB0aGUgYXV0b21hdGVkIGhhbmRsaW5nIHN5c3RlbVxuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVN0dWNrRXhlY3V0aW9uKFxuICAgICAgICAgIGtlcm5lbElkLCBcbiAgICAgICAgICBwcmltYXJ5RXhlYy5leGVjdXRpb25JZCwgXG4gICAgICAgICAgcHJpbWFyeUV4ZWMucnVudGltZSwgXG4gICAgICAgICAgcHJpbWFyeUV4ZWMuY29kZVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFyayBhbGwgZXhlY3V0aW9ucyBmb3IgdGhpcyBrZXJuZWwgYXMgaGFuZGxlZFxuICAgICAgICBmb3IgKGNvbnN0IGV4ZWMgb2YgZXhlY3V0aW9ucykge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBrZXJuZWxJZDogZXhlYy5rZXJuZWxJZCxcbiAgICAgICAgICAgIGV4ZWN1dGlvbklkOiBleGVjLmV4ZWN1dGlvbklkLFxuICAgICAgICAgICAgYWN0aW9uOiAnaW50ZXJydXB0ZWQnLCAvLyBXZSBkb24ndCBrbm93IHRoZSBleGFjdCBhY3Rpb24sIGJ1dCBpdCB3YXMgaGFuZGxlZFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaGFuZGxpbmcgc3R1Y2sgZXhlY3V0aW9ucyBmb3Iga2VybmVsICR7a2VybmVsSWR9OmAsIGVycm9yKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1hcmsgYWxsIGV4ZWN1dGlvbnMgZm9yIHRoaXMga2VybmVsIGFzIGZhaWxlZFxuICAgICAgICBmb3IgKGNvbnN0IGV4ZWMgb2YgZXhlY3V0aW9ucykge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBrZXJuZWxJZDogZXhlYy5rZXJuZWxJZCxcbiAgICAgICAgICAgIGV4ZWN1dGlvbklkOiBleGVjLmV4ZWN1dGlvbklkLFxuICAgICAgICAgICAgYWN0aW9uOiAnZmFpbGVkJyxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBpbnRlcnJ1cHQgYnVmZmVyIGZvciBhIHdvcmtlciBrZXJuZWwgZHVyaW5nIGNyZWF0aW9uXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIHdvcmtlciBXb3JrZXIgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2V0dXBXb3JrZXJJbnRlcnJ1cHRCdWZmZXIoaWQ6IHN0cmluZywgd29ya2VyOiBXb3JrZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gUHl0aG9uIGtlcm5lbHMgc3VwcG9ydCBpbnRlcnJ1cHQgYnVmZmVyc1xuICAgICAgXG4gICAgICAvLyBGb3IgUHl0aG9uIGtlcm5lbHMsIGNyZWF0ZSBhY3R1YWwgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgIGNvbnN0IHNoYXJlZEJ1ZmZlciA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKTtcbiAgICAgIGNvbnN0IGludGVycnVwdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHNoYXJlZEJ1ZmZlcik7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgYnVmZmVyIHRvIDAgKG5vIGludGVycnVwdCBzaWduYWwpXG4gICAgICBpbnRlcnJ1cHRCdWZmZXJbMF0gPSAwO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUgYnVmZmVyIGZvciBmdXR1cmUgdXNlXG4gICAgICB0aGlzLmludGVycnVwdEJ1ZmZlcnMuc2V0KGlkLCBpbnRlcnJ1cHRCdWZmZXIpO1xuICAgICAgXG4gICAgICAvLyBTZW5kIHRoZSBidWZmZXIgdG8gdGhlIHdvcmtlciB0byBzZXQgdXAgcHlvZGlkZS5zZXRJbnRlcnJ1cHRCdWZmZXIoKVxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJTRVRfSU5URVJSVVBUX0JVRkZFUlwiLFxuICAgICAgICBidWZmZXI6IGludGVycnVwdEJ1ZmZlclxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSB3b3JrZXIgdG8gY29uZmlybSBidWZmZXIgc2V0dXBcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGludGVycnVwdCBidWZmZXIgc2V0dXBcIikpO1xuICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIklOVEVSUlVQVF9CVUZGRVJfU0VUXCIpIHtcbiAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBzZXQgdXAgaW50ZXJydXB0IGJ1ZmZlciBmb3Iga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIC8vIERvbid0IHRocm93IC0ga2VybmVsIGNhbiBzdGlsbCB3b3JrIHdpdGhvdXQgaW50ZXJydXB0IGJ1ZmZlclxuICAgIH1cbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/manager.ts\n\n}");

/***/ }),

/***/ "./src/pyodide-loader.ts":
/*!*******************************!*\
  !*** ./src/pyodide-loader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPyodideCDNUrl: () => (/* binding */ getPyodideCDNUrl),\n/* harmony export */   getPyodideIndexUrl: () => (/* binding */ getPyodideIndexUrl),\n/* harmony export */   isPyodideLoaded: () => (/* binding */ isPyodideLoaded),\n/* harmony export */   loadPyodide: () => (/* binding */ loadPyodide)\n/* harmony export */ });\n/**\n * Pyodide CDN Loader Utility\n * Dynamically loads Pyodide from CDN for both main thread and web workers\n */\nconst PYODIDE_CDN_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js';\nconst PYODIDE_INDEX_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/';\n// Global flag to track if Pyodide is loaded\nlet pyodideLoaded = false;\nlet pyodideLoadPromise = null;\n/**\n * Load Pyodide script dynamically in main thread\n */\nfunction loadPyodideScript() {\n    return new Promise((resolve, reject) => {\n        // Check if script is already loaded\n        if (typeof globalThis.loadPyodide !== 'undefined') {\n            resolve();\n            return;\n        }\n        const script = document.createElement('script');\n        script.src = PYODIDE_CDN_URL;\n        script.onload = () => resolve();\n        script.onerror = () => reject(new Error(`Failed to load Pyodide from ${PYODIDE_CDN_URL}`));\n        document.head.appendChild(script);\n    });\n}\n/**\n * Load Pyodide in web worker using importScripts\n */\nfunction loadPyodideInWorker() {\n    return new Promise((resolve, reject) => {\n        try {\n            // Check if we're in a worker environment\n            if (typeof importScripts === 'undefined') {\n                reject(new Error('importScripts is not available - not in a worker context'));\n                return;\n            }\n            // Check if already loaded\n            if (typeof globalThis.loadPyodide !== 'undefined') {\n                resolve();\n                return;\n            }\n            importScripts(PYODIDE_CDN_URL);\n            resolve();\n        }\n        catch (error) {\n            reject(new Error(`Failed to import Pyodide in worker: ${error}`));\n        }\n    });\n}\n/**\n * Initialize Pyodide with proper configuration\n */\nasync function loadPyodide(config = {}) {\n    // Return existing promise if already loading\n    if (pyodideLoadPromise) {\n        return pyodideLoadPromise;\n    }\n    pyodideLoadPromise = (async () => {\n        try {\n            // Determine if we're in a worker or main thread\n            const isWorker = typeof importScripts !== 'undefined';\n            // Load the Pyodide script\n            if (isWorker) {\n                await loadPyodideInWorker();\n            }\n            else {\n                await loadPyodideScript();\n            }\n            // Get the global loadPyodide function\n            const globalLoadPyodide = globalThis.loadPyodide;\n            if (!globalLoadPyodide) {\n                throw new Error('loadPyodide function not found after script load');\n            }\n            // Configure default options\n            const defaultConfig = {\n                indexURL: PYODIDE_INDEX_URL,\n                ...config\n            };\n            // Initialize Pyodide\n            const pyodide = await globalLoadPyodide(defaultConfig);\n            pyodideLoaded = true;\n            console.log('✅ Pyodide loaded successfully from CDN');\n            return pyodide;\n        }\n        catch (error) {\n            pyodideLoadPromise = null; // Reset on failure\n            throw error;\n        }\n    })();\n    return pyodideLoadPromise;\n}\n/**\n * Check if Pyodide is already loaded\n */\nfunction isPyodideLoaded() {\n    return pyodideLoaded && typeof globalThis.loadPyodide !== 'undefined';\n}\n/**\n * Get Pyodide CDN URL for external use\n */\nfunction getPyodideCDNUrl() {\n    return PYODIDE_CDN_URL;\n}\n/**\n * Get Pyodide index URL for external use\n */\nfunction getPyodideIndexUrl() {\n    return PYODIDE_INDEX_URL;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RztnQkFDcEIsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0IsR0FBRyxNQUFNO2FBQ1YsQ0FBQztZQUVGLHFCQUFxQjtZQUNyQixNQUFNLE9BQU8sR0FBRyxNQUFNLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3ZELGFBQWEsR0FBRyxJQUFJLENBQUM7WUFFckIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO1lBQ3RELE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2Ysa0JBQWtCLEdBQUcsSUFBSSxDQUFDLENBQUMsbUJBQW1CO1lBQzlDLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFTCxPQUFPLGtCQUFrQixDQUFDO0FBQzVCLENBQUM7QUFFRDs7R0FFRztBQUNJLFNBQVMsZUFBZTtJQUM3QixPQUFPLGFBQWEsSUFBSSxPQUFRLFVBQWtCLENBQUMsV0FBVyxLQUFLLFdBQVcsQ0FBQztBQUNqRixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxTQUFTLGdCQUFnQjtJQUM5QixPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxTQUFTLGtCQUFrQjtJQUNoQyxPQUFPLGlCQUFpQixDQUFDO0FBQzNCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9XZWJQeXRob25LZXJuZWwvLi9zcmMvcHlvZGlkZS1sb2FkZXIudHM/NTAxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFB5b2RpZGUgQ0ROIExvYWRlciBVdGlsaXR5XG4gKiBEeW5hbWljYWxseSBsb2FkcyBQeW9kaWRlIGZyb20gQ0ROIGZvciBib3RoIG1haW4gdGhyZWFkIGFuZCB3ZWIgd29ya2Vyc1xuICovXG5cbmNvbnN0IFBZT0RJREVfQ0ROX1VSTCA9ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvcHlvZGlkZS92MC4yOC4wL2Z1bGwvcHlvZGlkZS5qcyc7XG5jb25zdCBQWU9ESURFX0lOREVYX1VSTCA9ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvcHlvZGlkZS92MC4yOC4wL2Z1bGwvJztcblxuLy8gR2xvYmFsIGZsYWcgdG8gdHJhY2sgaWYgUHlvZGlkZSBpcyBsb2FkZWRcbmxldCBweW9kaWRlTG9hZGVkID0gZmFsc2U7XG5sZXQgcHlvZGlkZUxvYWRQcm9taXNlOiBQcm9taXNlPGFueT4gfCBudWxsID0gbnVsbDtcblxuLyoqXG4gKiBMb2FkIFB5b2RpZGUgc2NyaXB0IGR5bmFtaWNhbGx5IGluIG1haW4gdGhyZWFkXG4gKi9cbmZ1bmN0aW9uIGxvYWRQeW9kaWRlU2NyaXB0KCk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIENoZWNrIGlmIHNjcmlwdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgIGlmICh0eXBlb2YgKGdsb2JhbFRoaXMgYXMgYW55KS5sb2FkUHlvZGlkZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBzY3JpcHQuc3JjID0gUFlPRElERV9DRE5fVVJMO1xuICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBQeW9kaWRlIGZyb20gJHtQWU9ESURFX0NETl9VUkx9YCkpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfSk7XG59XG5cbi8qKlxuICogTG9hZCBQeW9kaWRlIGluIHdlYiB3b3JrZXIgdXNpbmcgaW1wb3J0U2NyaXB0c1xuICovXG5mdW5jdGlvbiBsb2FkUHlvZGlkZUluV29ya2VyKCk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBhIHdvcmtlciBlbnZpcm9ubWVudFxuICAgICAgaWYgKHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdpbXBvcnRTY3JpcHRzIGlzIG5vdCBhdmFpbGFibGUgLSBub3QgaW4gYSB3b3JrZXIgY29udGV4dCcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGxvYWRlZFxuICAgICAgaWYgKHR5cGVvZiAoZ2xvYmFsVGhpcyBhcyBhbnkpLmxvYWRQeW9kaWRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW1wb3J0U2NyaXB0cyhQWU9ESURFX0NETl9VUkwpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gaW1wb3J0IFB5b2RpZGUgaW4gd29ya2VyOiAke2Vycm9yfWApKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgUHlvZGlkZSB3aXRoIHByb3BlciBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkUHlvZGlkZShjb25maWc6IGFueSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gUmV0dXJuIGV4aXN0aW5nIHByb21pc2UgaWYgYWxyZWFkeSBsb2FkaW5nXG4gIGlmIChweW9kaWRlTG9hZFByb21pc2UpIHtcbiAgICByZXR1cm4gcHlvZGlkZUxvYWRQcm9taXNlO1xuICB9XG5cbiAgcHlvZGlkZUxvYWRQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlJ3JlIGluIGEgd29ya2VyIG9yIG1haW4gdGhyZWFkXG4gICAgICBjb25zdCBpc1dvcmtlciA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJztcbiAgICAgIFxuICAgICAgLy8gTG9hZCB0aGUgUHlvZGlkZSBzY3JpcHRcbiAgICAgIGlmIChpc1dvcmtlcikge1xuICAgICAgICBhd2FpdCBsb2FkUHlvZGlkZUluV29ya2VyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBsb2FkUHlvZGlkZVNjcmlwdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIGdsb2JhbCBsb2FkUHlvZGlkZSBmdW5jdGlvblxuICAgICAgY29uc3QgZ2xvYmFsTG9hZFB5b2RpZGUgPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLmxvYWRQeW9kaWRlO1xuICAgICAgaWYgKCFnbG9iYWxMb2FkUHlvZGlkZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvYWRQeW9kaWRlIGZ1bmN0aW9uIG5vdCBmb3VuZCBhZnRlciBzY3JpcHQgbG9hZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb25maWd1cmUgZGVmYXVsdCBvcHRpb25zXG4gICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICBpbmRleFVSTDogUFlPRElERV9JTkRFWF9VUkwsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBQeW9kaWRlXG4gICAgICBjb25zdCBweW9kaWRlID0gYXdhaXQgZ2xvYmFsTG9hZFB5b2RpZGUoZGVmYXVsdENvbmZpZyk7XG4gICAgICBweW9kaWRlTG9hZGVkID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBQeW9kaWRlIGxvYWRlZCBzdWNjZXNzZnVsbHkgZnJvbSBDRE4nKTtcbiAgICAgIHJldHVybiBweW9kaWRlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBweW9kaWRlTG9hZFByb21pc2UgPSBudWxsOyAvLyBSZXNldCBvbiBmYWlsdXJlXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pKCk7XG5cbiAgcmV0dXJuIHB5b2RpZGVMb2FkUHJvbWlzZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBQeW9kaWRlIGlzIGFscmVhZHkgbG9hZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1B5b2RpZGVMb2FkZWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiBweW9kaWRlTG9hZGVkICYmIHR5cGVvZiAoZ2xvYmFsVGhpcyBhcyBhbnkpLmxvYWRQeW9kaWRlICE9PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBHZXQgUHlvZGlkZSBDRE4gVVJMIGZvciBleHRlcm5hbCB1c2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB5b2RpZGVDRE5VcmwoKTogc3RyaW5nIHtcbiAgcmV0dXJuIFBZT0RJREVfQ0ROX1VSTDtcbn1cblxuLyoqXG4gKiBHZXQgUHlvZGlkZSBpbmRleCBVUkwgZm9yIGV4dGVybmFsIHVzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHlvZGlkZUluZGV4VXJsKCk6IHN0cmluZyB7XG4gIHJldHVybiBQWU9ESURFX0lOREVYX1VSTDtcbn0gIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pyodide-loader.ts\n\n}");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KernelEvents: () => (/* binding */ KernelEvents)\n/* harmony export */ });\n// Shared types and interfaces to prevent circular dependencies\n// These are extracted from index.ts to break the circular dependency\n// Events enum\nvar KernelEvents;\n(function (KernelEvents) {\n    // IOPub Channel Messages\n    KernelEvents[\"STREAM\"] = \"stream\";\n    KernelEvents[\"DISPLAY_DATA\"] = \"display_data\";\n    KernelEvents[\"UPDATE_DISPLAY_DATA\"] = \"update_display_data\";\n    KernelEvents[\"EXECUTE_RESULT\"] = \"execute_result\";\n    KernelEvents[\"EXECUTE_ERROR\"] = \"execute_error\";\n    KernelEvents[\"EXECUTE_REQUEST\"] = \"execute_request\";\n    // Input request\n    KernelEvents[\"INPUT_REQUEST\"] = \"input_request\";\n    // Output control\n    KernelEvents[\"CLEAR_OUTPUT\"] = \"clear_output\";\n    // Comm messages\n    KernelEvents[\"COMM_OPEN\"] = \"comm_open\";\n    KernelEvents[\"COMM_MSG\"] = \"comm_msg\";\n    KernelEvents[\"COMM_CLOSE\"] = \"comm_close\";\n    // Internal Events\n    KernelEvents[\"KERNEL_READY\"] = \"kernel_ready\";\n    KernelEvents[\"KERNEL_BUSY\"] = \"kernel_busy\";\n    KernelEvents[\"KERNEL_IDLE\"] = \"kernel_idle\";\n    // Special catchall for internal use\n    KernelEvents[\"ALL\"] = \"*\";\n    // Execution monitoring events\n    KernelEvents[\"EXECUTION_STALLED\"] = \"execution_stalled\";\n    // Enhanced stuck kernel handling events\n    KernelEvents[\"KERNEL_UNRECOVERABLE\"] = \"kernel_unrecoverable\";\n    KernelEvents[\"EXECUTION_INTERRUPTED\"] = \"execution_interrupted\";\n    KernelEvents[\"KERNEL_RESTARTED\"] = \"kernel_restarted\";\n    KernelEvents[\"KERNEL_TERMINATED\"] = \"kernel_terminated\";\n})(KernelEvents || (KernelEvents = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHlwZXMudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLCtEQUErRDtBQUMvRCxxRUFBcUU7QUFFckUsY0FBYztBQUNkLElBQVksWUFvQ1g7QUFwQ0QsV0FBWSxZQUFZO0lBQ3RCLHlCQUF5QjtJQUN6QixpQ0FBaUI7SUFDakIsNkNBQTZCO0lBQzdCLDJEQUEyQztJQUMzQyxpREFBaUM7SUFDakMsK0NBQStCO0lBQy9CLG1EQUFtQztJQUVuQyxnQkFBZ0I7SUFDaEIsK0NBQStCO0lBRS9CLGlCQUFpQjtJQUNqQiw2Q0FBNkI7SUFFN0IsZ0JBQWdCO0lBQ2hCLHVDQUF1QjtJQUN2QixxQ0FBcUI7SUFDckIseUNBQXlCO0lBRXpCLGtCQUFrQjtJQUNsQiw2Q0FBNkI7SUFDN0IsMkNBQTJCO0lBQzNCLDJDQUEyQjtJQUUzQixvQ0FBb0M7SUFDcEMseUJBQVM7SUFFVCw4QkFBOEI7SUFDOUIsdURBQXVDO0lBRXZDLHdDQUF3QztJQUN4Qyw2REFBNkM7SUFDN0MsK0RBQStDO0lBQy9DLHFEQUFxQztJQUNyQyx1REFBdUM7QUFDekMsQ0FBQyxFQXBDVyxZQUFZLEtBQVosWUFBWSxRQW9DdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9XZWJQeXRob25LZXJuZWwvLi9zcmMvdHlwZXMudHM/YTc2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaGFyZWQgdHlwZXMgYW5kIGludGVyZmFjZXMgdG8gcHJldmVudCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbi8vIFRoZXNlIGFyZSBleHRyYWN0ZWQgZnJvbSBpbmRleC50cyB0byBicmVhayB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeVxuXG4vLyBFdmVudHMgZW51bVxuZXhwb3J0IGVudW0gS2VybmVsRXZlbnRzIHtcbiAgLy8gSU9QdWIgQ2hhbm5lbCBNZXNzYWdlc1xuICBTVFJFQU0gPSBcInN0cmVhbVwiLFxuICBESVNQTEFZX0RBVEEgPSBcImRpc3BsYXlfZGF0YVwiLFxuICBVUERBVEVfRElTUExBWV9EQVRBID0gXCJ1cGRhdGVfZGlzcGxheV9kYXRhXCIsXG4gIEVYRUNVVEVfUkVTVUxUID0gXCJleGVjdXRlX3Jlc3VsdFwiLFxuICBFWEVDVVRFX0VSUk9SID0gXCJleGVjdXRlX2Vycm9yXCIsXG4gIEVYRUNVVEVfUkVRVUVTVCA9IFwiZXhlY3V0ZV9yZXF1ZXN0XCIsXG4gIFxuICAvLyBJbnB1dCByZXF1ZXN0XG4gIElOUFVUX1JFUVVFU1QgPSBcImlucHV0X3JlcXVlc3RcIixcbiAgXG4gIC8vIE91dHB1dCBjb250cm9sXG4gIENMRUFSX09VVFBVVCA9IFwiY2xlYXJfb3V0cHV0XCIsXG4gIFxuICAvLyBDb21tIG1lc3NhZ2VzXG4gIENPTU1fT1BFTiA9IFwiY29tbV9vcGVuXCIsXG4gIENPTU1fTVNHID0gXCJjb21tX21zZ1wiLFxuICBDT01NX0NMT1NFID0gXCJjb21tX2Nsb3NlXCIsXG4gIFxuICAvLyBJbnRlcm5hbCBFdmVudHNcbiAgS0VSTkVMX1JFQURZID0gXCJrZXJuZWxfcmVhZHlcIixcbiAgS0VSTkVMX0JVU1kgPSBcImtlcm5lbF9idXN5XCIsXG4gIEtFUk5FTF9JRExFID0gXCJrZXJuZWxfaWRsZVwiLFxuICBcbiAgLy8gU3BlY2lhbCBjYXRjaGFsbCBmb3IgaW50ZXJuYWwgdXNlXG4gIEFMTCA9IFwiKlwiLCAvLyBXaWxkY2FyZCBldmVudCB0eXBlXG4gIFxuICAvLyBFeGVjdXRpb24gbW9uaXRvcmluZyBldmVudHNcbiAgRVhFQ1VUSU9OX1NUQUxMRUQgPSBcImV4ZWN1dGlvbl9zdGFsbGVkXCIsXG4gIFxuICAvLyBFbmhhbmNlZCBzdHVjayBrZXJuZWwgaGFuZGxpbmcgZXZlbnRzXG4gIEtFUk5FTF9VTlJFQ09WRVJBQkxFID0gXCJrZXJuZWxfdW5yZWNvdmVyYWJsZVwiLFxuICBFWEVDVVRJT05fSU5URVJSVVBURUQgPSBcImV4ZWN1dGlvbl9pbnRlcnJ1cHRlZFwiLFxuICBLRVJORUxfUkVTVEFSVEVEID0gXCJrZXJuZWxfcmVzdGFydGVkXCIsXG4gIEtFUk5FTF9URVJNSU5BVEVEID0gXCJrZXJuZWxfdGVybWluYXRlZFwiXG59XG5cbi8vIEV2ZW50RW1pdHRlciBpbnRlcmZhY2UgZm9yIHR5cGluZ1xuZXhwb3J0IGludGVyZmFjZSBJRXZlbnRFbWl0dGVyIHtcbiAgb24oZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbik6IHZvaWQ7XG4gIG9mZihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKTogdm9pZDtcbiAgZW1pdChldmVudE5hbWU6IHN0cmluZywgLi4uYXJnczogYW55W10pOiB2b2lkO1xuICBzZXRNYXhMaXN0ZW5lcnMobjogbnVtYmVyKTogdm9pZDtcbn1cblxuLy8gRmlsZXN5c3RlbSBtb3VudCBvcHRpb25zXG5leHBvcnQgaW50ZXJmYWNlIElGaWxlc3lzdGVtTW91bnRPcHRpb25zIHtcbiAgZW5hYmxlZD86IGJvb2xlYW47XG4gIHJvb3Q/OiBzdHJpbmc7XG4gIG1vdW50UG9pbnQ/OiBzdHJpbmc7XG59XG5cbi8vIEtlcm5lbCBvcHRpb25zIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsT3B0aW9ucyB7XG4gIGZpbGVzeXN0ZW0/OiBJRmlsZXN5c3RlbU1vdW50T3B0aW9ucztcbiAgZW52PzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjsgLy8gRW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIHNldCBpbiB0aGUga2VybmVsXG59XG5cbi8vIEtlcm5lbCBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSUtlcm5lbCBleHRlbmRzIElFdmVudEVtaXR0ZXIge1xuICBpbml0aWFsaXplKG9wdGlvbnM/OiBJS2VybmVsT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG4gIGV4ZWN1dGUoY29kZTogc3RyaW5nLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiwgcmVzdWx0PzogYW55LCBlcnJvcj86IEVycm9yIH0+O1xuICBleGVjdXRlU3RyZWFtPyhjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSk6IEFzeW5jR2VuZXJhdG9yPGFueSwgeyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfSwgdm9pZD47XG4gIGlzSW5pdGlhbGl6ZWQoKTogYm9vbGVhbjtcbiAgaW5wdXRSZXBseShjb250ZW50OiB7IHZhbHVlOiBzdHJpbmcgfSk6IFByb21pc2U8dm9pZD47XG4gIGdldFN0YXR1cygpOiBQcm9taXNlPFwiYWN0aXZlXCIgfCBcImJ1c3lcIiB8IFwidW5rbm93blwiPjtcbiAgXG4gIC8vIEludGVycnVwdCBmdW5jdGlvbmFsaXR5XG4gIGludGVycnVwdD8oKTogUHJvbWlzZTxib29sZWFuPjtcbiAgc2V0SW50ZXJydXB0QnVmZmVyPyhidWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkO1xuICBcbiAgLy8gT3B0aW9uYWwgbWV0aG9kc1xuICBjb21wbGV0ZT8oY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIHBhcmVudD86IGFueSk6IFByb21pc2U8YW55PjtcbiAgaW5zcGVjdD8oY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIGRldGFpbF9sZXZlbDogMCB8IDEsIHBhcmVudD86IGFueSk6IFByb21pc2U8YW55PjtcbiAgaXNDb21wbGV0ZT8oY29kZTogc3RyaW5nLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XG4gIGNvbW1JbmZvPyh0YXJnZXRfbmFtZTogc3RyaW5nIHwgbnVsbCwgcGFyZW50PzogYW55KTogUHJvbWlzZTxhbnk+O1xuICBjb21tT3Blbj8oY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPHZvaWQ+O1xuICBjb21tTXNnPyhjb250ZW50OiBhbnksIHBhcmVudD86IGFueSk6IFByb21pc2U8dm9pZD47XG4gIGNvbW1DbG9zZT8oY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG4vLyBFeGVjdXRlIG9wdGlvbnMgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIElLZXJuZWxFeGVjdXRlT3B0aW9ucyB7XG4gIGNvZGU6IHN0cmluZztcbiAgc2lsZW50PzogYm9vbGVhbjtcbiAgc3RvcmVIaXN0b3J5PzogYm9vbGVhbjtcbn1cblxuLy8gTWVzc2FnZSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSU1lc3NhZ2Uge1xuICB0eXBlOiBzdHJpbmc7XG4gIGJ1bmRsZT86IGFueTtcbiAgY29udGVudD86IGFueTtcbiAgbWV0YWRhdGE/OiBhbnk7XG4gIHBhcmVudEhlYWRlcj86IGFueTtcbiAgYnVmZmVycz86IGFueTtcbiAgaWRlbnQ/OiBhbnk7XG59XG5cbi8vIEV2ZW50IGRhdGEgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIElFdmVudERhdGEge1xuICB0eXBlOiBzdHJpbmc7XG4gIGRhdGE6IGFueTtcbn0gIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/types.ts\n\n}");

/***/ }),

/***/ "./src/worker.worker.ts":
/*!******************************!*\
  !*** ./src/worker.worker.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! comlink */ \"./node_modules/comlink/dist/esm/comlink.mjs\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ \"./src/index.ts\");\n// Web Worker file for running the Kernel in a separate thread\n// Import necessary modules\n\n\n\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n}\n// Create a new kernel instance\nconst kernel = new _index__WEBPACK_IMPORTED_MODULE_1__.Kernel();\n// Variable to store the event port\nlet eventPort = null;\n// Store kernel initialization options\nlet kernelOptions = {};\n// Track current event listeners for cleanup\nlet currentEventListeners = new Map();\n// Interrupt handling for worker\nlet interruptBuffer = null;\n// Helper function to check if an error is a KeyboardInterrupt\nfunction isKeyboardInterrupt(error) {\n    return error &&\n        typeof error === 'object' &&\n        (error.type === \"KeyboardInterrupt\" ||\n            (error.message && error.message.includes(\"KeyboardInterrupt\")));\n}\n// Helper function to create KeyboardInterrupt error result\nfunction createKeyboardInterruptResult() {\n    return {\n        success: false,\n        error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n        result: {\n            payload: [],\n            status: \"error\",\n            ename: \"KeyboardInterrupt\",\n            evalue: \"Execution interrupted by user\",\n            traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n        }\n    };\n}\n// Global error handlers to prevent worker crashes\nself.addEventListener(\"error\", (event) => {\n    console.error(\"[WORKER] Global error caught:\", event.error);\n    event.preventDefault();\n});\nself.addEventListener(\"unhandledrejection\", (event) => {\n    if (isKeyboardInterrupt(event.reason)) {\n        console.log(\"[WORKER] KeyboardInterrupt caught in unhandled rejection handler - this is expected during interrupts\");\n        // Send interrupt acknowledgment if we have an event port\n        if (eventPort) {\n            eventPort.postMessage({\n                type: _types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTE_ERROR,\n                data: {\n                    ename: \"KeyboardInterrupt\",\n                    evalue: \"Execution interrupted by user\",\n                    traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n                }\n            });\n        }\n    }\n    else {\n        console.error(\"[WORKER] Unhandled promise rejection:\", event.reason);\n    }\n    event.preventDefault();\n});\n// Listen for messages to set up the event port and initialize kernel\nself.addEventListener(\"message\", (event) => {\n    if (event.data?.type === \"SET_EVENT_PORT\" && event.data?.port) {\n        // Clean up old event listeners and port before setting up new ones\n        cleanupEventForwarding();\n        // Set the new port\n        eventPort = event.data.port;\n        // If the kernel is already initialized, set up event forwarding immediately\n        if (kernel.isInitialized()) {\n            setupEventForwarding();\n        }\n    }\n    else if (event.data?.type === \"INITIALIZE_KERNEL\") {\n        // Save the options for kernel initialization\n        kernelOptions = event.data.options || {};\n        // Initialize the kernel with the provided options\n        initializeKernel(kernelOptions).catch(error => {\n            console.error(\"[WORKER] Error initializing kernel in worker:\", error);\n            if (eventPort) {\n                eventPort.postMessage({\n                    type: _types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents.EXECUTE_ERROR,\n                    data: {\n                        ename: \"WorkerInitError\",\n                        evalue: `Failed to initialize kernel: ${error.message}`,\n                        traceback: [error.stack || \"\"]\n                    }\n                });\n            }\n        });\n    }\n    else if (event.data?.type === \"SET_INTERRUPT_BUFFER\") {\n        // Handle interrupt buffer setup\n        interruptBuffer = event.data.buffer;\n        // Set the interrupt buffer in the kernel if it's initialized\n        if (kernel.isInitialized() && interruptBuffer && typeof kernel.setInterruptBuffer === 'function') {\n            kernel.setInterruptBuffer(interruptBuffer);\n            console.log(\"[WORKER] Interrupt buffer set in pyodide kernel\");\n        }\n        else if (interruptBuffer) {\n            console.log(\"[WORKER] Interrupt buffer stored, will be set when kernel initializes\");\n        }\n        const responseMessage = {\n            type: \"INTERRUPT_BUFFER_SET\",\n            data: { success: true }\n        };\n        // Send response on both channels to ensure it's received\n        if (eventPort) {\n            eventPort.postMessage(responseMessage);\n        }\n        // Also send on main worker channel in case eventPort isn't set up yet\n        self.postMessage(responseMessage);\n    }\n    else if (event.data?.type === \"INTERRUPT_KERNEL\") {\n        // Handle interrupt request\n        if (interruptBuffer) {\n            // Set interrupt signal (2 = SIGINT)\n            interruptBuffer[0] = 2;\n            const responseMessage = {\n                type: \"INTERRUPT_TRIGGERED\",\n                data: { success: true, method: \"buffer\" }\n            };\n            // Send response on both channels\n            if (eventPort) {\n                eventPort.postMessage(responseMessage);\n            }\n            self.postMessage(responseMessage);\n        }\n        else {\n            console.log(\"[WORKER] No interrupt buffer available, trying kernel.interrupt()\");\n            // Fallback to kernel interrupt method\n            if (typeof kernel.interrupt === 'function') {\n                kernel.interrupt().then(success => {\n                    const responseMessage = {\n                        type: \"INTERRUPT_TRIGGERED\",\n                        data: { success, method: \"kernel\" }\n                    };\n                    if (eventPort) {\n                        eventPort.postMessage(responseMessage);\n                    }\n                    self.postMessage(responseMessage);\n                }).catch(error => {\n                    console.error(\"[WORKER] Error during kernel interrupt:\", error);\n                    const responseMessage = {\n                        type: \"INTERRUPT_TRIGGERED\",\n                        data: { success: false, error: error.message, method: \"kernel\" }\n                    };\n                    if (eventPort) {\n                        eventPort.postMessage(responseMessage);\n                    }\n                    self.postMessage(responseMessage);\n                });\n            }\n            else {\n                console.warn(\"[WORKER] No interrupt method available\");\n                const responseMessage = {\n                    type: \"INTERRUPT_TRIGGERED\",\n                    data: { success: false, error: \"No interrupt method available\", method: \"none\" }\n                };\n                if (eventPort) {\n                    eventPort.postMessage(responseMessage);\n                }\n                self.postMessage(responseMessage);\n            }\n        }\n    }\n});\n// Initialize the kernel with provided options\nasync function initializeKernel(options) {\n    try {\n        await kernel.initialize(options);\n        // Set up the interrupt buffer if it's available and the kernel supports it\n        if (interruptBuffer && typeof kernel.setInterruptBuffer === 'function') {\n            kernel.setInterruptBuffer(interruptBuffer);\n        }\n        // Set up event forwarding AFTER kernel is initialized\n        setupEventForwarding();\n        if (eventPort) {\n            eventPort.postMessage({\n                type: \"KERNEL_INITIALIZED\",\n                data: { success: true }\n            });\n        }\n    }\n    catch (error) {\n        console.error(\"Kernel initialization failed:\", error);\n        throw error;\n    }\n}\n// Clean up old event listeners and port\nfunction cleanupEventForwarding() {\n    if (currentEventListeners.size > 0) {\n        // Remove all current event listeners\n        for (const [eventType, listener] of currentEventListeners.entries()) {\n            kernel.off(eventType, listener);\n        }\n        // Clear the listeners map\n        currentEventListeners.clear();\n    }\n    // Close the old port if it exists\n    if (eventPort) {\n        eventPort.close();\n        eventPort = null;\n    }\n}\n// Set up event forwarding from kernel to main thread\nfunction setupEventForwarding() {\n    if (!eventPort) {\n        console.error(\"[WORKER] Cannot set up event forwarding: no event port available\");\n        return;\n    }\n    // Forward all kernel events to the main thread\n    Object.values(_types__WEBPACK_IMPORTED_MODULE_0__.KernelEvents).forEach((eventType) => {\n        // Create a listener function for this event type\n        const listener = (data) => {\n            if (eventPort) {\n                // Send just the event type and raw data\n                // This matches the structure used in main thread mode\n                eventPort.postMessage({\n                    type: eventType,\n                    data: data\n                });\n            }\n        };\n        // Store the listener for later cleanup\n        currentEventListeners.set(eventType, listener);\n        // Add the listener to the kernel\n        kernel.on(eventType, listener);\n    });\n}\n// Handle cleanup when worker is terminated\nself.addEventListener(\"beforeunload\", async () => {\n    // Close any resources or connections\n    try {\n        // Send a final message before termination if needed\n        if (eventPort) {\n            eventPort.postMessage({\n                type: \"WORKER_TERMINATING\",\n                data: { message: \"Worker is shutting down\" }\n            });\n        }\n    }\n    catch (error) {\n        console.error(\"Error during worker cleanup:\", error);\n    }\n});\n// Log available methods for debugging\n// Create a simplified proxy that only exposes the methods we need\n// We're not trying to implement the full EventEmitter interface\nconst simpleProxy = {\n    // Required methods from IKernel interface\n    initialize: async (options) => {\n        try {\n            await kernel.initialize(options);\n            return undefined;\n        }\n        catch (error) {\n            console.error(\"[WORKER] Initialize error:\", error);\n            throw error;\n        }\n    },\n    execute: async (code, parent) => {\n        try {\n            const result = await kernel.execute(code, parent);\n            return result;\n        }\n        catch (error) {\n            console.error(\"[WORKER] Execute error:\", error);\n            // Check if this is a KeyboardInterrupt and handle it specially\n            if (isKeyboardInterrupt(error)) {\n                console.log(\"[WORKER] KeyboardInterrupt caught in execute method\");\n                return createKeyboardInterruptResult();\n            }\n            // Handle other errors normally\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error)),\n                result: {\n                    payload: [],\n                    status: \"error\",\n                    ename: error instanceof Error ? error.constructor.name : \"Error\",\n                    evalue: error instanceof Error ? error.message : String(error),\n                    traceback: error instanceof Error && error.stack ? error.stack.split('\\n') : [String(error)]\n                }\n            };\n        }\n    },\n    isInitialized: () => {\n        try {\n            const result = kernel.isInitialized();\n            return result;\n        }\n        catch (error) {\n            console.error(\"[WORKER] IsInitialized error:\", error);\n            return false;\n        }\n    },\n    inputReply: async (content) => {\n        try {\n            await kernel.inputReply(content);\n        }\n        catch (error) {\n            console.error(\"[WORKER] InputReply error:\", error);\n            throw error;\n        }\n    },\n    // Async method for status\n    getStatus: async () => {\n        try {\n            const status = await kernel.getStatus();\n            return status;\n        }\n        catch (error) {\n            console.error(\"[WORKER] getStatus error:\", error);\n            return \"unknown\";\n        }\n    },\n    // Interrupt functionality\n    interrupt: async () => {\n        try {\n            if (typeof kernel.interrupt === 'function') {\n                const result = await kernel.interrupt();\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support interrupt method\");\n                return false;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] Interrupt error:\", error);\n            // Don't let interrupt errors crash the worker\n            return false;\n        }\n    },\n    setInterruptBuffer: (buffer) => {\n        try {\n            if (typeof kernel.setInterruptBuffer === 'function') {\n                kernel.setInterruptBuffer(buffer);\n                return true;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support setInterruptBuffer method\");\n                return false;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] setInterruptBuffer error:\", error);\n            return false;\n        }\n    },\n    // Completion methods\n    complete: async (code, cursor_pos, parent) => {\n        try {\n            if (typeof kernel.complete === 'function') {\n                const result = await kernel.complete(code, cursor_pos, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support complete method\");\n                return { status: 'error', error: 'Completion not supported' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] Complete error:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    },\n    inspect: async (code, cursor_pos, detail_level, parent) => {\n        try {\n            if (typeof kernel.inspect === 'function') {\n                const result = await kernel.inspect(code, cursor_pos, detail_level, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support inspect method\");\n                return { status: 'error', error: 'Inspection not supported' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] Inspect error:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    },\n    isComplete: async (code, parent) => {\n        try {\n            if (typeof kernel.isComplete === 'function') {\n                const result = await kernel.isComplete(code, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support isComplete method\");\n                return { status: 'unknown' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] IsComplete error:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    },\n    // Comm methods\n    commInfo: async (target_name, parent) => {\n        try {\n            if (typeof kernel.commInfo === 'function') {\n                const result = await kernel.commInfo(target_name, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commInfo method\");\n                return { comms: {}, status: 'ok' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommInfo error:\", error);\n            return { comms: {}, status: 'error', error: String(error) };\n        }\n    },\n    commOpen: async (content, parent) => {\n        try {\n            if (typeof kernel.commOpen === 'function') {\n                const result = await kernel.commOpen(content, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commOpen method\");\n                return undefined;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommOpen error:\", error);\n            return undefined;\n        }\n    },\n    commMsg: async (content, parent) => {\n        try {\n            if (typeof kernel.commMsg === 'function') {\n                const result = await kernel.commMsg(content, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commMsg method\");\n                return undefined;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommMsg error:\", error);\n            return undefined;\n        }\n    },\n    commClose: async (content, parent) => {\n        try {\n            if (typeof kernel.commClose === 'function') {\n                const result = await kernel.commClose(content, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commClose method\");\n                return undefined;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommClose error:\", error);\n            return undefined;\n        }\n    }\n};\n// Expose the proxy through Comlink\ntry {\n    comlink__WEBPACK_IMPORTED_MODULE_2__.expose(simpleProxy);\n}\ncatch (error) {\n    console.error(\"Error exposing proxy:\", error);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFPLE1BQU0sQ0FBQztZQUNoQixDQUFDO2lCQUFNLENBQUM7Z0JBQ04sT0FBTyxDQUFDLElBQUksQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO2dCQUNsRSxPQUFPLFNBQVMsQ0FBQztZQUNuQixDQUFDO1FBQ0gsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLDJCQUEyQixFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ2xELE9BQU8sU0FBUyxDQUFDO1FBQ25CLENBQUM7SUFDSCxDQUFDO0NBQ0YsQ0FBQztBQUVGLG1DQUFtQztBQUNuQyxJQUFJLENBQUM7SUFDSCwyQ0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzlCLENBQUM7QUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO0lBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNoRCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vV2ViUHl0aG9uS2VybmVsLy4vc3JjL3dvcmtlci53b3JrZXIudHM/MmU0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZWIgV29ya2VyIGZpbGUgZm9yIHJ1bm5pbmcgdGhlIEtlcm5lbCBpbiBhIHNlcGFyYXRlIHRocmVhZFxuLy8gSW1wb3J0IG5lY2Vzc2FyeSBtb2R1bGVzXG5pbXBvcnQgKiBhcyBDb21saW5rIGZyb20gXCJjb21saW5rXCI7XG5pbXBvcnQgeyBLZXJuZWxFdmVudHMsIElLZXJuZWxPcHRpb25zIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IEtlcm5lbCB9IGZyb20gXCIuL2luZGV4XCI7XG5cbi8vIFVzZSBhIGJyb3dzZXItY29tcGF0aWJsZSBFdmVudEVtaXR0ZXJcbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgZXZlbnRzOiB7IFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uW10gfSA9IHt9O1xuXG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIG9mZihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSByZXR1cm47XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgZW1pdChldmVudE5hbWU6IHN0cmluZywgLi4uYXJnczogYW55W10pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHJldHVybjtcbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoLi4uYXJncykpO1xuICB9XG59XG5cblxuLy8gQ3JlYXRlIGEgbmV3IGtlcm5lbCBpbnN0YW5jZVxuY29uc3Qga2VybmVsID0gbmV3IEtlcm5lbCgpO1xuXG4vLyBWYXJpYWJsZSB0byBzdG9yZSB0aGUgZXZlbnQgcG9ydFxubGV0IGV2ZW50UG9ydDogTWVzc2FnZVBvcnQgfCBudWxsID0gbnVsbDtcblxuLy8gU3RvcmUga2VybmVsIGluaXRpYWxpemF0aW9uIG9wdGlvbnNcbmxldCBrZXJuZWxPcHRpb25zOiBJS2VybmVsT3B0aW9ucyA9IHt9O1xuXG4vLyBUcmFjayBjdXJyZW50IGV2ZW50IGxpc3RlbmVycyBmb3IgY2xlYW51cFxubGV0IGN1cnJlbnRFdmVudExpc3RlbmVyczogTWFwPHN0cmluZywgKGRhdGE6IGFueSkgPT4gdm9pZD4gPSBuZXcgTWFwKCk7XG5cbi8vIEludGVycnVwdCBoYW5kbGluZyBmb3Igd29ya2VyXG5sZXQgaW50ZXJydXB0QnVmZmVyOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBhbiBlcnJvciBpcyBhIEtleWJvYXJkSW50ZXJydXB0XG5mdW5jdGlvbiBpc0tleWJvYXJkSW50ZXJydXB0KGVycm9yOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIGVycm9yICYmIFxuICAgICAgICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBcbiAgICAgICAgIChlcnJvci50eXBlID09PSBcIktleWJvYXJkSW50ZXJydXB0XCIgfHwgXG4gICAgICAgICAgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIktleWJvYXJkSW50ZXJydXB0XCIpKSk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgS2V5Ym9hcmRJbnRlcnJ1cHQgZXJyb3IgcmVzdWx0XG5mdW5jdGlvbiBjcmVhdGVLZXlib2FyZEludGVycnVwdFJlc3VsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBlcnJvcjogbmV3IEVycm9yKFwiS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCIpLFxuICAgIHJlc3VsdDoge1xuICAgICAgcGF5bG9hZDogW10sXG4gICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgIGVuYW1lOiBcIktleWJvYXJkSW50ZXJydXB0XCIsXG4gICAgICBldmFsdWU6IFwiRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcIixcbiAgICAgIHRyYWNlYmFjazogW1wiS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCJdXG4gICAgfVxuICB9O1xufVxuXG4vLyBHbG9iYWwgZXJyb3IgaGFuZGxlcnMgdG8gcHJldmVudCB3b3JrZXIgY3Jhc2hlc1xuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGV2ZW50KSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBHbG9iYWwgZXJyb3IgY2F1Z2h0OlwiLCBldmVudC5lcnJvcik7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59KTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsIChldmVudCkgPT4ge1xuICBpZiAoaXNLZXlib2FyZEludGVycnVwdChldmVudC5yZWFzb24pKSB7XG4gICAgY29uc29sZS5sb2coXCJbV09SS0VSXSBLZXlib2FyZEludGVycnVwdCBjYXVnaHQgaW4gdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyIC0gdGhpcyBpcyBleHBlY3RlZCBkdXJpbmcgaW50ZXJydXB0c1wiKTtcbiAgICBcbiAgICAvLyBTZW5kIGludGVycnVwdCBhY2tub3dsZWRnbWVudCBpZiB3ZSBoYXZlIGFuIGV2ZW50IHBvcnRcbiAgICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgICBldmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYW1lOiBcIktleWJvYXJkSW50ZXJydXB0XCIsXG4gICAgICAgICAgZXZhbHVlOiBcIkV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCIsXG4gICAgICAgICAgdHJhY2ViYWNrOiBbXCJLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcIl1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb246XCIsIGV2ZW50LnJlYXNvbik7XG4gIH1cbiAgXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59KTtcblxuLy8gTGlzdGVuIGZvciBtZXNzYWdlcyB0byBzZXQgdXAgdGhlIGV2ZW50IHBvcnQgYW5kIGluaXRpYWxpemUga2VybmVsXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJTRVRfRVZFTlRfUE9SVFwiICYmIGV2ZW50LmRhdGE/LnBvcnQpIHtcbiAgICAvLyBDbGVhbiB1cCBvbGQgZXZlbnQgbGlzdGVuZXJzIGFuZCBwb3J0IGJlZm9yZSBzZXR0aW5nIHVwIG5ldyBvbmVzXG4gICAgY2xlYW51cEV2ZW50Rm9yd2FyZGluZygpO1xuICAgIFxuICAgIC8vIFNldCB0aGUgbmV3IHBvcnRcbiAgICBldmVudFBvcnQgPSBldmVudC5kYXRhLnBvcnQ7XG4gICAgXG4gICAgLy8gSWYgdGhlIGtlcm5lbCBpcyBhbHJlYWR5IGluaXRpYWxpemVkLCBzZXQgdXAgZXZlbnQgZm9yd2FyZGluZyBpbW1lZGlhdGVseVxuICAgIGlmIChrZXJuZWwuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICBzZXR1cEV2ZW50Rm9yd2FyZGluZygpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIklOSVRJQUxJWkVfS0VSTkVMXCIpIHtcbiAgICAvLyBTYXZlIHRoZSBvcHRpb25zIGZvciBrZXJuZWwgaW5pdGlhbGl6YXRpb25cbiAgICBrZXJuZWxPcHRpb25zID0gZXZlbnQuZGF0YS5vcHRpb25zIHx8IHt9O1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gICAgaW5pdGlhbGl6ZUtlcm5lbChrZXJuZWxPcHRpb25zKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gRXJyb3IgaW5pdGlhbGl6aW5nIGtlcm5lbCBpbiB3b3JrZXI6XCIsIGVycm9yKTtcbiAgICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgICAgZXZlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICB0eXBlOiBLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUixcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBlbmFtZTogXCJXb3JrZXJJbml0RXJyb3JcIixcbiAgICAgICAgICAgIGV2YWx1ZTogYEZhaWxlZCB0byBpbml0aWFsaXplIGtlcm5lbDogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgICB0cmFjZWJhY2s6IFtlcnJvci5zdGFjayB8fCBcIlwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJTRVRfSU5URVJSVVBUX0JVRkZFUlwiKSB7XG4gICAgLy8gSGFuZGxlIGludGVycnVwdCBidWZmZXIgc2V0dXBcbiAgICBpbnRlcnJ1cHRCdWZmZXIgPSBldmVudC5kYXRhLmJ1ZmZlcjtcbiAgICBcbiAgICAvLyBTZXQgdGhlIGludGVycnVwdCBidWZmZXIgaW4gdGhlIGtlcm5lbCBpZiBpdCdzIGluaXRpYWxpemVkXG4gICAgaWYgKGtlcm5lbC5pc0luaXRpYWxpemVkKCkgJiYgaW50ZXJydXB0QnVmZmVyICYmIHR5cGVvZiBrZXJuZWwuc2V0SW50ZXJydXB0QnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBrZXJuZWwuc2V0SW50ZXJydXB0QnVmZmVyKGludGVycnVwdEJ1ZmZlcik7XG4gICAgICBjb25zb2xlLmxvZyhcIltXT1JLRVJdIEludGVycnVwdCBidWZmZXIgc2V0IGluIHB5b2RpZGUga2VybmVsXCIpO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJydXB0QnVmZmVyKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltXT1JLRVJdIEludGVycnVwdCBidWZmZXIgc3RvcmVkLCB3aWxsIGJlIHNldCB3aGVuIGtlcm5lbCBpbml0aWFsaXplc1wiKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgdHlwZTogXCJJTlRFUlJVUFRfQlVGRkVSX1NFVFwiLFxuICAgICAgZGF0YTogeyBzdWNjZXNzOiB0cnVlIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIFNlbmQgcmVzcG9uc2Ugb24gYm90aCBjaGFubmVscyB0byBlbnN1cmUgaXQncyByZWNlaXZlZFxuICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHNvIHNlbmQgb24gbWFpbiB3b3JrZXIgY2hhbm5lbCBpbiBjYXNlIGV2ZW50UG9ydCBpc24ndCBzZXQgdXAgeWV0XG4gICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgIFxuICB9IGVsc2UgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IFwiSU5URVJSVVBUX0tFUk5FTFwiKSB7XG4gICAgLy8gSGFuZGxlIGludGVycnVwdCByZXF1ZXN0XG4gICAgXG4gICAgaWYgKGludGVycnVwdEJ1ZmZlcikge1xuICAgICAgLy8gU2V0IGludGVycnVwdCBzaWduYWwgKDIgPSBTSUdJTlQpXG4gICAgICBpbnRlcnJ1cHRCdWZmZXJbMF0gPSAyO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSB7XG4gICAgICAgIHR5cGU6IFwiSU5URVJSVVBUX1RSSUdHRVJFRFwiLFxuICAgICAgICBkYXRhOiB7IHN1Y2Nlc3M6IHRydWUsIG1ldGhvZDogXCJidWZmZXJcIiB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBTZW5kIHJlc3BvbnNlIG9uIGJvdGggY2hhbm5lbHNcbiAgICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgICAgZXZlbnRQb3J0LnBvc3RNZXNzYWdlKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJbV09SS0VSXSBObyBpbnRlcnJ1cHQgYnVmZmVyIGF2YWlsYWJsZSwgdHJ5aW5nIGtlcm5lbC5pbnRlcnJ1cHQoKVwiKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2sgdG8ga2VybmVsIGludGVycnVwdCBtZXRob2RcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBrZXJuZWwuaW50ZXJydXB0KCkudGhlbihzdWNjZXNzID0+IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIklOVEVSUlVQVF9UUklHR0VSRURcIixcbiAgICAgICAgICAgIGRhdGE6IHsgc3VjY2VzcywgbWV0aG9kOiBcImtlcm5lbFwiIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgICAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gRXJyb3IgZHVyaW5nIGtlcm5lbCBpbnRlcnJ1cHQ6XCIsIGVycm9yKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIklOVEVSUlVQVF9UUklHR0VSRURcIixcbiAgICAgICAgICAgIGRhdGE6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlLCBtZXRob2Q6IFwia2VybmVsXCIgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGV2ZW50UG9ydCkge1xuICAgICAgICAgICAgZXZlbnRQb3J0LnBvc3RNZXNzYWdlKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBObyBpbnRlcnJ1cHQgbWV0aG9kIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgICAgIHR5cGU6IFwiSU5URVJSVVBUX1RSSUdHRVJFRFwiLFxuICAgICAgICAgIGRhdGE6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIk5vIGludGVycnVwdCBtZXRob2QgYXZhaWxhYmxlXCIsIG1ldGhvZDogXCJub25lXCIgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKGV2ZW50UG9ydCkge1xuICAgICAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCBwcm92aWRlZCBvcHRpb25zXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplS2VybmVsKG9wdGlvbnM6IElLZXJuZWxPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgYXdhaXQga2VybmVsLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgXG4gICAgLy8gU2V0IHVwIHRoZSBpbnRlcnJ1cHQgYnVmZmVyIGlmIGl0J3MgYXZhaWxhYmxlIGFuZCB0aGUga2VybmVsIHN1cHBvcnRzIGl0XG4gICAgaWYgKGludGVycnVwdEJ1ZmZlciAmJiB0eXBlb2Yga2VybmVsLnNldEludGVycnVwdEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAga2VybmVsLnNldEludGVycnVwdEJ1ZmZlcihpbnRlcnJ1cHRCdWZmZXIpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgdXAgZXZlbnQgZm9yd2FyZGluZyBBRlRFUiBrZXJuZWwgaXMgaW5pdGlhbGl6ZWRcbiAgICBzZXR1cEV2ZW50Rm9yd2FyZGluZygpO1xuICAgIFxuICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiS0VSTkVMX0lOSVRJQUxJWkVEXCIsXG4gICAgICAgIGRhdGE6IHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIktlcm5lbCBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBDbGVhbiB1cCBvbGQgZXZlbnQgbGlzdGVuZXJzIGFuZCBwb3J0XG5mdW5jdGlvbiBjbGVhbnVwRXZlbnRGb3J3YXJkaW5nKCkge1xuICBpZiAoY3VycmVudEV2ZW50TGlzdGVuZXJzLnNpemUgPiAwKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCBjdXJyZW50IGV2ZW50IGxpc3RlbmVyc1xuICAgIGZvciAoY29uc3QgW2V2ZW50VHlwZSwgbGlzdGVuZXJdIG9mIGN1cnJlbnRFdmVudExpc3RlbmVycy5lbnRyaWVzKCkpIHtcbiAgICAgIChrZXJuZWwgYXMgdW5rbm93biBhcyBFdmVudEVtaXR0ZXIpLm9mZihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIGxpc3RlbmVycyBtYXBcbiAgICBjdXJyZW50RXZlbnRMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxuICBcbiAgLy8gQ2xvc2UgdGhlIG9sZCBwb3J0IGlmIGl0IGV4aXN0c1xuICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgZXZlbnRQb3J0LmNsb3NlKCk7XG4gICAgZXZlbnRQb3J0ID0gbnVsbDtcbiAgfVxufVxuXG4vLyBTZXQgdXAgZXZlbnQgZm9yd2FyZGluZyBmcm9tIGtlcm5lbCB0byBtYWluIHRocmVhZFxuZnVuY3Rpb24gc2V0dXBFdmVudEZvcndhcmRpbmcoKSB7XG4gIGlmICghZXZlbnRQb3J0KSB7XG4gICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIENhbm5vdCBzZXQgdXAgZXZlbnQgZm9yd2FyZGluZzogbm8gZXZlbnQgcG9ydCBhdmFpbGFibGVcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yd2FyZCBhbGwga2VybmVsIGV2ZW50cyB0byB0aGUgbWFpbiB0aHJlYWRcbiAgT2JqZWN0LnZhbHVlcyhLZXJuZWxFdmVudHMpLmZvckVhY2goKGV2ZW50VHlwZSkgPT4ge1xuICAgIC8vIENyZWF0ZSBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciB0aGlzIGV2ZW50IHR5cGVcbiAgICBjb25zdCBsaXN0ZW5lciA9IChkYXRhOiBhbnkpID0+IHtcbiAgICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgICAgLy8gU2VuZCBqdXN0IHRoZSBldmVudCB0eXBlIGFuZCByYXcgZGF0YVxuICAgICAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHN0cnVjdHVyZSB1c2VkIGluIG1haW4gdGhyZWFkIG1vZGVcbiAgICAgICAgZXZlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICB0eXBlOiBldmVudFR5cGUsXG4gICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIFN0b3JlIHRoZSBsaXN0ZW5lciBmb3IgbGF0ZXIgY2xlYW51cFxuICAgIGN1cnJlbnRFdmVudExpc3RlbmVycy5zZXQoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgXG4gICAgLy8gQWRkIHRoZSBsaXN0ZW5lciB0byB0aGUga2VybmVsXG4gICAgKGtlcm5lbCBhcyB1bmtub3duIGFzIEV2ZW50RW1pdHRlcikub24oZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gIH0pO1xufVxuXG4vLyBIYW5kbGUgY2xlYW51cCB3aGVuIHdvcmtlciBpcyB0ZXJtaW5hdGVkXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgYXN5bmMgKCkgPT4ge1xuICAvLyBDbG9zZSBhbnkgcmVzb3VyY2VzIG9yIGNvbm5lY3Rpb25zXG4gIHRyeSB7XG4gICAgLy8gU2VuZCBhIGZpbmFsIG1lc3NhZ2UgYmVmb3JlIHRlcm1pbmF0aW9uIGlmIG5lZWRlZFxuICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiV09SS0VSX1RFUk1JTkFUSU5HXCIsXG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogXCJXb3JrZXIgaXMgc2h1dHRpbmcgZG93blwiIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIHdvcmtlciBjbGVhbnVwOlwiLCBlcnJvcik7XG4gIH1cbn0pO1xuXG4vLyBMb2cgYXZhaWxhYmxlIG1ldGhvZHMgZm9yIGRlYnVnZ2luZ1xuXG4vLyBDcmVhdGUgYSBzaW1wbGlmaWVkIHByb3h5IHRoYXQgb25seSBleHBvc2VzIHRoZSBtZXRob2RzIHdlIG5lZWRcbi8vIFdlJ3JlIG5vdCB0cnlpbmcgdG8gaW1wbGVtZW50IHRoZSBmdWxsIEV2ZW50RW1pdHRlciBpbnRlcmZhY2VcbmNvbnN0IHNpbXBsZVByb3h5ID0ge1xuICAvLyBSZXF1aXJlZCBtZXRob2RzIGZyb20gSUtlcm5lbCBpbnRlcmZhY2VcbiAgaW5pdGlhbGl6ZTogYXN5bmMgKG9wdGlvbnM/OiBJS2VybmVsT3B0aW9ucykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBrZXJuZWwuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBJbml0aWFsaXplIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG4gIFxuICBleGVjdXRlOiBhc3luYyAoY29kZTogc3RyaW5nLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsLmV4ZWN1dGUoY29kZSwgcGFyZW50KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBFeGVjdXRlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBLZXlib2FyZEludGVycnVwdCBhbmQgaGFuZGxlIGl0IHNwZWNpYWxseVxuICAgICAgaWYgKGlzS2V5Ym9hcmRJbnRlcnJ1cHQoZXJyb3IpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1dPUktFUl0gS2V5Ym9hcmRJbnRlcnJ1cHQgY2F1Z2h0IGluIGV4ZWN1dGUgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlS2V5Ym9hcmRJbnRlcnJ1cHRSZXN1bHQoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIG90aGVyIGVycm9ycyBub3JtYWxseVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSksXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIHBheWxvYWQ6IFtdLFxuICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxuICAgICAgICAgIGVuYW1lOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IuY29uc3RydWN0b3IubmFtZSA6IFwiRXJyb3JcIixcbiAgICAgICAgICBldmFsdWU6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICB0cmFjZWJhY2s6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3Iuc3RhY2sgPyBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykgOiBbU3RyaW5nKGVycm9yKV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIFxuICBpc0luaXRpYWxpemVkOiAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbC5pc0luaXRpYWxpemVkKCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gSXNJbml0aWFsaXplZCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgXG4gIGlucHV0UmVwbHk6IGFzeW5jIChjb250ZW50OiB7IHZhbHVlOiBzdHJpbmcgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBrZXJuZWwuaW5wdXRSZXBseShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIElucHV0UmVwbHkgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8vIEFzeW5jIG1ldGhvZCBmb3Igc3RhdHVzXG4gIGdldFN0YXR1czogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBrZXJuZWwuZ2V0U3RhdHVzKCk7XG4gICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gZ2V0U3RhdHVzIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgfVxuICB9LFxuICBcbiAgLy8gSW50ZXJydXB0IGZ1bmN0aW9uYWxpdHlcbiAgaW50ZXJydXB0OiBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWwuaW50ZXJydXB0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBLZXJuZWwgZG9lcyBub3Qgc3VwcG9ydCBpbnRlcnJ1cHQgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBJbnRlcnJ1cHQgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIC8vIERvbid0IGxldCBpbnRlcnJ1cHQgZXJyb3JzIGNyYXNoIHRoZSB3b3JrZXJcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIFxuICBzZXRJbnRlcnJ1cHRCdWZmZXI6IChidWZmZXI6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBrZXJuZWwuc2V0SW50ZXJydXB0QnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGtlcm5lbC5zZXRJbnRlcnJ1cHRCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBLZXJuZWwgZG9lcyBub3Qgc3VwcG9ydCBzZXRJbnRlcnJ1cHRCdWZmZXIgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBzZXRJbnRlcnJ1cHRCdWZmZXIgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIFxuICAvLyBDb21wbGV0aW9uIG1ldGhvZHNcbiAgY29tcGxldGU6IGFzeW5jIChjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5jb21wbGV0ZShjb2RlLCBjdXJzb3JfcG9zLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgY29tcGxldGUgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiAnQ29tcGxldGlvbiBub3Qgc3VwcG9ydGVkJyB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gQ29tcGxldGUgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICB9XG4gIH0sXG4gIFxuICBpbnNwZWN0OiBhc3luYyAoY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIGRldGFpbF9sZXZlbDogMCB8IDEsIHBhcmVudD86IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5pbnNwZWN0KGNvZGUsIGN1cnNvcl9wb3MsIGRldGFpbF9sZXZlbCwgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXT1JLRVJdIEtlcm5lbCBkb2VzIG5vdCBzdXBwb3J0IGluc3BlY3QgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiAnSW5zcGVjdGlvbiBub3Qgc3VwcG9ydGVkJyB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gSW5zcGVjdCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgIH1cbiAgfSxcbiAgXG4gIGlzQ29tcGxldGU6IGFzeW5jIChjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5pc0NvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5pc0NvbXBsZXRlKGNvZGUsIHBhcmVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBLZXJuZWwgZG9lcyBub3Qgc3VwcG9ydCBpc0NvbXBsZXRlIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAndW5rbm93bicgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIElzQ29tcGxldGUgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICB9XG4gIH0sXG4gIFxuICAvLyBDb21tIG1ldGhvZHNcbiAgY29tbUluZm86IGFzeW5jICh0YXJnZXRfbmFtZTogc3RyaW5nIHwgbnVsbCwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmNvbW1JbmZvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5jb21tSW5mbyh0YXJnZXRfbmFtZSwgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXT1JLRVJdIEtlcm5lbCBkb2VzIG5vdCBzdXBwb3J0IGNvbW1JbmZvIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIHsgY29tbXM6IHt9LCBzdGF0dXM6ICdvaycgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIENvbW1JbmZvIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBjb21tczoge30sIHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICB9XG4gIH0sXG4gIFxuICBjb21tT3BlbjogYXN5bmMgKGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmNvbW1PcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5jb21tT3Blbihjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgY29tbU9wZW4gbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gQ29tbU9wZW4gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICBcbiAgY29tbU1zZzogYXN5bmMgKGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmNvbW1Nc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsLmNvbW1Nc2coY29udGVudCwgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXT1JLRVJdIEtlcm5lbCBkb2VzIG5vdCBzdXBwb3J0IGNvbW1Nc2cgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gQ29tbU1zZyBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIFxuICBjb21tQ2xvc2U6IGFzeW5jIChjb250ZW50OiBhbnksIHBhcmVudD86IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5jb21tQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsLmNvbW1DbG9zZShjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgY29tbUNsb3NlIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIENvbW1DbG9zZSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEV4cG9zZSB0aGUgcHJveHkgdGhyb3VnaCBDb21saW5rXG50cnkge1xuICBDb21saW5rLmV4cG9zZShzaW1wbGVQcm94eSk7XG59IGNhdGNoIChlcnJvcikge1xuICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZXhwb3NpbmcgcHJveHk6XCIsIGVycm9yKTtcbn0gIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/worker.worker.ts\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/manager.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});